<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ningning0908.github.io","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="光、温暖、温柔">
<meta property="og:type" content="website">
<meta property="og:title" content="学习笔记">
<meta property="og:url" content="https://ningning0908.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:description" content="光、温暖、温柔">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ning Ning">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ningning0908.github.io/blog/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>学习笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">学习笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/05/15/HTML5+CSS3/HTML5%E6%A0%87%E7%AD%BE(%E4%B8%8B)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/05/15/HTML5+CSS3/HTML5%E6%A0%87%E7%AD%BE(%E4%B8%8B)/" class="post-title-link" itemprop="url">HTML标签(下)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-15 13:04:36" itemprop="dateCreated datePublished" datetime="2020-05-15T13:04:36+08:00">2020-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-17 23:44:23" itemprop="dateModified" datetime="2020-05-17T23:44:23+08:00">2020-05-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/HTML5-CSS3/" itemprop="url" rel="index"><span itemprop="name">HTML5+CSS3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><h3 id="表格标签的基本语法"><a href="#表格标签的基本语法" class="headerlink" title="表格标签的基本语法:"></a>表格标签的基本语法:</h3><ul>
<li><ol>
<li><code>&lt;table&gt;&lt;/table&gt;</code>是用于定义表格的标签。</li>
</ol>
</li>
<li><ol start="2">
<li><code>&lt;tr&gt;&lt;/tr&gt;</code>标签用于定义表格中的行，必须嵌套在<code>&lt;table&gt;&lt;/table&gt;</code>标签中。</li>
</ol>
</li>
<li><ol start="3">
<li><code>&lt;td&gt;&lt;/td&gt;</code>用于定义表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中。</li>
</ol>
</li>
<li><ol start="4">
<li>字母td指表格数据(table data)，即数据单元格的内容。</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h3><p><code>&lt;th&gt;</code>标签表示HTML表格的表头部分(table head)：会加粗居中</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>刘德华<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>56<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>张学友<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>56<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><p>表格标签这部分属性在实际开发中不常用，后面用CSS来设置。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>align</td>
<td>left  center  right</td>
<td>规定相对周围元素的对齐方式</td>
</tr>
<tr>
<td>border</td>
<td>1或””</td>
<td>规定表格单元是否拥有边框，默认为””,表示没有边框</td>
</tr>
<tr>
<td>cellpadding</td>
<td>像素值</td>
<td>规定单元边沿其内容之间的空白，默认1像素</td>
</tr>
<tr>
<td>cellspacing</td>
<td>像素值</td>
<td>规定单元格之间的空白，默认2像素</td>
</tr>
<tr>
<td>width</td>
<td>像素值或百分比</td>
<td>规定表格的宽度</td>
</tr>
</tbody></table>
<h3 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h3><p>表格分为头部区域与主体区域<br><code>&lt;thead&gt;&lt;/thead&gt;</code>表示表格的头部区域，<code>&lt;tbody&gt;&lt;/tbody&gt;</code>表示表格的主体区域。</p>
<h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><ul>
<li>1.合并单元格的方式：<ul>
<li>跨行合并：rowspan=”合并单元格的个数”，最上侧为目标单元格，写合并代码；</li>
<li>跨列合并：colspan=”合并单元格的个数”，最左侧为目标单元格，写合并代码。</li>
</ul>
</li>
<li>2.合并单元格三部曲：<ul>
<li>先确定是跨行还是跨列</li>
<li>找到目标单元格，写上合并方式=”合并的单元格数量”，比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code></li>
<li>删除多余的单元格</li>
</ul>
</li>
</ul>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>表格是用来展示数据的，列表是用来布局的，列表最大的特点就是整洁、有序，它作为布局会更加自由和方便。</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p><code>&lt;ul&gt;&lt;/ul&gt;</code>标签表示HTML页面中的无序列表，一般会以项目符号呈现列表项，而列表项使用<code>&lt;li&gt;&lt;/li&gt;</code>标签定义。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.无序列表的各个列表项之间没有顺序级别之分，是并列的。</li>
<li>2.<code>&lt;ul&gt;&lt;/ul&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ul&gt;&lt;/ul&gt;</code>中输入其它标签或者文字的做法是不被允许的。</li>
<li>3.<code>&lt;li&gt;&lt;/li&gt;</code>相当于一个容器，可以容纳所有元素。</li>
<li>4.无序列表会带有自己的样式属性，但在实际应用时，我们使用CSS来设置。</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在HTML中，<code>&lt;ol&gt;</code>标签用于定义有序列表，列表排序以数字来显示，并且使用<code>&lt;li&gt;</code>标签来定义列表项。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.<code>&lt;ol&gt;&lt;/ol&gt;</code>中只能放<code>&lt;li&gt;&lt;/li&gt;</code>，不允许放其他元素。</li>
<li>2.<code>&lt;li&gt;&lt;/li&gt;</code>相当于一个容器，可以容纳所有元素。</li>
<li>3.有序列表会带有自己的样式属性，但在实际应用时，我们使用CSS来设置。</li>
</ul>
<h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>自定义列表经常用于对术语或者名词进行解释和描述，定义列表的列表项前没有任何项目符号。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释3<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.<code>&lt;dl&gt;</code>里只能出现<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code></li>
<li>2.<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code>标签个数无限制</li>
</ul>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>使用表单标签的目的是为了收集用户信息，在HTML中，一个完整的表单通常由表单域、表单控件(表单元素)和提示信息3个部分组成。</p>
<h3 id="表单域：是一个包含表单元素的区域。"><a href="#表单域：是一个包含表单元素的区域。" class="headerlink" title="表单域：是一个包含表单元素的区域。"></a>表单域：是一个包含表单元素的区域。</h3><p>在HTML中，<code>&lt;form&gt;&lt;/form&gt;</code>标签用于定义表单域，以实现用户信息的收集和传递。<code>&lt;form&gt;&lt;/form&gt;</code>会把它范围内的表单元素提交给服务器。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"url地址"</span> <span class="attr">method</span>=<span class="string">"提交方式"</span> <span class="attr">name</span>=<span class="string">"表单域名称"</span>&gt;</span>各种表单元素控件<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>action</td>
<td>url地址</td>
<td>用于指定接收并处理表单数据的服务器程序的url地址</td>
</tr>
<tr>
<td>method</td>
<td>get/post</td>
<td>用于设置表单数据的提交方式，其取值为get/post</td>
</tr>
<tr>
<td>name</td>
<td>名称</td>
<td>用于指定表单的名称，以区分一个页面中的多个表单域</td>
</tr>
</tbody></table>
<h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><p><strong><code>&lt;input&gt;</code>表单元素：用于手机用户信息。</strong><br>语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"属性"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>type属性的属性值及其描述如下：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>button</td>
<td>定义可点击按钮</td>
</tr>
<tr>
<td>checkbox</td>
<td>定义复选框</td>
</tr>
<tr>
<td>file</td>
<td>定义输入字段和”浏览”按钮，供文件上传</td>
</tr>
<tr>
<td>hidden</td>
<td>定义隐藏的输入字段</td>
</tr>
<tr>
<td>image</td>
<td>定义图像形式的提交按钮</td>
</tr>
<tr>
<td>password</td>
<td>定义密码字段，该字段的字符被掩码</td>
</tr>
<tr>
<td>radio</td>
<td>定义单选按钮</td>
</tr>
<tr>
<td>reset</td>
<td>定义重置按钮，重置按钮会清除表单中的所有数据</td>
</tr>
<tr>
<td>submit</td>
<td>定义提交按钮，提交按钮会把表单数据发送到服务器</td>
</tr>
<tr>
<td>text</td>
<td>定义单行的输入字段，用户可在其中输入文本，默认宽度20个字符</td>
</tr>
</tbody></table>
<p>除type属性外，还有其他属性，其常用属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>由用户定义</td>
<td>定义input元素的名称</td>
</tr>
<tr>
<td>value</td>
<td>由用户定义</td>
<td>定义input元素的值</td>
</tr>
<tr>
<td>checked</td>
<td>checked</td>
<td>规定此input元素首次加载时应当被选中</td>
</tr>
<tr>
<td>maxlength</td>
<td>正整数</td>
<td>规定输入字段的字符的最大长度</td>
</tr>
</tbody></table>
<p>**<code>&lt;label&gt;</code>标签为<code>&lt;input&gt;</code>元素标注（标签）<br><code>&lt;label&gt;</code>标签用于绑定一个表单元素，当点击<code>&lt;label&gt;</code>标签的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验。<br>语法如下：<code>&lt;label&gt;</code>标签中的for属性与相应的元素的id属性相同。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">id</span>=<span class="string">"sex"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>&lt;select&gt;</code>下拉表单元素</strong><br>在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.<code>&lt;select&gt;</code>中至少包含一对<code>&lt;option&gt;</code></li>
<li>2.在<code>&lt;option&gt;</code>中定义selected=”selected”时，当前项即为默认选项。</li>
</ul>
<p><strong><code>&lt;textarea&gt;</code>文本域元素</strong><br>当用户输入内容较多的情况下，不能使用文本框表单了，就使用文本域元素。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"3"</span> <span class="attr">cols</span>=<span class="string">"20"</span>&gt;</span>文本内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>&lt;textarea&gt;</code>可以轻松地创建行文本输入框,cols=”每行的字符数”，rows=”显示的行数”(实际开发中不会使用，都是用CSS来改变大小)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/05/14/HTML5+CSS3/HTML5%E6%A0%87%E7%AD%BE(%E4%B8%8A)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/05/14/HTML5+CSS3/HTML5%E6%A0%87%E7%AD%BE(%E4%B8%8A)/" class="post-title-link" itemprop="url">HTML标签(上)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-14 15:48:41 / 修改时间：17:05:33" itemprop="dateCreated datePublished" datetime="2020-05-14T15:48:41+08:00">2020-05-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/HTML5-CSS3/" itemprop="url" rel="index"><span itemprop="name">HTML5+CSS3</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p>标题标签按照标题的大小分为6级，分别是<code>&lt;h1&gt;&lt;/h1&gt;——&lt;h6&gt;&lt;/h6&gt;</code></p>
<h2 id="段落标签和换行标签"><a href="#段落标签和换行标签" class="headerlink" title="段落标签和换行标签"></a>段落标签和换行标签</h2><p>段落标签：<code>&lt;p&gt;&lt;/p&gt;</code><br>换行标签：<code>&lt;br /&gt;</code></p>
<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><p>加粗： <code>&lt;strong&gt;&lt;/strong&gt;</code>或<code>&lt;b&gt;&lt;/b&gt;</code>  (推荐使用<code>&lt;strong&gt;&lt;/strong&gt;</code>)<br>倾斜： <code>&lt;em&gt;&lt;/em&gt;</code>或<code>&lt;i&gt;&lt;/i&gt;</code>    (推荐使用<code>&lt;em&gt;&lt;/em&gt;</code>)<br>删除线：<code>&lt;del&gt;&lt;/del&gt;</code>或<code>&lt;s&gt;&lt;/s&gt;</code> (推荐使用<code>&lt;del&gt;&lt;/del&gt;</code>)<br>下划线：<code>&lt;ins&gt;&lt;/ins&gt;</code>或<code>&lt;u&gt;&lt;/u&gt;</code> (推荐使用<code>&lt;ins&gt;&lt;/ins&gt;</code>)</p>
<h2 id="lt-div-gt-和-lt-span-gt"><a href="#lt-div-gt-和-lt-span-gt" class="headerlink" title="&lt;div&gt;和&lt;span&gt;"></a><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code></h2><p><code>&lt;div&gt;&lt;/div&gt;</code>是盒子标签，一行只能放一个<br><code>&lt;span&gt;&lt;/span&gt;</code>也是盒子标签，一行可以放多个，中间不占距离</p>
<h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><p><code>&lt;img src=&quot;图像URL&quot; /&gt;</code> src是<code>&lt;img&gt;</code>标签的必须属性，它用于指定图像文件的路径和文件名</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>图片路径</td>
<td>必须属性</td>
</tr>
<tr>
<td>alt</td>
<td>文本</td>
<td>替换文本，图像不能显示时的文字</td>
</tr>
<tr>
<td>title</td>
<td>文本</td>
<td>提示文本，鼠标放到图像上显示的文字</td>
</tr>
<tr>
<td>width</td>
<td>像素</td>
<td>设置图像的宽度</td>
</tr>
<tr>
<td>height</td>
<td>像素</td>
<td>设置图像的高度</td>
</tr>
<tr>
<td>border</td>
<td>像素</td>
<td>设置图像的边框粗细</td>
</tr>
</tbody></table>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>以引用文件位置为参考基础，而建立的目录路径。</p>
<table>
<thead>
<tr>
<th>相对路径分类</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>同一级路径</td>
<td></td>
<td>图像位于HTML文件同一级，如<code>&lt;img src=&quot;baidu.gif&quot; /&gt;</code></td>
</tr>
<tr>
<td>下一级路径</td>
<td>/</td>
<td>图像位于HTML文件同一级, 如<code>&lt;img src=&quot;images/baidu.gif&quot; /&gt;</code></td>
</tr>
<tr>
<td>上一级路径</td>
<td>../</td>
<td>图像位于HTML文件上一级， 如<code>&lt;img src=&quot;../baidu.gif&quot; /&gt;</code></td>
</tr>
</tbody></table>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。<br>例如：”D:\blog\images\logo.gif” 或者完整的网络地址 “<a href="https://www.itcast.cn/images/logo.gif&quot;" target="_blank" rel="noopener">https://www.itcast.cn/images/logo.gif&quot;</a></p>
<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><p><code>&lt;a&gt;</code>标签用于定义超链接，作用是从一个页面到另一个页面。<br>语法：<code>&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或者图像&lt;/a&gt;</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>用于指定链接目标的url地址，是必须属性，当为标签应用href属性时，它就具有了超链接的功能</td>
</tr>
<tr>
<td>target</td>
<td>用于指定链接页面的打开方式，其中_self 为默认值，_blank为在新窗口中的打开方式</td>
</tr>
</tbody></table>
<p>链接分类</p>
<ul>
<li><ol>
<li>外部链接：例如<code>&lt;a href=&quot;http://www.qq.com&quot; target=&quot;_blank&quot;&gt;腾讯&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="2">
<li>内部链接： 网站内部页面之间的相互链接，直接链接内部页面名称即可。例如：<br><code>&lt;a href=&quot;gongsijianjie.html&quot;&gt;公司简介&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="3">
<li>空链接：如果当时没有确定链接目标时，可以设置<code>&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="4">
<li>下载链接：如果href里面地址是一个文件或者压缩包，会下载这个文件，地址链接的是文件、.exe或者.zip等形式。<br>例如：<code>&lt;a href=&quot;img.zip&quot;&gt;下载文件&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="5">
<li>网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以。<br>添加超链接：如<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;&lt;img src=&quot;img.jpg&quot; /&gt;&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="6">
<li>锚点链接：当我们点击链接，可以快速定位到页面中的某个位置。<ul>
<li>在链接的href属性中，设置属性值为 <code>#名字</code> 的形式，如 <code>&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;</code></li>
<li>找到相同位置标签，里面添加一个<code>id属性=刚才的名字</code>，如<code>&lt;h3 id=two&gt;第二集介绍&lt;/h3&gt;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
<th>字符的代码</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格符</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&gt;</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;</td>
</tr>
<tr>
<td>￥</td>
<td>人民币</td>
<td>&yen;</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&copy;</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&reg;</td>
</tr>
<tr>
<td>±</td>
<td>加减号</td>
<td>&plusmn;</td>
</tr>
<tr>
<td>℃</td>
<td>摄氏度</td>
<td>&deg;</td>
</tr>
<tr>
<td>✖</td>
<td>乘号</td>
<td>&times;</td>
</tr>
<tr>
<td>➗</td>
<td>除号</td>
<td>&divide;</td>
</tr>
<tr>
<td>²</td>
<td>平方</td>
<td>&sup2;</td>
</tr>
<tr>
<td>³</td>
<td>立方3</td>
<td>&sup3;</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/05/11/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/05/11/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/" class="post-title-link" itemprop="url">数据结构1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-11 11:11:19" itemprop="dateCreated datePublished" datetime="2020-05-11T11:11:19+08:00">2020-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 09:13:37" itemprop="dateModified" datetime="2020-05-21T09:13:37+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Python-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" itemprop="url" rel="index"><span itemprop="name">Python 知识汇总</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><ul>
<li><ol>
<li>数据<br>数据即信息的载体，是能够输入到计算机中并且能被计算机识别、存储和处理的符号总称。</li>
</ol>
</li>
<li><ol start="2">
<li>数据元素<br>数据元素是数据的基本单位，又称为记录(Recaord)。一般，数据元素由若干个基本项(或称字段、域、属性)组成。</li>
</ol>
</li>
<li><ol start="3">
<li>数据结构<br>数据结构指的是数据元素及数据元素之间的相互关系，或组织数据的形式。</li>
</ol>
</li>
</ul>
<h2 id="数据之间的结构关系"><a href="#数据之间的结构关系" class="headerlink" title="数据之间的结构关系"></a>数据之间的结构关系</h2><ul>
<li><ol>
<li>逻辑结构<br>表示数据之间的抽象关系（如邻接关系、从属关系等），按每个元素可能具有的直接前驱和直接后继数将逻辑结构分为“线性结构”和“非线性结构”两大类。</li>
</ol>
</li>
<li><ol start="2">
<li>存储结构<br>逻辑结构在计算机中的具体实现方法分为顺序存储方法、链接存储方法、索引存储方法、散列存储方法。</li>
</ol>
</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是描述其逻辑结构，而通常会在线性表中进行查找、插入、删除等操作。线性表作为一种基本的数据结构，在计算机中的存储映像有两种，顺序存储结构和链式存储结构。</p>
<h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><ol>
<li>定义<br>若将线性表L=(a0,a1,…,an-1)中的各元素依次存储于计算机一片连续的存储空间，这种机制表示为线性表的顺序存储结构。</li>
<li>特点<div class="note info">
            <ul><li>逻辑上相邻的元素ai,ai+1,其存储位置也是相邻的；</li><li>存储密度高，方便对数据进行遍历查找；</li><li>对表的插入和删除等运算的效率较差。</li></ul>
          </div>

</li>
</ol>
<p>3.程序实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">L.append(<span class="number">10</span>)  <span class="comment">#尾部增加元素</span></span><br><span class="line">print(L)     <span class="comment">#[1, 2, 3, 4, 10]</span></span><br><span class="line">L.insert(<span class="number">1</span>,<span class="number">20</span>) <span class="comment">#插入元素</span></span><br><span class="line">print(L)  <span class="comment">#[1, 20, 2, 3, 4, 10]</span></span><br><span class="line">L.remove(<span class="number">1</span>) <span class="comment">#删除元素</span></span><br><span class="line">print(L)  <span class="comment">#[20, 2, 3, 4, 10]</span></span><br><span class="line">L[<span class="number">4</span>] = <span class="number">30</span> <span class="comment">#修改元素</span></span><br><span class="line">print(L) <span class="comment">#[20, 2, 3, 4, 30]</span></span><br><span class="line">print(L.index(<span class="number">2</span>)) <span class="comment">#3(查找)</span></span><br></pre></td></tr></table></figure>

<h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><ul>
<li><ol>
<li>定义<br>将线性表L=(a0,a1,…,an-1)中的各元素分布在存储器的不同存储块，称为结点，每个结点(尾结点除外)中都有一个指向下一个结点的引用，这样所得到的存储结构为链式结构。</li>
</ol>
</li>
<li><ol start="2">
<li>特点<div class="note info">
            <ul><li>逻辑上相邻的元素ai,ai+1,其存储位置不一定是相邻的；</li><li>存储稀疏，不必开辟存储空间；</li><li>对表的插入和删除等运算的效率较高；</li><li>逻辑结构复杂，不利于遍历。</li></ul>
          </div>
</li>
</ol>
</li>
<li><ol start="3">
<li>程序实现</li>
</ol>
</li>
</ul>
<div class="note info">
            <p>链式线性表思路:</p><ol><li>结点如何表示？<br> 自定义对象：对象即数据，对象属性即数据元素<br> 数据元素：有用数据，记录下一个对象地址的数据</li><li>如何建立关联？<br> a = Node(1)  a.val = 1  a.next = b<br> b = Node(2)  b.val = 2  b.next = None</li><li>实现什么样的链表操作？</li></ol>
          </div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    单链表学习程序</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 创建结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,next=None)</span>:</span></span><br><span class="line">        self.val = val  <span class="comment"># 有用数据</span></span><br><span class="line">        self.next = next</span><br><span class="line"><span class="comment"># 链表的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = Node(<span class="literal">None</span>) <span class="comment">#链表的开头</span></span><br><span class="line">    <span class="comment"># 链表初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_list</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        p = self.head   <span class="comment">#可移动变量p</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            p.next = Node(i)</span><br><span class="line">            p = p.next</span><br><span class="line"></span><br><span class="line">    <span class="comment">#遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        p = self.head.next</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            print(p.val,end=<span class="string">' '</span>)</span><br><span class="line">            p = p.next</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在链表尾部插入新结点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = Node(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="comment">#判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.length() == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment">#清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head.next = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 获取索引值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_item</span><span class="params">(self,index)</span>:</span></span><br><span class="line">        p = self.head.next</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; index <span class="keyword">and</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"list index out of range"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> p.val</span><br><span class="line"></span><br><span class="line">    <span class="comment">#插入函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,index,value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt; self.length():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"list index out of range"</span>)</span><br><span class="line">        p = self.head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; index:</span><br><span class="line">            p = p.next</span><br><span class="line">            i +=<span class="number">1</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = p.next</span><br><span class="line">        p.next = node</span><br><span class="line">    <span class="comment">#删除函数（按照值删除，多个的话删除第一个）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.next.val == item:</span><br><span class="line">                p.next = p.next.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">raise</span> ValueError(<span class="string">"x not in list"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 创建链表对象</span></span><br><span class="line">    link = LinkList()</span><br><span class="line">    <span class="comment"># 初始数据</span></span><br><span class="line">    l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">    link.init_list(l)   <span class="comment">#将数据插入链表</span></span><br><span class="line">    link.show()</span><br><span class="line">    link.append(<span class="number">8</span>)   <span class="comment">#在链表尾部插入一个新节点</span></span><br><span class="line">    link.show()</span><br><span class="line">    print(link.length())  <span class="comment">#获取链表长度</span></span><br><span class="line">    print(link.is_empty()) <span class="comment">#判断链表是否为空</span></span><br><span class="line">    <span class="comment"># link.clear()  #清空链表</span></span><br><span class="line">    <span class="comment"># print(link.is_empty()) #判断链表是否为空</span></span><br><span class="line">    print(link.get_item(<span class="number">3</span>)) <span class="comment">#获取到index等于3的位置的value</span></span><br><span class="line">    link.insert(<span class="number">0</span>,<span class="number">16</span>)  <span class="comment">#插入</span></span><br><span class="line">    link.show()</span><br><span class="line">    link.delete(<span class="number">3</span>) <span class="comment">#删除</span></span><br><span class="line">    link.show()</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li><p>1.定义：栈是限制在一端进行插入操作和删除操作的线性表（俗称堆栈），允许进行操作的一端称为“栈顶”，另一固定端称为“栈底”，当栈中没有元素时称为“空栈”。</p>
</li>
<li><ol start="2">
<li>特点：<ul>
<li>栈只能在一端进行数据操作</li>
<li>栈模型具有后进先出或者叫做先进后出的规律</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>栈的代码操作<br>栈的操作有入栈（压栈），出栈（弹栈），判断栈的空满等操作。<br>栈的功能：初始化、入栈、出栈和判断栈是否为空</li>
</ol>
</li>
</ul>
<h3 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    栈的顺序存储结构</span></span><br><span class="line"><span class="string">    重点代码</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 自定义栈操作异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于列表实现顺序栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#约定列表的最后一个元素为栈顶</span></span><br><span class="line">        self._elems = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._elems:</span><br><span class="line">            <span class="keyword">raise</span> StackError(<span class="string">"stack is empty"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._elems[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,elem)</span>:</span></span><br><span class="line">        self._elems.append(elem)</span><br><span class="line">    <span class="comment">#出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._elems:</span><br><span class="line">            <span class="keyword">raise</span> StackError(<span class="string">"stack is empty"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._elems.pop()</span><br><span class="line">    <span class="comment">#判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._elems == []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    st = SStack() <span class="comment">#初始化栈</span></span><br><span class="line">    <span class="comment"># print(st.top())</span></span><br><span class="line">    st.push(<span class="number">10</span>)</span><br><span class="line">    st.push(<span class="number">20</span>)</span><br><span class="line">    st.push(<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> st.is_empty():</span><br><span class="line">        print(st.pop()) <span class="comment"># 30  20  10</span></span><br></pre></td></tr></table></figure>

<p><strong>练习：监测一段文字中的括号是否为成对出现，如果不是，则报出括号匹配的错误问题</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> python_shujujiegou.sstack <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">text= <span class="string">'''Arithmetic (operations) between subclasses of datetime.date or datetime.datetime and datetime.timedelta objects now [return an instance] of the subclass, rather than the base class. (This also &#123;affects the (return) type of operations&#125; whose implementation (directly or indirectly) uses datetime.timedelta arithmetic, such as astimezone()). (Contributed by Paul Ganssle in bpo-32417.)'''</span></span><br><span class="line"></span><br><span class="line">parens = <span class="string">"()[]&#123;&#125;"</span> <span class="comment">#验证的括号</span></span><br><span class="line">left_parens = <span class="string">"([&#123;"</span></span><br><span class="line">opposite = &#123;<span class="string">')'</span>:<span class="string">'('</span>,<span class="string">']'</span>:<span class="string">'['</span>,<span class="string">'&#125;'</span>:<span class="string">'&#123;'</span>&#125; <span class="comment">#对应关系</span></span><br><span class="line"><span class="comment">#生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="comment"># i记录字符串索引</span></span><br><span class="line">    i,text_len = <span class="number">0</span>,len(text)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#逐个遍历字符串，如果没到结尾且不是括号就向后遍历</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; text_len <span class="keyword">and</span> text[i] <span class="keyword">not</span> <span class="keyword">in</span> parens:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= text_len:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> text[i],i  <span class="comment">#生成括号字符和对应位置</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">st = SStack()  <span class="comment">#初始化栈</span></span><br><span class="line"><span class="keyword">for</span> pr,i <span class="keyword">in</span> generate(text):</span><br><span class="line">    <span class="keyword">if</span> pr <span class="keyword">in</span> left_parens:</span><br><span class="line">        st.push((pr,i)) <span class="comment">#将左括号及其位置入栈</span></span><br><span class="line">    <span class="keyword">elif</span> st.is_empty() <span class="keyword">or</span> st.pop()[<span class="number">0</span>] != opposite[pr]:</span><br><span class="line">        print(<span class="string">"Unmatching is found at %d for %s"</span> % (i,pr))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环正常结束，判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> st.is_empty():</span><br><span class="line">        print(<span class="string">"All parentheses are matched"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 有左括号没有匹配</span></span><br><span class="line">        e = st.pop()</span><br><span class="line">        print(<span class="string">"Unmatching is found at %d for %s"</span> % (e[<span class="number">1</span>],e[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h3><p>链式存储栈的形式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self._top  -&gt;   node  -&gt; node</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    栈的链式存储(重点代码)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 自定义栈操作异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,next=None)</span>:</span></span><br><span class="line">        self.val = val  <span class="comment"># 有用数据</span></span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#标记栈顶位置</span></span><br><span class="line">        self._top = <span class="literal">None</span></span><br><span class="line">    <span class="comment">#判断栈为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._top == <span class="literal">None</span></span><br><span class="line">    <span class="comment">#入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        node = Node(item,self._top)</span><br><span class="line">        self._top = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty() == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> StackError(<span class="string">"stack is empty"</span>)</span><br><span class="line">        p = self._top</span><br><span class="line">        self._top = p.next</span><br><span class="line">        <span class="keyword">return</span> p.val</span><br><span class="line">    <span class="comment">#获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> self._top.val</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    st = LStack() <span class="comment">#初始化栈</span></span><br><span class="line">    print(st.is_empty())</span><br><span class="line">    st.push(<span class="number">10</span>)</span><br><span class="line">    st.push(<span class="number">20</span>)</span><br><span class="line">    st.push(<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> st.is_empty():</span><br><span class="line">        print(st.peek())</span><br><span class="line">        print(st.pop())</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/05/10/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/05/10/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">python常用函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 11:28:56" itemprop="dateCreated datePublished" datetime="2020-05-10T11:28:56+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-12 22:08:20" itemprop="dateModified" datetime="2020-05-12T22:08:20+08:00">2020-05-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Python-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/" itemprop="url" rel="index"><span itemprop="name">Python 知识汇总</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h2><ul>
<li>1.定义：eval() 函数用来执行一个字符串表达式，并返回表达式的值</li>
<li>2.语法<div class="note info">
            <p>eval(expression[, globals[, locals]])</p><ul><li>expression – 表达式。</li><li>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li><li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul>
          </div>

</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;x = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval( <span class="string">'3 * x'</span> )</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'pow(2,2)'</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'2 + 2'</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">"n + 4"</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure>

<h2 id="python内置进制转换方法"><a href="#python内置进制转换方法" class="headerlink" title="python内置进制转换方法"></a>python内置进制转换方法</h2><p>使用Python内置函数：bin()、oct()、int()、hex()可实现进制转换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入一个十进制的数值字符串。输出该数值的十六进制字符串。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = hex(int(input(),<span class="number">10</span>))  <span class="comment">#输入10</span></span><br><span class="line">        print(a)      <span class="comment">#输出oxa</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/18/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/BOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/18/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/BOM/" class="post-title-link" itemprop="url">第八章 BOM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 18:49:05" itemprop="dateCreated datePublished" datetime="2020-04-18T18:49:05+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-19 09:28:38" itemprop="dateModified" datetime="2020-07-19T09:28:38+08:00">2020-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ECMAScript是JavaScript的核心，但如果要在Web中使用JavaScript，那么BOM（浏览器对象模型）则无疑才是真正的核心。,BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。</p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。在window中定义的任何一个变量、函数和对象，都以window作为其Global对象，因此有权访问parseInt等方法。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>由于window对象同时扮演着ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。<br><strong>定义全局变量与在window对象上定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。</strong></p>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象，每个window对象都有一个name属性，其中包含框架的名称。</p>
<div class="note info">
            <p>top 对象始终指向最高（最外层）的框架，也就是浏览器窗口。<br>parent （父）对象始终指向当前框架的直接上层框架。<br>self 对象始终指向window对象，可以与window互换使用。</p>
          </div>

<h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>使用window.open()方法可以导航到一个特定的URL,也可以打开一个新的浏览器窗口。这个方法可以接收四个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只传递第一个参数，最后一个参数只有在不打开新窗口的情况下使用。</p>
<h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><p>JavaScript是单线程语言，但它允许设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者是每隔指定的时间就执行一次代码。<br>超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是一个字符串（就和在eval()函数中使用的字符串一样），也可以是一个函数。实例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议传递字符串,有可能导致性能损失</span></span><br><span class="line">setTimeout(<span class="string">"alert('Hello world')"</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 推荐的调用方式</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>调用setTimeout()之后，该方法会返回一个数值ID，表示超值调用，这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。采用clearTimeout()方法可以将尚未执行的超时调用计划取消，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置超时调用</span></span><br><span class="line"><span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">clearTimeout(timeoutId); <span class="comment">// 取消超时调用计划的ID即可取消调用</span></span><br></pre></td></tr></table></figure>

<p>间歇调用和超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同：要执行的代码（字符串或函数）和每次执行之前需要等待的毫秒数。与超时调用类似，取消间歇调用也是取消间歇调用返回的ID，取消方法是clearInterval()看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置间歇调用</span></span><br><span class="line"><span class="keyword">var</span> timeoutId = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//取消间歇调用</span></span><br><span class="line">clearInterval(timeoutId)</span><br></pre></td></tr></table></figure>
<p><strong>取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用会执行到页面卸载。但是在开发中很少使用间歇调用，一般使用超时调用。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E8%A7%A3%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E8%A7%A3%E6%9E%84/" class="post-title-link" itemprop="url">解构：更方便的数据访问</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-23 18:29:28" itemprop="dateModified" datetime="2019-11-23T18:29:28+08:00">2019-11-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/" itemprop="url" rel="index"><span itemprop="name">深入理解ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构语法在赋值语句的左侧使用了对象字面量，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;type, name&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type);    <span class="comment">//"Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">//"foo"</span></span><br></pre></td></tr></table></figure>

<p>在此代码中，<code>node.type</code> 的值被存储到 <code>type</code> 本地变量中， <code>node.name</code> 的值则存储到<code>name</code>变量中, <code>type</code> 与 <code>name</code> 标识符既声明了本地变量，也读取了对象的相应属性值。</p>
<p>**不要遗忘初始化器：当使用解构来配合<code>var</code> <code>let</code> 或 <code>const</code>来声明变量时，必须提供初始化器（即等号右边的值）。下面的代码都会因为没有提供初始化器而抛出错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">var</span> &#123; type, name &#125;;</span><br><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125;;</span><br><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">const</span> &#123; type, name &#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>const</code> 总是要求有初始化器，即使没有使用解构的变量；而 <code>var</code> 与 <code>let</code> 则仅在使用解构时才作此要求。</strong></p>
<h3 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h3><p>在变量声明之后也可以进行解构赋值。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;,</span><br><span class="line">type = <span class="string">"Literal"</span>,</span><br><span class="line">name = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 使用解构来分配不同的值</span></span><br><span class="line">(&#123; type, name &#125; = node);</span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：必须用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符（即等号）左侧出现。圆括号标示了里面的花括号并不是块语句，而应该被解释为表达式，从而允许完成赋值操作。</strong></p>
<h3 id="对象解构默认值"><a href="#对象解构默认值" class="headerlink" title="对象解构默认值"></a>对象解构默认值</h3><p>当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为<code>undefined</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;type, name, value&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type);    <span class="comment">//"Indentifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">//"foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value);   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>你可以选择性地定义一个默认值，以便在指定属性不存在时使用该值。若要这么做，需要在属性名后面添加一个等号并指定默认值，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;type, name, value=<span class="string">"12"</span>&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type);    <span class="comment">//"Indentifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">//"foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value);   <span class="comment">//"12"</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值给不同的本地变量名"><a href="#赋值给不同的本地变量名" class="headerlink" title="赋值给不同的本地变量名"></a>赋值给不同的本地变量名</h3><p><strong>ES6</strong>有一个扩展语法，允许你在给本地变量赋值时使用一个不同的名称，而且该语法看上去就像是使用对象字面量的非简写的属性初始化，看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: localType, <span class="attr">name</span>: localName&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localType);    <span class="comment">//"Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName);    <span class="comment">//"foo"</span></span><br></pre></td></tr></table></figure>

<p>也可以给变量别名添加默认值，依然是在本地变量名称后添加等号与默认值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: localType, <span class="attr">name</span>: localName=<span class="string">"bar"</span>&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localType);    <span class="comment">//"Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName);    <span class="comment">//"bar"</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套的对象解构"><a href="#嵌套的对象解构" class="headerlink" title="嵌套的对象解构"></a>嵌套的对象解构</h3><p>使用类似于对象字面量的语法，可以深入到嵌套的对象结构中去提取你想要的数据。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line:<span class="number">1</span>,</span><br><span class="line">            column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;start&#125;&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(start.line);   <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>在对象的嵌套解构中同样能为本地变量使用不同的名称</strong>，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line:<span class="number">1</span>,</span><br><span class="line">            column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 提取 node.loc.start</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;<span class="attr">start</span>: localStart&#125;&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(localStart.line);   <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(localStart.column); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>数组解构的语法看起来与对象解构非常相似，只是将对象字面量替换成了数组字面量。数组解构时，解构作用在数组内部的位置上，而不是作用在对象的具名属性上，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, secondColor ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p>此处数组解构从<code>colors</code>数组中取出了<code>&quot;red&quot;</code> 与 <code>&quot;green&quot;</code> ，并将它们赋值给 <code>fristColor</code>与 <code>secondColor</code> 变量。这些值被选择，是由于它们在数组中的位置，实际的变量名称是任意的（与位置无关）。任何没有在解构模式中明确指定的项都会被忽略。记住，<strong>数组本身并没有以任何方式被改变</strong>。<br>在解构模式中可以忽略一些项，并且只给感兴趣的项提供变量名，例如：若只想获取数组中的第三个元素，那么不必给前两项提供变量名，以下展示了这种方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ , , thirdColor ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(thirdColor); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>

<h3 id="数组解构赋值"><a href="#数组解构赋值" class="headerlink" title="数组解构赋值"></a>数组解构赋值</h3><p><strong>可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号内</strong>，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ],</span><br><span class="line">firstColor = <span class="string">"black"</span>,</span><br><span class="line">secondColor = <span class="string">"purple"</span>;</span><br><span class="line">[firstColor, secondColor] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p><strong>数组解构赋值有一个非常独特的用例，能轻易地互换两个变量的值。互换变量值在排序算法中十分常用。</strong>如下例所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ES6 中互换值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>本例中的数组解构赋值看起来如同镜像。赋值语句左侧（即等号之前）的解构模式正如其他数组解构的范例，右侧则是为了互换而临时创建的数组字面量。 b 与 a 的值分别被复制到<br>临时数组的第一个与第二个位置，并对该数组进行解构，结果两个变量就互换了它们的值。<br><strong>与对象解构赋值相同，若等号右侧的计算结果为 null 或 undefined ，那么数组解构赋值表达式也会抛出错误。</strong></p>
<h3 id="数组解构默认值"><a href="#数组解构默认值" class="headerlink" title="数组解构默认值"></a>数组解构默认值</h3><p><strong>数组解构赋值同样允许在数组任意位置指定默认值，当指定位置的项不存在、或其值为<code>undefined</code>, 那么该默认值就会被使用。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, secondColor = <span class="string">"green"</span> ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p>此代码的<code>colors</code>数组只有一个项，因此没有能与<code>secondColor</code>匹配的项，又由于此处有个默认值，<code>secondColor</code>的值就被设置为<code>&quot;green&quot;</code>，而不是<code>undefined</code>。</p>
<h3 id="嵌套的解构"><a href="#嵌套的解构" class="headerlink" title="嵌套的解构"></a>嵌套的解构</h3><p>与解构嵌套的对象相似，可以用类似的方式来解构嵌套的数组。在整个解构模式中插入另一个数组模式，解构数组就会下行到嵌套的数组中，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</span><br><span class="line"><span class="comment">// 随后</span></span><br><span class="line"><span class="keyword">let</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<h3 id="剩余项"><a href="#剩余项" class="headerlink" title="剩余项"></a>剩余项</h3><p>与函数的剩余参数类似，数组解构有一个名为剩余项的概念，它使用<code>...</code>语法来将剩下的项目赋值给一个指定的变量，范例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, ...restColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]); <span class="comment">// "green"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>

<p><strong>除此之外在ES6中可以使用剩余项的语法来进行数组克隆。</strong>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ES6 中克隆数组</span></span><br><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ ...clonedColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(clonedColors); <span class="comment">//"[red,green,blue]"</span></span><br></pre></td></tr></table></figure>

<p><strong>剩余项必须是数组解构模式中最后的部分，之后不能再有逗号，否则就是语法错误。</strong></p>
<h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><p><strong>对象与数组解构能被用在一起，以创建更复杂的解构表达式。在对象与数组混合而成的结构中，这么做便能准确提取其中你想要的信息片段。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    range: [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    loc: &#123;start&#125;,</span><br><span class="line">    range: [startIndex]</span><br><span class="line">&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(start);      <span class="comment">//&#123; line: 1, column: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(startIndex); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><p>解构的另外一个特别有用的场景，即在传递函数参数时，<strong>当JS的函数接收大量可选参数时，一个常用模式是创建一个<code>option</code>对象</strong>，其中包含了附加的参数，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> secure = options.secure,</span><br><span class="line">        path = options.path,</span><br><span class="line">        domain = options.domain,</span><br><span class="line">        expires = options.expires;</span><br><span class="line">    <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>很多<code>JS</code>的库都包含了类似于此例的<code>setCookie()</code>函数。在此函数内，<code>name</code>与<code>value</code>参数是必需的，而<code>secure</code>、<code>path</code> 、 <code>domain</code> 与 <code>expires</code> 则不是。并且因为此处对于其余数据并没有顺序要求，将它们作为 <code>options</code> 对象的具名属性会更有效率，而无须列出一堆额外的具名参数。这种方法很有用，但无法仅通过查看函数定义就判断出函数所期望的输入，你必须阅读函数体的代码。<br>参数解构提供了更清楚地标明函数期望输入的替代方案。它使用对象或数组解构的模式替代了具名参数。要看到其实际效果，请查看下例中重写版本的 <code>setCookie()</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125;</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在对于<code>setCookie()</code> 函数的使用者来说，解构参数之外的参数明显是必需的；而可选项目存在于额外的参数组中，这同样是非常明确的；同时，若使用了第三个参数，其中应当包含什么值当然也是极其明确的。解构参数在没有传递值的情况下类似于常规参数，它们会被设为<code>undefined</code>。</p>
<h3 id="解构的参数是必需的"><a href="#解构的参数是必需的" class="headerlink" title="解构的参数是必需的"></a>解构的参数是必需的</h3><p>参数解构有一个怪异点：默认情况下调用函数时未给参数解构传值会抛出错误，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出错！</span></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>);</span><br></pre></td></tr></table></figure>

<p>调用时第三个参数缺失了，因此它不出预料地等于<code>undefined</code>。这导致了一个错误，因为参数解构实际上只是解构声明的简写。当<code>setCookie()</code> 函数被调用时，<code>JS</code>引擎实际上是这么做的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options;</span><br><span class="line">    <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若你让解构的参数作为必选参数，那么上述行为并不会令人困扰。但若你要求它是可选的，可以给解构的参数提供默认值来处理这种行为，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例为第三个参数提供了一个空对象作为其默认值。给解构的参数提供默认值，也就意味着若未向 setCookie() 函数传递第三个参数，则 secure 、 path 、 domain 与 expires 的值全都会是 undefined ，此时不会有错误被抛出。</p>
<h3 id="参数解构的默认值"><a href="#参数解构的默认值" class="headerlink" title="参数解构的默认值"></a>参数解构的默认值</h3><p>你可以为参数解构提供可解构的默认值，就像在解构赋值时所做的那样，只需在其中每个参数后面添加等号并指定默认值即可。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,</span></span></span><br><span class="line"><span class="function"><span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    secure = false,</span></span></span><br><span class="line"><span class="function"><span class="params">    path = <span class="string">"/"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    domain = <span class="string">"example.com"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    expires = new Date(Date.now(</span>) + 360000000)</span></span><br><span class="line"><span class="function">&#125; = </span>&#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E7%AC%A6%E5%8F%B7%E4%B8%8E%E7%AC%A6%E5%8F%B7%E5%B1%9E%E6%80%A7%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E7%AC%A6%E5%8F%B7%E4%B8%8E%E7%AC%A6%E5%8F%B7%E5%B1%9E%E6%80%A7%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/" class="post-title-link" itemprop="url">符号与符号属性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-28 20:09:02" itemprop="dateModified" datetime="2019-11-28T20:09:02+08:00">2019-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/" itemprop="url" rel="index"><span itemprop="name">深入理解ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在JS已有的基本类型（字符串、数值、布尔类型、null与undefined）之外，ES6引入了一种新的基本类型：符号（Symbol）。符号起初被设计用于创建私有成员，而这也是JS开发者期待已久的特性。在符号诞生之前，将字符串作为属性名称导致属性可以被轻易访问，无论命名规则如何。而“私有名称”意味着开发者可以创建非字符串类型的属性名称，由此可以防止使用常规手段来探查这些名称。<br>“私有名称”提案最终发展成为ES6中的符号，而本章将会教你如何有效使用它。虽然它只保留了实现细节（即：引入了非字符串类型的属性名）而丢弃了私有性意图，但它仍然显著有别于对象的其余属性。</p>
<h2 id="创建符号值"><a href="#创建符号值" class="headerlink" title="创建符号值"></a>创建符号值</h2><p><strong>符号没有字面量形式。</strong>有别于布尔类型的<code>true</code>或数值类型的<code>42</code>等等。可以使用全局<code>Symbol</code>函数来创建一个符号值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[firstName] = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>此代码创建了一个符号类型的<code>firstName</code>变量，并将它作为<code>person</code>对象的一个属性，而每次访问该属性都要使用这个符号值。为符号变量适当命名是个好主意，这样你就可以很容易地说明它的含义。</p>
<div class="note info">
            <p>由于符号值是基本类型的值，因此调用 new Symbol() 将会抛出错误。你可以通过 newObject(yourSymbol) 来创建一个符号实例，但尚不清楚这能有什么作用。</p>
          </div>

<p>Symbol 函数还可以接受一个额外的参数用于描述符号值，该描述并不能用来访问对应属性，但它能用于调试，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">"first name"</span>);</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[firstName] = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"first name"</span> <span class="keyword">in</span> person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(firstName); <span class="comment">// "Symbol(first name)"</span></span><br></pre></td></tr></table></figure>

<p>符号的描述信息被存储在内部属性<code>[[Description]]</code>中，当符号的<code>toString()</code>方法被显式或隐式调用时，该属性都会被读取。在本例中，<code>console.log()</code>隐式调用了 <code>firstName</code>变量的<code>toString()</code>方法，于是描述信息就被输出到日志。此外没有任何办法可以从代码中直接访问<code>[[Description]]</code>属性。我建议始终应给符号提供描述信息，以便更好地阅读代码或进行调试。</p>
<div class="note into">
            <p>识别符号值<br>由于符号是基本类型的值，因此你可以使用 typeof 运算符来判断一个变量是否为符号。 ES6 扩充了 typeof 的功能以便让它在作用于符号值的时候能够返回 “symbol” ，尽管有其他方法可以判断一个变量是否为符号， typeof 运算符依然是最准确、最优先的判别手段。例如：</p>
          </div>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">"test symbol"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol); <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>

<h2 id="使用符号值"><a href="#使用符号值" class="headerlink" title="使用符号值"></a>使用符号值</h2><p>可以在任意能使用“需计算属性名”的场合使用符号，此外还可以在<code>Object.defineProperty()</code>或<code>Object.defineProperties()</code>调用中使用它。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">"first name"</span>);</span><br><span class="line"><span class="comment">// 使用一个需计算字面量属性</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [firstName]: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 让该属性变为只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, firstName, &#123; <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="built_in">Symbol</span>(<span class="string">"last name"</span>);</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    [lastName]: &#123;</span><br><span class="line">        value: <span class="string">"Zakas"</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]); <span class="comment">// "Zakas"</span></span><br></pre></td></tr></table></figure>

<h3 id="共享符号值"><a href="#共享符号值" class="headerlink" title="共享符号值"></a>共享符号值</h3><p>你或许想在不同的代码段中使用相同的符号值，例如：假设在应用中需要在两个不同的对象类型中使用同一个符号属性，用来表示一个唯一标识符。跨越文件或代码来追踪符号值是很<br>困难并且易错的，为此， <strong>ES6 提供了“全局符号注册表”供你在任意时间点进行访问。</strong><br>若你想创建共享符号值，应使用<code>Symbol.for()方法</code>而不是<code>Symbol()方法</code>。 <strong><code>Symbol.for()</code>方法仅接受单个字符串类型的参数，作为目标符号值的标识符，同时此参数也会成为该符号的描述信息。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;&#125;;</span><br><span class="line">object[uid] = <span class="string">"12345"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(object[uid]); <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid); <span class="comment">// "Symbol(uid)"</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for()</code> 方法首先会搜索全局符号注册表，看是否存在一个键值为 <code>&quot;uid&quot;</code> 的符号值。若是，该方法会返回这个已存在的符号值；否则，会创建一个新的符号值，并使用该键值将其记录到全局符号注册表中，然后返回这个新的符号值。这就意味着此后使用同一个键值去调用 <code>Symbol.for()</code>方法都将会返回同一个符号值，就像下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    [uid]: <span class="string">"12345"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object[uid]); <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid); <span class="comment">// "Symbol(uid)"</span></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(uid === uid2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(object[uid2]); <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid2); <span class="comment">// "Symbol(uid)"</span></span><br></pre></td></tr></table></figure>

<p>本例中，<code>uid</code>与<code>uid2</code>包含同一个符号值，因此它们可以互换使用。<strong>第一次调用<code>Symbol.for()</code>创建了这个符号值，而第二次调用则从全局符号注册表中将其检索了出来。</strong><br><strong>共享符号值还有另一个独特用法，你可以使用<code>Symbol.keyFor()</code>方法在全局符号注册表中根据符号值检索出对应的键值</strong>，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid)); <span class="comment">// "uid"</span></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid2)); <span class="comment">// "uid"</span></span><br><span class="line"><span class="keyword">let</span> uid3 = <span class="built_in">Symbol</span>(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid3)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>注意：使用符号值<code>uid</code>与<code>uid2</code>都返回了键值<code>&quot;uid&quot;</code>，而符号值<code>uid3</code>在全局符号注册表中并不存在，因此没有关联的键值，<code>Symbol.keyFor()</code>方法只会返回 undefined 。</p>
<div class="note info">
            <p>全局符号注册表类似于全局作用域，是一个共享环境，这意味着你不应当假设某些值是否已存在于其中。在使用第三方组件时，为符号的键值使用命名空间能够减少命名冲突<br>的可能性，举个例子：<code>jQuery</code>代码应当为它的所有键值使用 <code>&quot;jquery.&quot;</code> 的前缀，如<code>&quot;jquery.element&quot;</code> 或类似的形式。</p>
          </div>

<h2 id="符号值的转换"><a href="#符号值的转换" class="headerlink" title="符号值的转换"></a>符号值的转换</h2><p>类型转换是<strong>JS</strong>语言重要的一部分，能够非常灵活地将一种数据类型转换为另一种。然而符号类型在进行转换时非常不灵活，因为其他类型缺乏与符号值的合理等价，尤其是符号值无法被转换为字符串值或数值。因此将符号作为属性所达成的效果，是其他类型所无法替代的。<br>前面例子中使用了<code>console.log()</code>来展示符号值的输出，能这么做是由于自动调用了符号的<code>String()</code>方法来产生输出，也可以直接调用<code>String()</code>方法来获取相同结果，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</span><br><span class="line">    desc = <span class="built_in">String</span>(uid);</span><br><span class="line"><span class="built_in">console</span>.log(desc); <span class="comment">// "Symbol(uid)"</span></span><br></pre></td></tr></table></figure>

<p><code>String()</code>方法调用了<code>uid.toString()</code>来获取符号的字符串描述信息。但若你想直接将符号转换为字符串，则会引发错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</span><br><span class="line">    desc = uid + <span class="string">""</span>; <span class="comment">// 引发错误！</span></span><br></pre></td></tr></table></figure>

<p>将 uid 与空字符串相连接，会首先要求把 uid 转换为一个字符串，而这会引发错误，从而阻止了转换行为。相似地，你不能将符号转换为数值，对符号使用所有数学运算符都会引发错误，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</span><br><span class="line">sum = uid / <span class="number">1</span>; <span class="comment">// 引发错误！</span></span><br></pre></td></tr></table></figure>

<p>此例试图把符号值除以 1 ，同样引发了错误。无论对符号使用哪种数学运算符都会导致错误，但使用逻辑运算符则不会，因为符号值在逻辑运算中会被认为等价于 true （就像 JS<br>中其他的非空值那样）。</p>
<h2 id="检索符号属性"><a href="#检索符号属性" class="headerlink" title="检索符号属性"></a>检索符号属性</h2><p><code>Object.keys()</code> 与 <code>Object.getOwnPropertyNames()</code> 方法可以检索对象的所有属性名称，前者返回所有的可枚举属性名称，而后者则返回所有属性名称而无视其是否可枚举。然而两者都不能返回符号类型的属性，以保持它们在<strong>ES5</strong>中的功能不发生变化。而 <strong>ES6</strong> 新增了<code>Object.getOwnPropertySymbols()</code> 方法，以便让你可以检索对象的符号类型属性。<br><code>Object.getOwnPropertySymbols()</code> 方法会返回一个数组，包含了对象自有属性名中的符号值，例如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    [uid]: <span class="string">"12345"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(object);</span><br><span class="line"><span class="built_in">console</span>.log(symbols.length);         <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]);             <span class="comment">// "Symbol(uid)"</span></span><br><span class="line"><span class="built_in">console</span>.log(object[symbols[<span class="number">0</span>]]);    <span class="comment">// "12345"</span></span><br></pre></td></tr></table></figure>

<h2 id="使用知名符号暴露内部方法"><a href="#使用知名符号暴露内部方法" class="headerlink" title="使用知名符号暴露内部方法"></a>使用知名符号暴露内部方法</h2><p>ES5的中心主题之一是披露并定义了一些魔术般的成分，而这些部分是当时开发者所无法自行模拟的。ES6延续了这些工作，对原先属于语言内部逻辑的部分进行了进一步的暴露，允许使用符号类型的原型属性来定义某些对象的基础行为。</p>
<p>ES6定义了“知名符号”来代表JS中一些公共行为，而这些行为此前被认为只能是内部操作，每一个知名符号都对应全局<code>Sympol</code>对象的一个属性，例如<code>Sympol.create</code>。<br>这些知名符号是：</p>
<div class="note info">
            <ul><li><code>Sympol.hasInstance</code>: 供<code>instanceof</code>运算符使用的一个方法，用于判断对象继承关系。</li><li><code>Symbol.isConcatSpreadable</code>: 一个布尔类型值，在集合对象作为参数传递给<code>Array.prototype.concat()</code>方法时，指示是否要将该集合的元素扁平化。</li><li><code>Symbol.iterator</code>: 返回迭代器的一个方法。</li><li><code>Symbol.match</code>: 供<code>String.prototype.match()</code>函数使用的一个方法，用于比较字符串。</li><li><code>Symbol.replace</code>: 供<code>String.prototype.replace()</code>函数使用的一个方法，用于替换子字符串。</li><li><code>Symbol.search</code>: 供<code>String.prototype.search()</code> 函数使用的一个方法，用于定位子字符串。</li><li><code>Symbol.species</code>: 用于产生派生对象的构造器。</li><li><code>Symbol.split</code>: 供<code>String.prototype.split()</code>函数使用的一个方法，用于分割字符串。</li><li><code>Symbol.toPrimitive</code>: 返回对象所对应的基本类型值的一个方法。</li><li><code>Symbol.toStringTag</code>: 供 <code>String.prototype.toString()</code> 函数使用的一个方法，用于创建对象的描述信息。</li><li><code>Symbol.unscopables</code>: 一个对象，该对象的属性指示了哪些属性名不允许被包含在<code>with</code> 语句中。</li></ul>
          </div>

<div class="note into">
            <p>重写知名符号所定义的方法，会把一个普通对象改变成奇异对象，因为它改变了一些默认的内部行为。这并不会对你的代码造成实际影响，它只是改变了规范所描述的对象特征。</p>
          </div>

<h3 id="Symbol-hasInstance属性"><a href="#Symbol-hasInstance属性" class="headerlink" title="Symbol.hasInstance属性"></a>Symbol.hasInstance属性</h3><p>每个函数都具有一个 <code>Symbol.hasInstance</code> 方法，用于判断指定对象是否为本函数的一个实例。这个方法定义在 <code>Function.prototype</code> 上，因此所有函数都继承了面对<code>instanceof</code>运算符时的默认行为。<code>Symbol.hasInstance</code>属性自身不可写入、不可配置、不可枚举的，从而保证它不会被错误地重写。<br><code>Symbol.hasInstance</code> 方法只接受单个参数，即需要检测的值。如果该值是本函数的一个实例，则方法会返回 <code>true</code> 。为了理解该方法是如何工作的，可研究下述代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br></pre></td></tr></table></figure>

<p>这句话等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>[<span class="built_in">Symbol</span>.hasInstance](obj);</span><br></pre></td></tr></table></figure>

<p>ES6从本质上将<code>instanceof</code>运算符重定义为上述方法调用的简写语法，这样使用<code>instanceof</code> 便会触发一次方法调用，实际上允许你改变该运算符的工作。<br>例如:假设你想定义一个函数，使得任意对象都不会被判断为该函数的一个实例，你可以采用硬编码的方式让该函数的<code>Symbol.hasInstance</code>方法始终返回<code>false</code>，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    name: <span class="string">"foo"</span>;</span><br><span class="line">    type: <span class="string">"Indentifier"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(MyObject, <span class="built_in">Symbol</span>.hasInstance,&#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Obj = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="built_in">console</span>.log(MyObject[<span class="built_in">Symbol</span>.hasInstance](Obj));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(Obj <span class="keyword">instanceof</span> MyObject);        <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>要重写一个不可写入的属性，你必须像这个例子一样使用 <code>Object.defineProperty()</code> 。此代码将 <code>Symbol.hasInstance</code> 方法重写为一个始终返回 <code>false</code> 的函数，所以此后即使传入的对象确实是 <code>MyObject</code> 类的一个实例， <code>instanceof</code> 运算符仍然会返回 <code>false</code>。</p>
<p>当然，你可以基于各种条件来决定一个值是否应当被判断为某个类的实例。例如，将介于 1到 100 之间的数值认定为一个特殊的数值类型，为此你可以书写如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(SpecialNumber, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (v <span class="keyword">instanceof</span> <span class="built_in">Number</span>) &amp;&amp; (v &gt;= <span class="number">1</span> &amp;&amp; v &lt;= <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> two = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</span><br><span class="line">    zero = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(two <span class="keyword">instanceof</span> SpecialNumber);   <span class="comment">//two</span></span><br><span class="line"><span class="built_in">console</span>.log(zero <span class="keyword">instanceof</span> SpecialNumber);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>此代码重写了 <code>Symbol.hasInstance</code> 方法，在目标对象是数值对象的实例、并且其值介于 1 到100 之间时，返回 true 。于是， <code>SpecialNumber</code> 类会把变量 <code>two</code>判断为自身的一个实例，即使二者之间并不存在直接的定义关联。需要注意的是： <code>instanceof</code> 的操作数必须是一个对象，以便触发 <code>Symbol.hasInstance</code> 调用；若操作数并非对象， instanceof 只会简单地返回 <code>false</code>。</p>
<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>JS在数组上设计了<code>concat()</code> 方法用于将两个数组连接在一起，此处示范了如何使用该方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors1 = [<span class="string">"red"</span>, <span class="string">"green"</span>],</span><br><span class="line">    colors2 = colors1.concat([<span class="string">"blue"</span>, <span class="string">"black"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2.length);    <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);       <span class="comment">//[ 'red', 'green', 'blue', 'black' ]</span></span><br></pre></td></tr></table></figure>

<p>此代码将一个新数组连接到 <code>colors1</code> 末尾，并创建了 <code>colors2</code> ，后者包含了前两个数组中所有的项。不过， <code>concat()</code> 方法也可以接受非数组的参数，此时这些参数只是简单地被添加到数组末尾，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors1 = [ <span class="string">"red"</span>, <span class="string">"green"</span> ],</span><br><span class="line">    colors2 = colors1.concat([ <span class="string">"blue"</span>, <span class="string">"black"</span> ], <span class="string">"brown"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors2.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// ["red","green","blue","black","brown"]</span></span><br></pre></td></tr></table></figure>

<p>此代码向 <code>concat()</code> 方法传递了一个额外参数 <code>&quot;brown&quot;</code> ，使得它成为数组 <code>colors2</code> 的第 <strong>5</strong> 项。<strong>为何数组类型的参数与字符串类型的参数会被区别对待？这是因为 <code>JS</code> 规范要求此时数组类型的参数需要被自动分离出各个子项，而其他类型的参数无需如此处理。在 ES6 之前，没有任何手段可以改变这种行为。</strong><br><code>Symbol.isConcatSpreadable</code> 属性是一个布尔类型的属性，它表示目标对象拥有长度属性与数值类型的键、并且数值类型键所对应的属性值在参与 <code>concat()</code> 调用时需要被分离为个体。该符号与其他的知名符号不同，默认情况下并不会作为任意常规对象的属性。它只出现在特定类型的对象上，用来标示该对象在作为 <code>concat()</code> 参数时应如何工作，从而有效改变该对象的默认行为。你可以用它来定义任意类型的对象，让该对象在参与 <code>concat()</code> 调用时能够表现得像数组一样，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">"Hello"</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">"world"</span>,</span><br><span class="line">    length: <span class="number">2</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> messages = [ <span class="string">"Hi"</span> ].concat(collection);</span><br><span class="line"><span class="built_in">console</span>.log(messages.length); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(messages); <span class="comment">// ["hi","Hello","world"]</span></span><br></pre></td></tr></table></figure>

<p>本例中的 <code>collection</code> 对象的特征类似于数组：拥有长度属性以及两个数值类型的键，并且<code>Symbol.isConcatSpreadable</code> 属性值被设为 <code>true</code> ，用于指示该对象在被添加到数组时应该使用分离的属性值。当 <code>collection</code> 对象被传递给 <code>concat()</code> 方法时， <code>&quot;Hello&quot;</code> 与 <code>&quot;world&quot;</code>被分离为独立的项，并跟在 <code>&quot;hi&quot;</code> 元素之后。</p>
<div class="note info">
            <p>你也可以将数组的子类的 <code>Symbol.isConcatSpreadable</code> 属性值设为 <code>false</code> ，用于在<code>concat()</code> 调用时避免项目被分离。子类的介绍在迭代器与生成器部分介绍。</p>
          </div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/" class="post-title-link" itemprop="url">迭代器与生成器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-12-31 17:09:01" itemprop="dateModified" datetime="2019-12-31T17:09:01+08:00">2019-12-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/" itemprop="url" rel="index"><span itemprop="name">深入理解ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>许多编程语言都将迭代数据的方式从使用<code>for</code>循环转变到使用迭代器对象，<code>for</code>循环需要初始化变量以追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。迭代器能使操作集合变得更简单，因此ES6也将其添加进JS中。</p>
<h2 id="何为迭代器"><a href="#何为迭代器" class="headerlink" title="何为迭代器"></a>何为迭代器</h2><p>迭代器是被设计专用于迭代的对象，带有特定接口，所有迭代器对象都拥有<code>next()</code>方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的<code>value</code>,以及一个布尔类型的<code>done</code>，其值为<code>true</code>时表示没有更多值可供使用。迭代器有一个指向集合位置的内部指针，每当调用了<code>next()</code>方法，迭代器就会返回相应的下一个值。<br>若在最后一个值返回后再调用<code>next()</code>，所返回的<code>done</code>属性值会是<code>true</code>，并且<code>value</code>属性值会是迭代器自身的返回值。该返回值不是原数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用<code>undefined</code>。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A/" class="post-title-link" itemprop="url">块级作用域绑定</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 19:48:38" itemprop="dateModified" datetime="2019-11-17T19:48:38+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/" itemprop="url" rel="index"><span itemprop="name">深入理解ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>变量声明的工作方式历来是JS编程中最微妙的部分之一。在大多数类C语言中，变量（或绑定）总是在它被声明的地方创建。然而JS就不是这样，变量实际创建的位置取决于你如何声明它，而ES6提供了额外选择以便你能更轻易地控制变量的作用域。</p>
<h2 id="var声明与变量提升"><a href="#var声明与变量提升" class="headerlink" title="var声明与变量提升"></a>var声明与变量提升</h2><p>使用var关键字声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部），这种方式就是变量提升。<br>如下例所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="string">"blue"</span>;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不太熟悉 JS ，或许会认为仅当 condition 的值为 true 时，变量 value 才会被创建。但实际上，value 无论如何都会被创建。 JS 引擎在后台对 getValue 函数进行了调整，就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        value = <span class="string">"blue"</span>;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>value 变量的声明被提升到了顶部，而初始化工作则保留在原处。这意味着在 else 分支内value 变量也是可访问的，此处它的值会是 undefined ，因为它并没有被初始化。</strong></p>
<h2 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h2><p>块级声明即让所声明的变量在指定块的作用域外无法被访问。块级作用域（又被称为词法作用域）在如下情况被创建：</p>
<ul>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ul>
<h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p>let声明与var的语法一致，但是let声明不会被提升到当前代码块的顶部，需要手动将let声明放置到顶部，以便让变量在整个代码块内部使用。<strong>let声明会将变量的作用域限制在当前代码块中。</strong>范例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">"blue"</span>;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value 在此处不可用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// value 在此处不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h3><p><strong>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行let声明就会导致抛出错误。</strong><br>但是在嵌套的作用域内使用let声明一个同名的新变量，则不会抛出错误。范例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">40</span>;</span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>使用const语法进行声明的变量是常量，在设置完成后就不能再被改变，正因为如此，所有的const变量都需要在声明时进行初始化。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效的常量</span></span><br><span class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 语法错误；未进行初始化</span></span><br><span class="line"><span class="keyword">const</span> name;</span><br></pre></td></tr></table></figure>

<ul>
<li>对比常量声明与let声明： 常量声明与let声明一样，都是块级声明。即常量在声明它们的语句块外部是无法访问的，并且声明也不会被提升；同样不能重复声明。</li>
<li>使用const声明对象：const声明会阻止对于变量绑定与变量自身值的修改，意味着const声明并不会阻止对变量成员的修改。如下例所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 工作正常</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">person = &#123;</span><br><span class="line">name: <span class="string">"Greg"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上例中，修改 person.name 是可能的，并不会抛出错误，因为该操作只修改了 person 对象的成员，而没有修改 person 的绑定值。当代码试图为 person 对象自身赋值时（这会改变变量绑定），就会导致错误。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>使用let或const声明的变量在达到声明处之前是无法访问的，试图访问会导致一个引用错误。</p>
<h2 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h2><h3 id="循环内的函数"><a href="#循环内的函数" class="headerlink" title="循环内的函数"></a>循环内的函数</h3><p>长期以来，var的特点是使得循环变量在循环作用域之外仍然可被访问，于是在循环内创建函数就变得很有问题。例如下例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func(); <span class="comment">// 输出数值 "10" 十次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>上例预期为这段代码会输出0到9的数值，但它却在同一行将数值10输出了十次。因为变量i在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对于同一变量的引用。</strong></p>
<h3 id="循环内的let声明"><a href="#循环内的let声明" class="headerlink" title="循环内的let声明"></a>循环内的let声明</h3><p>let是属于局部作用域声明，因此使用let代替var将避免上面的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func(); <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在循环中let声明每次都创建了一个新的i变量，因此在循环内部创建的函数获得了各自的i副本，而每个i副本的值都在每次循环迭代声明变量的时候被确定了。</strong></p>
<h3 id="循环内的常量声明"><a href="#循环内的常量声明" class="headerlink" title="循环内的常量声明"></a>循环内的常量声明</h3><p>ES6中没有明确禁止在循环中使用const声明，但是它会根据循环方式的不同而有不同行为。在常规的for循环中，可以在初始化时使用const，但循环会在你试图改变该变量的值时抛出错误。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="comment">// 在一次迭代后抛出错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>const 变量在 for-in 或 for-of 循环中使用时，与 let 变量效果相同。</strong>const 能够在 for-in 与 for-of 循环内工作，是因为循环为每次迭<br>代创建了一个新的变量绑定，而不是试图去修改已绑定的变量的值</p>
<h2 id="全局块级绑定"><a href="#全局块级绑定" class="headerlink" title="全局块级绑定"></a>全局块级绑定</h2><p>在全局作用域上使用var时，会创建一个新的全局变量，并成为全局对象（在浏览器中是window）的一个属性，即使用var可能会无意覆盖一个已有的全局属性。<br>在全局作用域上使用let或const时，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。即不能使用let或const来覆盖一个全局变量，只能将其屏蔽。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">字符串与正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-09 12:09:13" itemprop="dateModified" datetime="2020-06-09T12:09:13+08:00">2020-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/" itemprop="url" rel="index"><span itemprop="name">深入理解ES6</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>关于字符串与正则表达式，这里不介绍太多细致内容，本章整理的不是很全面。</strong></p>
<h2 id="识别子字符串的方法"><a href="#识别子字符串的方法" class="headerlink" title="识别子字符串的方法"></a>识别子字符串的方法</h2><p>自从 JS 引入了 indexOf() 方法，开发者们就使用它来识别字符串是否存在于其它字符串中。ES6 包含了以下三个方法来满足这类需求：</p>
<div class="note info">
            <ul><li><strong>includes()方法</strong>：在给定文本存在于字符串中的任意位置时会返回 true，否则返回false；</li><li><strong>startsWith()方法</strong>：在给定文本出现在字符串起始处时返回 true ，否则返回 false；</li><li><strong>endsWith()方法</strong>：在给定文本出现在字符串结尾处时返回 true，否则返回 false。</li></ul>
          </div>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"!"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"world!"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"x"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>, <span class="number">4</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"o"</span>, <span class="number">8</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>, <span class="number">8</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h2><p>ES6 还为字符串添加了一个 repeat() 方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span>.repeat(<span class="number">3</span>));  <span class="comment">// "xxx"</span></span><br></pre></td></tr></table></figure>

<p>此方法比相同目的的其余方法更加方便，在操纵文本时特别有用，尤其是在需要产生缩进的代码格式化工具中，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indent 使用了一定数量的空格</span></span><br><span class="line"><span class="keyword">var</span> indent = <span class="string">" "</span>.repeat(<span class="number">4</span>),</span><br><span class="line">indentLevel = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每当你增加缩进</span></span><br><span class="line"><span class="keyword">var</span> newIndent = indent.repeat(++indentLevel);</span><br></pre></td></tr></table></figure>

<p><strong>上面的代码在第一次调用<code>repeat()</code>创建了一个包含四个空格的字符串，而<code>indentLevel</code>变量会持续追踪缩进的级别，此后，你可以通过增加<code>indentLevel</code>的值来调用`repeat()方法，便可以改变空格数量。</strong></p>
<h2 id="正则表达式的其他改动"><a href="#正则表达式的其他改动" class="headerlink" title="正则表达式的其他改动"></a>正则表达式的其他改动</h2><p>正则表达式是在JS中操作字符串的重要方面之一，与该语言的其他方面相似，它在以往的版本中并未有太多改变。不过，为了配合字符串的更新，ES6也对正则表达式进行了一些改进。</p>
<h3 id="正则表达式-y-标志"><a href="#正则表达式-y-标志" class="headerlink" title="正则表达式 y 标志"></a>正则表达式 y 标志</h3><p><code>y</code>标志影响正则表达式搜索时的粘连（<code>sticky</code>）属性，它表示从正则表达式的<code>lastIndex</code>属性值的位置开始检索字符串中的匹配字符，如果在该位置没有匹配成功，那么正则表达式将停止检索。看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</span><br><span class="line">pattern = <span class="regexp">/hello\d\s?/</span>,</span><br><span class="line">result = pattern.exec(text),</span><br><span class="line">globalPattern = <span class="regexp">/hello\d\s?/g</span>,</span><br><span class="line">globalResult = globalPattern.exec(text),</span><br><span class="line">stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line">pattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">globalPattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">stickyPattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">result = pattern.exec(text);</span><br><span class="line">globalResult = globalPattern.exec(text);</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]); <span class="comment">// "hello2 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]); <span class="comment">// Error! stickyResult is null</span></span><br></pre></td></tr></table></figure>

<p>此例中有三个正则表达式： pattern 中的表达式没有使用任何标志， globalPattern 使用了<code>g</code> 标志， stickyPattern 则使用了 <code>y</code> 标志。对 console.log() 的第一次调用，三个正则表达式分别都返回了 “hello1 “ ，此字符串尾部有个空格。<br>此后，三个模式的 lastIndex 属性全部被更改为 1 ，表示三个模式的正则表达式都应当从第二个字符开始尝试匹配。不使用任何标志的正则表达式完全忽略了对于 lastIndex 的更改，仍然毫无意外地匹配了 “hello1 “ ；而使用 g 标志的正则表达式继续匹配了 “hello2 “ ，因为它从第二个字符（ “e” ）开始，持续向着字符串尾部方向搜索；粘连的正则表达式则在第二个字符处没有匹配成功，因此 stickyResult 的值是 null 。<br>一旦匹配操作成功，粘连标志就会将匹配结果之后的那个字符的索引值保存在 lastIndex中；若匹配未成功，那么 lastIndex 的值将重置为 0 。全局标志的行为与其相同，如下所<br>示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</span><br><span class="line">pattern = <span class="regexp">/hello\d\s?/</span>,</span><br><span class="line">result = pattern.exec(text),</span><br><span class="line">globalPattern = <span class="regexp">/hello\d\s?/g</span>,</span><br><span class="line">globalResult = globalPattern.exec(text),</span><br><span class="line">stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex); <span class="comment">// 7</span></span><br><span class="line">result = pattern.exec(text);</span><br><span class="line">globalResult = globalPattern.exec(text);</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]); <span class="comment">// "hello2 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]); <span class="comment">// "hello2 "</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex); <span class="comment">// 14</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<p>对于 stickyPattern 和 globalPattern 模式变量来说，第一次调用之后 lastIndex 的值均被更改为 7 ，而第二次则均被改为 14 。</p>
<div class="note info">
            <p><strong>有两个关于粘连标志的微妙细节需要牢记：</strong></p><ul><li>只有调用正则表达式对象上的方法（例如 exec() 与 test() 方法）， lastIndex 属性才会生效。而将正则表达式作为参数传递给字符串上的方法（例如 match() ），并不会<br>体现粘连特性。</li><li>当使用 ^ 字符来匹配字符串的起始处时，粘连的正则表达式只会匹配字符串的起始处（或者在多行模式下匹配行首）。当 lastIndex 为 0 时， ^ 不会让粘连的正则表达式<br>与非粘连的有任何区别；而当 lastIndex 在单行模式下不对应整个字符串起始处，或者当它在多行模式下不对应行首时，粘连的正则表达式永远不会匹配成功。</li></ul>
          </div>

<p><strong>和正则表达式其他标志相同，你可以根据一个属性来检测 y 标志是否存在。此时你需要检查的是 sticky 属性，如下：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/hello\d/y</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pattern.sticky); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blog/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/6/">6</a><a class="extend next" rel="next" href="/blog/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ning Ning</p>
  <div class="site-description" itemprop="description">光、温暖、温柔</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ning Ning</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
