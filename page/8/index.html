<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ningning0908.github.io","root":"/blog/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="光、温暖、温柔">
<meta property="og:type" content="website">
<meta property="og:title" content="学习笔记">
<meta property="og:url" content="https://ningning0908.github.io/blog/page/8/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:description" content="光、温暖、温柔">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ning Ning">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://ningning0908.github.io/blog/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>学习笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">学习笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">第四章 变量、作用域和内存问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 15:00:16" itemprop="dateModified" datetime="2020-05-21T15:00:16+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>ECMAScript变量可能包含不同数据类型的值：基本类型值和引用类型值。<br>基本类型值：指的是简单的数据段，Undefined、Null、Boolean、Number和String这五种基本数据类型是按值访问的。<br>引用类型值：指的是那些可能由多个值构成的对象，引用类型的值是保存在内存中的对象。<br>与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p>
<h3 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h3><p>引用类型的值可以动态地添加属性和方法，也可以改变和删除其属性和方法，但是不能给基本类型的值添加属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为引用类型的值添加属性并给属性赋值</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// "Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为基本类型的值添加属性会返回undefined,但是不会报错</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Nicholas"</span>;</span><br><span class="line">name.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><p>基本类型值与引用类型值复制变量是不同的。<br>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，这两个变量可以参与任何操作而不会相互影响。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = num1;  <span class="comment">// num1与num2的值都是5，但是他们两个相互之间没有影响</span></span><br></pre></td></tr></table></figure>

<p>如果一个变量向另一个变量复制引用类型的值，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，但是这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制结束后，两个变量实际上将引用同一个对象，改变一个变量，就会影响另一个变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript中所有函数的参数都是按值传递的。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数），<br>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p>typeof 可以检测基本数据类型，instanceof可以检测引用数据类型。<br>根据规定，所有引用类型的值都是Object的实例，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true，<br>使用instanceof操作符检测基本类型的值，则该操作符始终会返回false。</p>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。<br>全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。<br>当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。<br>作用域链的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，活动对象在一开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。<br>作用域链中的下一个变量对象包含（外部）环境，而再下一个变量对象则来自下一个包含环境，这样，一直延续到全局执行环境，全局执行环境中的变量对象始终都是作用域链中的最后一个对象。<br>标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(color == <span class="string">"blue"</span>)&#123;</span><br><span class="line">        color = <span class="string">"red"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        color == <span class="string">"grey"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Color is "</span> + color);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color is red</span><br></pre></td></tr></table></figure>

<p>上面例子中的函数changColor()的作用域链的中包含两个对象，它自己的变量对象（其中定义着arguments）和全局环境的变量对象。<br>作用域链为它自己的变量对象 ——&gt; 全局环境的变量对象</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除，在两种情况下会发生这种现象，出现以下两种现象时，执行流进入下列任何一个语句时，作用域链就会得到加长：</p>
<ul>
<li>try-catch 语句的 catch 块；</li>
<li>with 语句。</li>
</ul>
<p>这两个语句都会在作用域的前端添加一个变量对象，对with语句来说，会将指定的对象添加到作用域链中；<br>对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。<br>如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    <span class="keyword">with</span>(location)[</span><br><span class="line">        <span class="keyword">var</span> url = href + qs;</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加进了作用域链的前端，buildUrl()函数中定义了一个变量qs，当在with语句中引用变量href时（实际引用的是location.href），可以在当前执行环境的变量对象中找到，当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中，因此with内部的url就成了函数执行环境的一部分，可以作为函数的值返回。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>JavaScript没有块级作用域，在其他类C的语言中，由花括号封闭的代码都有自己的作用域（用ECMAScript的话来说就是他们自己的执行环境）。<br>因而支持根据条件来定义变量，例如，下面的代码在JavaScript中并不会得到想象中的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>

<p>这个例子，如果是在C、C++或Java中，color会在if语句执行完毕后被销毁，但是在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。<br>使用for语句时也会发生这样的情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>for循环执行结束后，由for语句创建的i依旧存在于循环外部的执行环境中。<br><strong>解决这种办法ES6使用let声明变量，用let声明可以将作用域限制在当前块中。</strong><br><strong>声明变量：</strong>使用var声明的变量会自动被添加进最接近的环境中，在函数内部，最接近的环境就是函数的局部环境，在with语句中，最接近的环境是函数环境，如果初始化变量时没有使用var声明，该变量会自动添加进全局环境。<br><strong>查询标识符：</strong>搜索过程从作用域链的前端开始，向上逐级查询给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪；如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索，搜索过程一直追溯到全局环境的变量对象，如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。</p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>JavaScript具有自动垃圾收集机制，垃圾收集器跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，用于标识无用变量的策略主要有以下两种办法：<br>标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去除环境中的变量以及被环境中的变量引用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。<br>引用计数：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给变量时，则这个值的引用次数就是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1；相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1，当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间收回来。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">第五章 引用类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-04 11:05:18" itemprop="dateModified" datetime="2020-07-04T11:05:18+08:00">2020-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>引用类型的值（对象）是引用类型的一个实例，在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称作类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型（例如Object），以便开发人员用以实现常见的计算任务。</p>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>创建Object类型的方式有两种，第一种是使用new操作符后跟Object构造函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用对象字面量的方法，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于对象字面量语法，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;      <span class="comment">// 与new Object()相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>

<p><strong>开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉，实际上，对象字面量也是向函数传递大量可选参数的首选方式。</strong></p>
<p>访问对象属性有两种办法：点表示法和方括号表示法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>从功能上看，这两种访问对象属性的方法没有任何区别，但方括号语法的主要优点是可以通过变量来访问属性，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[propertyName]);  <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>Array类型与Object类型一样都是ECMAScript中最常用的类型，ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据，创建数组的基本方式有两种，第一种是使用Array构造函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>

<p>创建数组也可以按照下面几种方式进行创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);  <span class="comment">// 创建length为20的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);  <span class="comment">// 创建了一个包含三个字符串值的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含3项的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Grey"</span>); <span class="comment">// 创建一个包含1项，即字符串"Grey"的数组</span></span><br></pre></td></tr></table></figure>

<p>在使用Array构造函数时也可以省略new操作符，省略new操作符与不省略new操作符的结果相同。</p>
<p>创建数组的第二种基本方式是使用数组字面量表示法，数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line"><span class="keyword">var</span> name = [];   <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,];   <span class="comment">// 不要这样！这样会创建一个包含2项或3项的数组</span></span><br><span class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！这样会创建一个包含5项或6项的数组</span></span><br></pre></td></tr></table></figure>

<p>在读取和设置数组的值时，要使用方括号并提供响应值的基于0的数字索引，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 定义一个字符串数组</span></span><br><span class="line"><span class="built_in">console</span>.log(color[<span class="number">0</span>]);  <span class="comment">// 显示第一项</span></span><br><span class="line">color[<span class="number">2</span>] = <span class="string">"black"</span>;  <span class="comment">// 修改第三项</span></span><br><span class="line">color[<span class="number">3</span>] = <span class="string">"brown"</span>;  <span class="comment">// 新增第四项</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面例子的数组的length属性不是只读的，通过设置这个属性，可以从数组的末尾移除或向数组中添加新项，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>下面介绍数组会用到的一些方法</p>
<h3 id="检测数组方法"><a href="#检测数组方法" class="headerlink" title="检测数组方法"></a>检测数组方法</h3><p>ECMAScript新增Array.isArray()方法，这个方法能确定某个值最终到底是不是数组，不管在哪个全局环境下创建的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="comment">// 对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>数组继承的<code>toString()</code>返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串，<code>valueOf()</code>返回的还是Array 对象的原始值。<br>使用<code>join()</code>方法，则可以使用不同的分隔符来构建字符串，<code>join()</code>方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString());</span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf());</span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">"||"</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">red,blue,green</span><br><span class="line">[ <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span> ]</span><br><span class="line">red||blue||green</span><br></pre></td></tr></table></figure>

<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。<br>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度；pop()方法则从数组末尾移除最后一项，减少数组的length()值，然后返回移除的项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item);  <span class="comment">//"black"</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>实现这一操作的方法有两组：<br>从数组末端添加项，从数组前端取得项：push()与shift()方法<br>从数组前端添加项，从数组末端取得项：unshift()与pop()方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">//"red"</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个数组并使用push()方法先后推入了3个值，首先是”red”和”green”，然后是”black”，数组中各项的顺序为”red”,”green”,”black”，在调用shift()方法时，移除并返回的是第一项，即”red”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.unshift(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">//"green"</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个数组并使用unshift()方法先后推入了3个值，首先是”red”和”green”，然后是”black”，数组中各项的顺序为”black”,”red”,”green”，在调用pop()方法时，移除并返回的是最后一项，即”green”。</p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>reverse()方法：反转数组项的顺序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(values);  <span class="comment">//5,4,3,2,1</span></span><br></pre></td></tr></table></figure>

<p>sort()方法：按照升序或者降序顺序排列数组项，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，然后接收一个比较函数作为参数，以确定排列顺序。<br>示例如下：这个示例是按照升序进行排列的，若是按照降序排列，只需交换比较函数返回的值即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(values)；  <span class="comment">// 0，1，5，10，15</span></span><br></pre></td></tr></table></figure>

<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>要介绍的concat()方法、slice()方法都不影响原始数组。<br>concat()方法：可以基于当前数组中的所有项创建一个新数组，具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors1 = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors1.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors1);  <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure>

<p>slice()方法：能够基于当前数组中的一个或多个项创建一个新数组，slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项；<strong>如果有两个参数，该方法返回起始和结束位置之间的项但不包括结束位置的项。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors1 = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors1.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors1.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line"><span class="built_in">console</span>.log(clolors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure>

<p>splice()方法：该方法包括对原始数组的删除、插入以及替换功能</p>
<ul>
<li>删除：可以删除任意数量的项，只需提供2个参数：要删除的第一项的位置和要删除的项数；</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项；</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项，插入的项不必等于删除的项数。<br>实例如下所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);   <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);  <span class="comment">// green,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"yellow"</span>, <span class="string">"orange"</span>);  <span class="comment">// 从位置1开始插入两项</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);  <span class="comment">// green,yellow,orange,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// 返回的是一个空数组</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"red"</span>, <span class="string">"purple"</span>);     <span class="comment">// 插入两项，删除一项</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);  <span class="comment">// green,red,purple,orange,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// yellow</span></span><br></pre></td></tr></table></figure>

<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()方法，这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。<br>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1，在比较第一个参数与数组中的每一项时，使用全等操作符（===）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>, <span class="string">"blue"</span>, <span class="string">"purple"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(<span class="string">"blue"</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(<span class="string">"blue"</span>,<span class="number">2</span>);  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.latIndexOf(<span class="string">"blue"</span>);  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(<span class="string">"yellow"</span>);  <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">#比较时全等</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"blue"</span>);</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"blue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str1));  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str2));  <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(str1));  <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(str2));  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript提供了5个迭代方法，每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值,传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。以下方法都不会修改数组中的包含的值。</p>
<ul>
<li>every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li>
<li>filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数，这个方法没有返回值。</li>
<li>map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。<br>实例如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(someResult); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filterResult); <span class="comment">// [3,4,5,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mapResult); <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></span><br><span class="line"></span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> 执行某些操作，这个方法没有返回值，本质上与for循环迭代数组一样</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>))</span></span><br></pre></td></tr></table></figure>

<h3 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h3><p>ECMAScript5新增了两个缩小数组的方法：reduce()和reduceRight()。这两个数组都会迭代数组的所有项，然后构建一个最终返回的值。<br>reduce()方法从数组的第一项开始，逐个遍历到最后；reduceRight()则从数组的最后一项开始，向前遍历到第一项。<br>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值，传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象，这个函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数就是数组的第一项，第二个参数就是数组的第二项。<br>使用reduce()方法可以执行求数组中所有值之和的操作，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>reduceRight()的作用类似，只不过方向相反而已。</p>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>ECMAScript中的Date类型是在早期Java中的java.utip.Date类基础上构建的，为此，Date类型使用自UTC1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。<br>要创建一个日期对象，使用new操作符和Date构造函数即可，若需要在构造函数中传递一个表示时间的字符串作为参数，那么日期的格式为<strong>月份/日/年 时：分：秒</strong>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();   </span><br><span class="line"><span class="built_in">console</span>.log(now)     <span class="comment">//2020-07-02T09:00:51.471Z</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"12/03/2016"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(date)   <span class="comment">//2016-12-02T16:00:00.000Z</span></span><br></pre></td></tr></table></figure>

<p>在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数，为了简化这一计算，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。<br>Date.parse()是Date对象的静态方法，parse()方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。<br>语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"12/03/2016"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.parse(date))  <span class="comment">//1480694400000</span></span><br><span class="line"><span class="comment">//时间戳形式的毫秒数(计算机底层保存的都是时间戳形式的日期)</span></span><br><span class="line"><span class="keyword">var</span> time = date.getTime()</span><br><span class="line"><span class="built_in">console</span>.log(time)      <span class="comment">////1480694400000</span></span><br></pre></td></tr></table></figure>

<p>UTC() 方法可根据世界时间返回 1970 年 1 月 1 日 到指定日期的毫秒数。Date.UTC() 是一种静态方法，因为需要使用构造函数 Date() 来调用它，而不是通过某个 Date 对象调用。</p>
<p>Date.UTC() 方法的参数指定日期和时间，它们都是 UTC 时间，处于 GMT 时区。指定的UTC时间将转换成毫秒的形式，这样构造函数 Date() 和方法 Date.setTime() 就可以使用它了。<br>语法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.UTC(year,month,day,hours,minutes,seconds,ms)</span><br></pre></td></tr></table></figure>
<p>关于日期的其他方法参考一下链接：<a href="http://www.w3s.com.cn/js/jsref_obj_date.asp" target="_blank" rel="noopener">http://www.w3s.com.cn/js/jsref_obj_date.asp</a></p>
<h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>与其他引用类型一样，Date类型也重写了toLocalString()、toString()和valueOf()方法，但这些方法返回的值与其他类型中的方法不同。Date()类型的toLocalString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间，这大致意味着时间格式中会包含AM或PM，但不会包含时区信息；而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。<br>Date类型的valueOf()方法则根本不返回字符串，而是返回日期的毫秒表示。</p>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><ul>
<li><p>toDateString(): 以特定实现的格式显示星期几、月、日和年；</p>
</li>
<li><p>toTimeString(): 以特定于实现的格式显示时、分、秒和时区；</p>
</li>
<li><p>toLocalTimeString(): 以特定于实现的格式显示时、分、秒；</p>
</li>
<li><p>toLocalDateString(): 以特定于地区的格式显示星期几、月、日和年；</p>
</li>
<li><p>toUTCString(): 以特定于实现的格式显示完整的UTC日期。</p>
</li>
<li><p>还有很多关于日期的函数方法：</p>
</li>
</ul>
<p>更多参考：<a href="https:#www.w3school.com.cn/jsref/jsref_obj_date.asp">Date对象方法</a></p>
<h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>ECMAScript通过RegExp类型来支持正则表达式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure>

<p>其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标名正则表达式的行为，正则表达式的匹配模式支持下列3个标志：</p>
<ul>
<li>g: 表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
<li>i: 表示不区分大小写模式，，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m: 表示多行模式，即在到达一行文末末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>因此一个正则表达式就是一个模式与上述3个标志的组合体，不同组合产生不同结果，如下面的例子所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有"at"的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配第一个"bat"或者"cat"，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有以"at"结尾的3个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure>

<p>与其他语言中的正则表达式一样，模式中所使用的所有元字符都必须转义，正则表达式中的元字符包括：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( | &#123; \ ^ $ ) ? * + . ]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字符串和正则表达式相关的方法以及元字符的具体含义参考：<a href="http://www.w3s.com.cn/js/jsref_obj_regexp.asp" target="_blank" rel="noopener">http://www.w3s.com.cn/js/jsref_obj_regexp.asp</a></strong><br>这些元字符在正则表达式中都有一或多种特殊用途，因此想要匹配字符串中包含的这些字符，就必须对它们进行转义，下面给出几个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配第一个"[bc]at"，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有以"at"结尾的3个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern3 = <span class="regexp">/.at/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有以".at"结尾的3个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure>

<p>前面举得这些例子都是以字面量形式来定义的正则表达式，另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串，可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 与pattern1相同，只不过是使用构造函数创建的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure>

<p>使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样，在ECMAScript3 中，正则表达式字面量始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="literal">null</span>,i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    re = <span class="regexp">/cat/g</span>;</span><br><span class="line">    <span class="built_in">console</span>.log((re.test(<span class="string">"catastrophe"</span>)));   <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>, <span class="string">"g"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(re.test(<span class="string">"catastrophe"</span>));    <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一个循环中，即使是循环体指定的，但实际上只为/cat/创建了一个RegExp实例，由于实例属性不会重置，所以在循环中再次调用text()方法会失败，这是因为第一次调用test()找到了”cat”，但第二次调用是从索引为3的字符（上一次匹配的末尾）开始的，所以就找不到它了，由于会测试到字符串末尾，所以下一次再调用test()就又从开头开始了。<br>第二个循环使用RegExp构造函数在每次循环中创建正则表达式，因为每次迭代都会创建一个新的RegExp构造函数一样，每次创建新的RegExp实例。</p>
<h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li>global: 布尔值，表示是否设置了g标志；</li>
<li>ignoreCase: 布尔值，表示是否设置了i标志；</li>
<li>lastIndex: 整数，表示开始搜索下一个匹配项的字符位置，从0算起；</li>
<li>multiline: 布尔值，表示是否设置了m标志；</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。<br>实例如下所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc]at/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pattern1.global);    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.ignoreCase);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);  <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.multiline);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.source);    <span class="comment">//"\[bc]at"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pattern2.global);    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);  <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.multiline);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source);    <span class="comment">//"\[bc]at"</span></span><br></pre></td></tr></table></figure>

<h3 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h3><p>RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组，或者在没有匹配项的情况下返回null。返回的数组包含两个额外的属性：<br>index与input属性，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有匹配组，则该数组只包含一项）<br>实例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom(and dad(and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(matches.index);    <span class="comment">// 0 与整个模式匹配的字符串的第一项的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input);    <span class="comment">// "mom and dad and baby" 与整个模式匹配的字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);       <span class="comment">// "mom and dad and baby" 整个字符串本身的匹配项</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);       <span class="comment">// "and dad and baby"    与第一个捕获组匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);       <span class="comment">// "and baby"    与第二个捕获组匹配的内容</span></span><br></pre></td></tr></table></figure>

<p>对于exec()方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项，在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息，而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。如下面例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line"><span class="comment">// 非全局模式下：</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern1.exec[text];</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);   <span class="comment">//0</span></span><br><span class="line"><span class="comment">// 每次调用exec()返回的都是第一个匹配项("cat")</span></span><br><span class="line">matches = pattern1.exec[text];</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern2.exec[text];</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">//4</span></span><br><span class="line"><span class="comment">// 每次调用exec()返回的都是下一个匹配项，直到搜索到字符串末尾为止</span></span><br><span class="line">matches = pattern1.exec[text];</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

<p>正则表达式的第二个方法是test(),它接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便，因此test()方法经常被用在if语句中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这个模式有匹配项"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a>RegExp构造函数属性</h3><p>RegExp构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化，并且这些属性可以以两种方式访问，下表列出了RegExp构造函数的一些属性</p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串，Opera未实现此属性</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项，Opera未实现此功能</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组，Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本</td>
</tr>
<tr>
<td>mulitiline</td>
<td>$*</td>
<td>布尔值，表示是否所有表达式都是使用多行模式，IE和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>input字符串中lastMatch之后的文本</td>
</tr>
</tbody></table>
<p>使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);        <span class="comment">// this has been a short summer</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch);    <span class="comment">//short</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);  <span class="comment">//this has been a</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">//summer</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.mulitiline);   <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以通过短属性来访问它们，这里就不介绍了，与长属性用法相同</p>
<p>除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性，访问这些属性的方法是RegExp.$1、RegExp.$2 … RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组，在调用exec()或test()方法时，这些属性会被自动填充，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);   <span class="comment">//sh</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);   <span class="comment">//t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>函数是对象，函数名是一个指向函数对象的指针，不会与某个函数绑定，函数声明定义形式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数没有重载"><a href="#函数没有重载" class="headerlink" title="函数没有重载"></a>函数没有重载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    reurn num +<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    reurn num +<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>);  <span class="comment">//300</span></span><br></pre></td></tr></table></figure>

<p>第二个函数覆盖了第一个函数的变量，函数没有重载</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据时，会先读取函数声明，并使其在执行任何代码之前可用（可以访问），而函数表达式是等到解析器执行到它所在的代码行，才会真正被解释执行。<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 +num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析器通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中，就是sum函数已经提前声明，所以可以在前面调用</p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>函数内部有3个特殊的对象：arguments、this和caller。<br>arguments是一个类数组对象，包含着传入函数中的所有参数，除此之外arguments还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数；<br>如下递归阶乘函数所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num*<span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this引用的是函数执行的环境对象，在全局作用域中，this对象引用的是window。比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();    <span class="comment">//"red"</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();  <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>

<p>第一次调用sayColor()是在全局作用域中定义的，this引用的对象是window，所以输出为”red”, 第二次this引用的对象是0，所以this.color= o.color, 返回为”blue”<br>caller属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，会为null。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);   <span class="comment">//Function: outer</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>

<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>由于ECMAScript中的函数是对象，所以函数也有属性和方法，每个函数有两个属性：length和prototype<br>length表示函数希望接收的命名参数的个数，prototype指的函数的原型方法，toString()、valueOf()等都属于prototype内。<br>每个函数也会包含两个非继承而来的方法：apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。<br>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，其中，第二个参数可以是Array的实例，也可以是arguments对象。<br>如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,[num1,num2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>,<span class="number">10</span>))   <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>,<span class="number">10</span>))   <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>call()与apply()的作用没有什么不同，只是call()必须将传递给函数的参数逐个列举出来，如下面例子所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>,num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span>,<span class="number">10</span>))   <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>传递参数并非apply()和call()的真正用武之地，它们真正强大的地方是能扩充函数赖以运行的作用域，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor.call(<span class="keyword">this</span>);     <span class="comment">//"red"</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);   <span class="comment">//"red"</span></span><br><span class="line">sayColor.call(o);        <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript5还定义了一个方法：bind(),这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();    <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>

<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>charAt()与charCodeAt()方法，这两个方法都接收一个参数，即基于0的字符位置，charAt()方法以单字符串的形式返回给定位置的那个字符，charCodeAt()返回的是给定位置的字符编码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>；</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.charAt(<span class="number">1</span>));      <span class="comment">//"e"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.charCodeAt(<span class="number">1</span>));  <span class="comment">//"101"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><p>concat()：用于将一或多个字符串拼接起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);         <span class="comment">//"hello world!"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue)     <span class="comment">//"hello "</span></span><br></pre></td></tr></table></figure>

<p>创建新字符串的三种方法：都接受一到两个参数<br>slice()：第一个参数用于指定字符串的开始位置，第二个参数表示字符串到哪里结束<br>substring()：第一个参数用于指定字符串的开始位置，第二个参数表示字符串到哪里结束<br>substr()：第一个参数用于指定字符串的开始位置，第二个参数表示返回的字符个数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>));           <span class="comment">//"lo world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>));       <span class="comment">//"lo world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>));          <span class="comment">//"lo world"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>,<span class="number">7</span>));           <span class="comment">//"lo w"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>));       <span class="comment">//"lo w"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>,<span class="number">7</span>));          <span class="comment">//"lo worl"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h3><p>有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()，这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该字符串，则返回-1），indexOf()方法是从字符串的开头向后搜索子字符串，而和lastIndexOf()方法是从字符串的末尾向前搜索子字符串。同时这两个方法都可以接收第二个参数，表示从字符串的哪个位置开始搜索。因此可以通过循环调用indexOf()和lastIndexOf()来找到所有匹配的子字符串。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world,helo,dsjfkgsdlfkglfd"</span>;</span><br><span class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> pos = stringValue.indexOf(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(pos&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">    positions.push(pos);</span><br><span class="line">    pos = stringValue.indexOf(<span class="string">"e"</span>, pos+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(positions);   <span class="comment">// [ 1, 13 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h3><p>trim()方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"  hello world   "</span>;</span><br><span class="line"><span class="keyword">var</span> trimstringValue = stringValue.trim();</span><br><span class="line"><span class="built_in">console</span>.log(trimstringValue);  <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h3><p>字符串大小写转换方法有toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()。<br>toLowerCase()与toUpperCase()是通用方法，toLocaleLowerCase()与toLocaleUpperCase()是针对特定地区的实现，一般来说不知道自己的代码将在哪种语言运行环境下运行的时候，还是使用针对地区的方法更稳妥一些，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"Hello World"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLowerCase());</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleLowerCase());</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toUpperCase());</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleUpperCase());</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">HELLO WORLD</span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h3 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h3><p>match(): 在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，match()只接收一个参数，要么是一个正则表达式，要么是一个RegExp对象。<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> matches = text.match(pattern);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>search()：这个方法返回字符串中的第一个匹配项的索引，如果没有找到匹配项，则返回-1，这个方法的唯一参数与match()方法相同。<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"hello,bat,sat,fat"</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(pattern);</span><br><span class="line"><span class="built_in">console</span>.log(pos);   <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>replace()方法：这个方法接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的方法就是提供一个正则表达式，而且要指定全局（g）标志。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="regexp">/at/g</span>,<span class="string">"12"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c12,b12,s12,f12</span><br></pre></td></tr></table></figure>

<p>replace()方法的第二个参数也可以是一个函数，在只有一个匹配项的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match,pos,originalText</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(match) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&lt;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&gt;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&amp;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"\""</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;quot"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(htmlEscape("&lt;p class=\"greeting\"&gt;Hello World!&lt;/p&gt;"));  #&amp;lt;p class=&amp;quotgreeting&amp;quot&amp;gt;Hello World!&amp;lt;/p&amp;gt;</span><br></pre></td></tr></table></figure>

<p>split()方法：这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式），split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。如下例所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</span><br><span class="line"><span class="keyword">var</span> color = colorText.split(<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(color);                <span class="comment">//["red","blue","green","yellow"]</span></span><br></pre></td></tr></table></figure>

<h3 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h3><p>与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：<br>1、如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况是-1）；<br>2、如果字符串等于字符串参数，则返回0；<br>3、如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1）。<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"black"</span>)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a>fromCharCode()方法</h3><p>接收一或多个字符编码，将它们转换为字符串。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>));   <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure>

<h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><p>所有在全局作用域中定义的属性和方法都是Global对象的属性。除了isNaN()、isFinite()、parseInt()、parseFloat()等方法之外，Global对象还包含其他一些方法<br>这里主要介绍常用的eval()方法，eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript)字符串，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"var msg = 'hello world'"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg);    <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><h3 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.E</td>
<td>自然对数的底数，即常量e的值</td>
</tr>
<tr>
<td>Math.LN2</td>
<td>2的自然对数</td>
</tr>
<tr>
<td>Math.LN10</td>
<td>10的自然对数</td>
</tr>
<tr>
<td>Math.LOG2E</td>
<td>以2为底的e对数</td>
</tr>
<tr>
<td>Math.LOG10E</td>
<td>以10为底的e对数</td>
</tr>
<tr>
<td>Math.PI</td>
<td>Π的值</td>
</tr>
<tr>
<td>Math.SQRT1_2</td>
<td>1/2的平方根</td>
</tr>
<tr>
<td>Math.SQRt2</td>
<td>2的平方根</td>
</tr>
</tbody></table>
<h3 id="Math对象的方法"><a href="#Math对象的方法" class="headerlink" title="Math对象的方法"></a>Math对象的方法</h3><p>min()、max()方法用于确定一组数值中的最小最大值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">74</span>,<span class="number">51</span>,<span class="number">65</span>,<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max);     <span class="comment">//89</span></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">74</span>,<span class="number">51</span>,<span class="number">65</span>,<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(min);    <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>舍入方法：Math.ceil()、Math.floor()、Math.round()<br>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；<br>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；<br>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数。</p>
<h3 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h3><p>Math.random()方法返回介于0到1之间的一个随机数，不包括0和1</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.abs(num)</td>
<td>返回num的绝对值</td>
<td>Math.asin(x)</td>
<td>返回x的反正弦值</td>
</tr>
<tr>
<td>Math.exp(num)</td>
<td>返回Math.E的num次幂</td>
<td>Math.atan(x)</td>
<td>返回x的反正切值</td>
</tr>
<tr>
<td>Math.log(num)</td>
<td>返回num的自然对数</td>
<td>Math.atan2(y,x)</td>
<td>返回y/x的反正切值</td>
</tr>
<tr>
<td>Math.pow(num,power)</td>
<td>返回num的power次幂</td>
<td>Math.cos(x)</td>
<td>返回x的余弦值</td>
</tr>
<tr>
<td>Math.sqrt(num)</td>
<td>返回num的平方根</td>
<td>Math.sin(x)</td>
<td>返回x的正弦值</td>
</tr>
<tr>
<td>Math.acos(x)</td>
<td>返回x的反余弦值</td>
<td>Math.tan(x)</td>
<td>返回x的正切值</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">第七章 函数表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-11 12:23:33" itemprop="dateModified" datetime="2020-08-11T12:23:33+08:00">2020-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">JavaScript高级程序设计</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的，下面先看一个错误使用递归函数的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">1</span>));    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">4</span>));    <span class="comment">//TypeError: factorial is not a function</span></span><br></pre></td></tr></table></figure>

<p>原因是：以上代码先把factorial()函数保存在变量anotherFactorial中，然后将factorial变量设置为null,结果指向原始函数的引用只剩下一个，但在接下来调用anotherFactorial()时，由于必须执行factorial()，而factorial已经不再是函数，所以就会导致错误，该问题可以用arguments.callee解决。<br><strong>arguments.callee是一个指向正在执行的函数的指针。但在严格模式下不能通过脚本访问arguments.callee，因此在严格模式下可以使用命名函数表达式来达成相同的效果</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 非严格模式下</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">4</span>));    <span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">#严格模式下</span><br><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">4</span>));     <span class="comment">//24</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包是指有权访问另一个函数作用域中的变量的函数。</strong>创建闭包的常见方式就是在一个函数内部创建另一个函数。</p>
<h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>作用链的配置机制引出一个值得注意的副作用：<strong>即闭包只能取得包含函数中任何变量的最后一个值。但是闭包保存的是整个变量对象，而不是某个特殊的变量。</strong>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = createFunctions();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> result) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item())               <span class="comment">//0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值，在调用每个匿名函数时，传入了变量i,由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num，在匿名函数内部，又创建并返回了一个访问num的闭包，<strong>注意这样的结果是result返回的是一个指向结果的指针组成的数组，调用数组中的每个指针才能得到结果。</strong></p>
<h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><p>在闭包中使用this对象有可能会导致一些问题，<strong>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。</strong>但是，<strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window</strong>，有时候由于编写闭包的方式不同，这一点不会那么明显。<br>先看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());   <span class="comment">//undefined(在严格模式下)  "The Window"(在非严格模式下)</span></span><br></pre></td></tr></table></figure>

<p><strong>上面的代码在严格模式下取得的是undefined，在做项目时经常出现的问题，非严格模式下取得的是全局name的变量，没有取得其包含作用域（或外部作用域）的this对象</strong><br>每个函数在被调用时，其活动对象都会自动取得两个特殊变量：this和arguments，内部函数在搜索这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量，但是，把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());   <span class="comment">//'My Object'</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中最重要的不同时在定义匿名函数之前，把this对象赋值给了一个名为that的变量，在定义闭包之后，闭包也可以访问这个变量，即使在函数返回之后，this也仍然引用着object，所以上面的调用有返回值。<br><strong>this与arguments一样存在同样的问题，如果想访问arguments对象，必须将对该对象的引用保存在另一个闭包能够访问到的变量中。</strong></p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来说，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过倒是又一个私有变量的概念。<strong>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包含函数的参数、局部变量和在函数内部定义的其他函数。</strong>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个函数内部，有3个私有变量：num1、num2和sum。在函数内部可以访问这几个变量，但在函数外部则不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量，利用这一点就可以创建用于访问私有变量的公有方法。<br><strong>有权访问私有变量和私有函数的公有方法称为特权方法。</strong>有两种在对象上创建特权方法的方式，第一种是在构造函数中定义特权方法，基本模式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVariable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="built_in">console</span>.log(myObject.publicMethod())     <span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<p>这个模式在构造函数内部定义了所有私有变量和函数，然后又创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。上面的例子中的变量privateVariable和函数privateFunction()只能通过特权方法publicMethod()来访问。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/%E7%9B%92%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/%E7%9B%92%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">盒模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 19:08:46" itemprop="dateModified" datetime="2019-11-17T19:08:46+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" itemprop="url" rel="index"><span itemprop="name">CSS权威指南</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="理解盒模型"><a href="#理解盒模型" class="headerlink" title="理解盒模型"></a>理解盒模型</h2><p>元素盒子的属性分为以下三类：</p>
<ul>
<li>边框： 可以设置边框的宽窄、样式和颜色；</li>
<li>内边距：可以设置盒子内容区与边框的间距；</li>
<li>外边距：可以设置盒子与相邻元素的间距。</li>
</ul>
<p>如下面的这个盒模型示意图所示，展示了HTML 元素的边框、内边距和外边距之间的关系<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="attr"></p>
<p>外边距是边框向外推其他元素，而内边距是从边框向内推元素的内容，一个盒子有4条边，因此与边框、内边距和外边距相关的属性也各有4个，分别是上（top）、右（right）、下（bottom）、左（left）。<br><strong>CSS提供了简写样式</strong><br>CSS为边框、内边距和外边距分别规定了简写属性，可以通过一条声明就可以完成设定，在每个简写声明中，属性值的顺序都是上、右、下、左（顺时针旋转顺序）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">不使用简写属性</span><br><span class="line">&#123;</span><br><span class="line">    margin-top:<span class="number">5</span>px;</span><br><span class="line">    margin-right:<span class="number">10</span>px;</span><br><span class="line">    margin-bottom:<span class="number">12</span>px;</span><br><span class="line">    margin-left:<span class="number">8</span>px;</span><br><span class="line">&#125;</span><br><span class="line">使用简写属性</span><br><span class="line">&#123;</span><br><span class="line">    margin:<span class="number">5</span>px <span class="number">10</span>px <span class="number">12</span>px <span class="number">8</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：4个值之间有空格，但不能是其他分隔符（比如逗号之类的），甚至不用把4值都写出来，如果哪个值没有写，就使用对边的值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    margin:12px 10px 6px;     #最后一个值没有写就会使用对边的值即10px</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    margin:12px;         #4个边都取这个值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个盒子的属性也分三种粒度，到底选择哪个粒度的属性，要看你想选择哪条边，以及那条边的哪个属性，这三种粒度从一般到特殊分别是举例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 全部三个属性，全部<span class="number">4</span>条边</span><br><span class="line">&#123;</span><br><span class="line">    border:<span class="number">2</span>px dashed red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span>个属性，全部<span class="number">4</span>条边</span><br><span class="line">&#123;</span><br><span class="line">    border-style:dashed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span> <span class="number">1</span>个属性，<span class="number">1</span>条边</span><br><span class="line">&#123;</span><br><span class="line">    border-left-style:dashed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混合使用这三种粒度的简写属性达成设计目标是很常见的，。比如说吧，我想为盒子的上边和下边添加4 像素宽的红色边框，为左边添加1 像素宽的红色边框，而右边没有边框。可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">border</span>:<span class="number">4</span>px solid red;&#125; <span class="comment">/* 先给4 条边设置相同的样式 */</span></span><br><span class="line">&#123;border-left-width:<span class="number">1</span>px;&#125; <span class="comment">/* 修改左边框宽度 */</span></span><br><span class="line">&#123;border-right:none;&#125; <span class="comment">/* 移除右边框 */</span></span><br></pre></td></tr></table></figure>

<h3 id="盒子边框"><a href="#盒子边框" class="headerlink" title="盒子边框"></a>盒子边框</h3><p>边框有3个相关属性</p>
<ul>
<li>宽度(border-width)：可以使用thin、medium和thick等文本值，也可以使用除百分比和负值之外的任何绝对值；</li>
<li>样式(border-style): 有none、hidden、dotted、dashed、solid、double、groove、ridge、inset 和outset 等文本值。</li>
<li>颜色(border-color): 可以使用任意颜色值，包括RGB、HSL、十六进制颜色值和颜色关键字。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.warning &#123;border:solid #f33;&#125;                #所有带有warning类的段落都会带有一个4像素宽的红色实心边框</span><br><span class="line">p.warning &#123;border-width:4px 1px 1px 4px;&#125;     #修改边框宽度</span><br></pre></td></tr></table></figure>

<h3 id="盒子内边距-padding"><a href="#盒子内边距-padding" class="headerlink" title="盒子内边距(padding)"></a>盒子内边距(padding)</h3><p>内边距是盒子内容区与盒子边框之间的距离。同样遵从简写样式，依据上、右、下、左的顺序。</p>
<h3 id="盒子外边距-margin"><a href="#盒子外边距-margin" class="headerlink" title="盒子外边距(margin)"></a>盒子外边距(margin)</h3><p>推荐使用下面的这条规则作为样式表的第一条规则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;<span class="attr">margin</span>:<span class="number">0</span>; padding:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>根据不同需要修改外边距与内边距。</p>
<h3 id="叠加外边距"><a href="#叠加外边距" class="headerlink" title="叠加外边距"></a>叠加外边距</h3><p>垂直方向上的边距会叠加，但是像下例这样上下边距相遇时，他们就会相互叠加，直到一个外边距碰到另一个元素的边框。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*为简明起见，省略了字体声明*/</span></span><br><span class="line">p &#123;height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px;</span><br><span class="line">margin-bottom:<span class="number">30</span>px;&#125;</span><br></pre></td></tr></table></figure>

<p>上例中的第一段的下外边距与第二段的上外边距之间的外边距是50像素，不是（50+30），因为外边距叠加。<strong>较宽的外边距决定两个元素最终离多远</strong></p>
<h3 id="外边距的单位"><a href="#外边距的单位" class="headerlink" title="外边距的单位"></a>外边距的单位</h3><p>根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。比如说，一个段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间<br>距，不受字号变大或变小的影响。而对于上、下外边距，以em 为单位则可以让段间距随字号变化而相应增大或缩小，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为30 像素*/</span></span><br><span class="line">p &#123;font-size:<span class="number">1</span>em; margin:<span class="number">.75</span>em <span class="number">30</span>px;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浮动与清除"><a href="#浮动与清除" class="headerlink" title="浮动与清除"></a>浮动与清除</h2><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>CSS 设计float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性居然也成了创建多栏布局最简单的方式。</p>
<ol>
<li><strong>文本绕排图片：为了实现文本绕排图片的浮动效果，必须在标记中先写图片，然后再写环绕它的文本。</strong><br>示例如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">       /</span>*为简明起见，省略了字体声明*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        p &#123;margin:0; border:1px solid red;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>*外边距防止图片紧挨文本*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        img &#123;float:left; margin:0 4px 4px 0;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;img src="images/</span>acoustic_nylon1.jpg<span class="string">" alt="</span>nylon string acoustic guitar<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;Do you know，guitar?I very like guitar!It's my favorite a kind of instrument! If you don't know guitar,piease read this article.I believe the article will be very helpful to you!</span></span><br><span class="line"><span class="string">        The guitar is used for various musical style, it in the pop music, rock music, r&amp;b, folk music, Buddha brother Ming is regarded as the main instrument. There are also in the guitar classical music, there have been a lot of solo, selects a use of and orchestra. It usually have six strings, but there are four strings, eight and ten strings, ten strings ErXian. There are two main categories: guitar ShiYou history, a wooden sound box with the timber guitar, 8031 ErShiEr 10th century were invented, electric guitars 8031. Loudspeakers Timber guitar is usually used to classical music, folk music and popular music. Guitars are often used to, rock music, blues and pop music. The invention of receiving of western pop culture and music had important influence.</span></span><br><span class="line"><span class="string">        Now,do you learn guitar and love it?&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下所示：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/acoustic_nylon1.png" alt="attr"></p>
<p><strong>浮动非图片元素时，必须给它设定宽度，否则后果难以预料。图片无所谓，因为它本身有默认的宽度。</strong></p>
<p>2.<strong>创建分栏</strong><br>在此基础上创建多栏，只要再用一次float 属性，如下图所示，只要给段落设定宽度，然后也浮动它即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &#123;<span class="attr">float</span>:left; margin:<span class="number">0</span>; width:<span class="number">300</span>px; border:<span class="number">1</span>px solid red;&#125;</span><br><span class="line">img &#123;<span class="attr">float</span>:left; margin:<span class="number">0</span> <span class="number">4</span>px <span class="number">4</span>px <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/acoustic_nylon2.png" alt="attr"></p>
<h3 id="围住浮动元素的三种方法"><a href="#围住浮动元素的三种方法" class="headerlink" title="围住浮动元素的三种方法"></a>围住浮动元素的三种方法</h3><p>如果出现下面的这种情况应该怎么办？<strong>底部的标题跑到右边去了</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;<span class="attr">border</span>:<span class="number">1</span>px solid blue; margin:<span class="number">0</span> <span class="number">0</span> <span class="number">10</span>px <span class="number">0</span>;&#125;</span><br><span class="line">img &#123;<span class="attr">float</span>:left;&#125;</span><br><span class="line">footer &#123;<span class="attr">border</span>:<span class="number">1</span>px solid red;&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/float1.png" alt="attr"></p>
<p><strong>方法一：为父元素添加overflow:hidden，以强制它包围浮动元素。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;<span class="attr">border</span>:<span class="number">1</span>px solid blue; margin:<span class="number">0</span> <span class="number">0</span> <span class="number">10</span>px <span class="number">0</span>; overflow:hidden;&#125;</span><br><span class="line">img &#123;<span class="attr">float</span>:left;&#125;</span><br><span class="line">p &#123;<span class="attr">border</span>:<span class="number">1</span>px solid red;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：同时浮动父元素。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">section &#123;<span class="attr">border</span>:<span class="number">1</span>px solid blue; float:left; width:<span class="number">100</span>%;&#125;</span><br><span class="line">img &#123;<span class="attr">float</span>:left;&#125;</span><br><span class="line">footer &#123;<span class="attr">border</span>:<span class="number">1</span>px solid red; clear:left;&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意：由于section浮动了，所有为了强制footer依然呆在section 下方，要给它应用clear:left。</p>
<p><strong>方法三：添加非浮动的清除元素。</strong><br>强制父元素包含其浮动子元素的方法，就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素。由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）浮动元素的下方，因此包含元素一定会包含这个子元素——以及前面的浮动元素。在包含元素最后添加子元素作为清除元素的方式有两种。<br><strong>第一种如下所示：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        section &#123;border:1px solid blue;&#125;</span></span><br><span class="line"><span class="regexp">        img &#123;float:left;&#125;</span></span><br><span class="line"><span class="regexp">        .clear_me &#123;clear:left;&#125;</span></span><br><span class="line"><span class="regexp">        footer &#123;border:1px solid red;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;section&gt;</span></span><br><span class="line"><span class="regexp">            &lt;img src="images/</span>acoustic_nylon1.jpg<span class="string">" alt="</span>nylon string acoustic guitar<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;It is fun to float.&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;div class="</span>clear_me<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/section&gt;</span></span><br><span class="line"><span class="string">        &lt;footer&gt; Here is the footer element…&lt;/footer&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二种如下所示：</strong> 用CSS 来添加这个清除元素的方法，添加clearfix类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#html 部分</span><br><span class="line">&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"clearfix"</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"images/rubber_duck.jpg"</span>&gt;</span><br><span class="line">    &lt;p&gt;It is fun to float.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br><span class="line">&lt;footer&gt; Here is the footer element…&lt;<span class="regexp">/footer&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">## CSS样式</span></span><br><span class="line"><span class="regexp">.clearfix:after &#123;</span></span><br><span class="line"><span class="regexp">content:".";</span></span><br><span class="line"><span class="regexp">display:block;</span></span><br><span class="line"><span class="regexp">height:0;</span></span><br><span class="line"><span class="regexp">visibility:hidden;</span></span><br><span class="line"><span class="regexp">clear:both;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用clear:both 意味着section 中新增的子元素会清除左、右浮动元素（位于左、右浮动元素下方）。这里当然可以只用left，但both 也适用于将来图片float:right 的情况。</strong></p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>CSS 布局的核心是position 属性，对元素盒子应用这个属性，可以相对于它在常规文档流中的位置重新定位。position 属性有4 个值：static(静态定位)、relative(相对定位)、absolute(绝对定位)、fixed(固定定位)，默认值为static。<br>从完全移出文档流的角度说，固定定位与绝对定位类似。<strong>但不同之处在于，固定定位元素的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而移动</strong></p>
<h2 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h2><p>把元素的position 属性设定为relative、absolute 或fixed 后，继而可以使用top、right、bottom 和left 属性，相对于另一个元素移动该元素的位置。这里的“另一个元素”，就是该元素的定位上下文。<br>示例代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"inner"</span>&gt;This is text…&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">#搭配下面的CSS</span></span><br><span class="line"><span class="regexp">div#outer &#123;width:250px; margin:50px 40px; border-top:3px solid red;&#125;</span></span><br><span class="line"><span class="regexp">div#inner &#123;position:absolute; top:10px; left:20px; background:#ccc;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="显示属性"><a href="#显示属性" class="headerlink" title="显示属性"></a>显示属性</h2><p>正如所有元素都有position 属性，所有元素也都有display 属性。尽管display 属性的值有很多，但大多数元素display 属性的默认值不是block，就是inline</p>
<ul>
<li>块级元素，比如段落、标题、列表等，在浏览器中上下堆叠显示。</li>
<li>行内元素，比如a、span 和img，在浏览器中左右并排显示，只有前一行没有空间时才会显示到下一行。</li>
</ul>
<p>把块级元素变成行内元素（或者相反）的魔法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*默认为block*/</span></span><br><span class="line">p &#123;<span class="attr">display</span>:inline;&#125;</span><br><span class="line"><span class="comment">/*默认为inline*/</span></span><br><span class="line">a &#123;<span class="attr">display</span>:block;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CSS中每个元素盒子都可以想象成由两个图层组成，元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用实色填充（使用background-color属性），也可以包含任意多个背景图片（使用background-image 属性），背景图片叠加在背景颜色之上</p>
<h3 id="CSS背景属性"><a href="#CSS背景属性" class="headerlink" title="CSS背景属性"></a>CSS背景属性</h3><p>CSS规定以下与背景相关属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">background-color</span><br><span class="line">background-image</span><br><span class="line">background-repeat</span><br><span class="line">background-position</span><br><span class="line">background-size</span><br><span class="line">background-attachment</span><br><span class="line">background(简写属性)</span><br><span class="line">background-clip、background-origin、background-<span class="keyword">break</span>（目前尚未得到广泛支持）</span><br></pre></td></tr></table></figure>

<p><strong>背景颜色：</strong>background-color 是背景属性中最简单的，通过它可以设定元素的颜色。然后，元素就会以设定的颜色填充背景图层。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;background-color:#caebff;&#125;</span><br><span class="line">p &#123;<span class="comment">/*盒子布局样式*/</span></span><br><span class="line">    font-family:helvetica, arial, sans-serif; font-size:<span class="number">18</span>px;</span><br><span class="line">    width:<span class="number">350</span>px; margin:<span class="number">20</span>px auto; padding:<span class="number">10</span>px;</span><br><span class="line">    <span class="comment">/*这个例子中讨论背景和前景样式*/</span></span><br><span class="line">    background-color:#fff; color:#666; border:4px solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中body 的background-color 是蓝绿色，段落的background-color是白色，前景色color是灰色，前景色既影响文本，也影响边框。</p>
<p><strong>背景图片</strong>默认情况下背景图片会以元素左上角为起点，沿水平和垂直方向重复出现，最终填满整个背景区域，背景图片来源方式如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image:url(图片路径/图片文件名)</span><br></pre></td></tr></table></figure>

<p><strong>要改变默认的水平和垂直重复效果，可以修改background-repeat 属性；要改变背景图片的起点，可以修改background-position 属性。</strong></p>
<p><strong>背景重复：</strong>控制背景重复方式的background-repeat属性有4个值。默认值就是repeat，效果就是水平和垂直方向都重复，直至填满元素的背景区域为止。<br>另外3个值分别是只在水平方向重复的repeat-x、只在垂直方向上重复的repeat-y 和在任何方向上都不重复（或者说只让背景图片显示一次）的no-repeat。</p>
<ul>
<li>background-repeat:round：为确保图片不被剪切，通过调整图片大小来适应背景区域。</li>
<li>background-repeat:space，为确保图片不被剪切，通过在图片间添加空白来适应<br>背景区域。</li>
</ul>
<p><strong>背景位置：</strong>控制背景位置的background-position 属性，是所有背景属性中最复杂的。background-position 属性有5个关键字值，分别是top、left、bottom、right 和center，这些关键字中的任意两个组合起来都可以作为该属性的值<br>background-position 属性同时设定元素和图片的原点。原点决定了元素和图片中某一点的水平和垂直坐标。默认情况下，background-position 的原点位于左上角。换句话说，元素的左上角和图片的左上角是对齐的，随后图片向各个方向重复，都是以左上角为起点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*center center 的简化写法*/</span></span><br><span class="line">p#center &#123;background-position:center;&#125;   #相当于background-position:center cetner</span><br></pre></td></tr></table></figure>

<p>background-position:center center 设定图片中心点与元素中心点重合，然后再向各个方向重复<br><strong>设定背景位置时可以使用三种值：关键字、百分比、绝对或相对单位的数值。可以使用两个值分别设定水平和垂直位置。</strong></p>
<p><strong>背景尺寸：</strong>background-size 是CSS3 规定的属性，但却得到了浏览器很好的支持。这个属性用来控制背景图片的尺寸，可以给它设定的值及含义如下。</p>
<ul>
<li>50%：缩放图片，使其填充背景区的一半。</li>
<li>100px 50px：把图片调整到100 像素宽，50 像素高。</li>
<li>cover：拉大图片，使其完全填满背景区；保持宽高比。</li>
<li>contain：缩放图片，使其恰好适合背景区；保持宽高比。</li>
</ul>
<p><strong>背景粘附：</strong>background-attachment 属性控制滚动元素内的背景图片是否随元素滚动而移动。这个属性的默认值是scroll，即背景图片随元素移动。如果把它的值改为fixed，那么背景图片不会随元素滚动而移动。<br>background-attachment:fixed 最常用于给body元素中心位置添加淡色水印，让水印不随页面滚动而移动。实现这种效果的CSS 规则如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-image:url(images/watermark.png);</span><br><span class="line">    background-position:center;</span><br><span class="line">    background-color:#fff;</span><br><span class="line">    background-repeat:no-repeat;</span><br><span class="line">    background-size:contain;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写背景属性：</strong>background 属性可以用来设定所有背景相关的值。比如，前面那个backgroundattachment的例子使用简写的background 属性，可以写成这样一条规则：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123;background:url(images/watermark.png) center #fff no-repeat contain fixed;&#125;</span><br></pre></td></tr></table></figure>

<p>声明中少写了哪个属性的值（比如没写no-repeat），就会使用相应属性的默认值（repeat）。</p>
<h3 id="其他CSS3-背景属性"><a href="#其他CSS3-背景属性" class="headerlink" title="其他CSS3 背景属性"></a>其他CSS3 背景属性</h3><p>background-clip: 控制背景绘制区域的范围，比如可以让背景颜色和背景图片只出现在内容区，而不出现在内边距区域。默认情况下，背景绘制区域是扩展到边框外边界的。<br>background-origin: 控制背景定位区域的原点，可以设定为元素盒子左上角以外的位置。比如，可以设定以内容区左上角作为原点。<br>background-break: 控制分离元素（比如跨越多行的行内盒子）的显示效果。</p>
<h3 id="多背景图片"><a href="#多背景图片" class="headerlink" title="多背景图片"></a>多背景图片</h3><p>CSS3 还可以给元素背景添加多个背景图片，下面我们就使用简写属性background来说明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    height:<span class="number">150</span>px;</span><br><span class="line">    width:<span class="number">348</span>px;</span><br><span class="line">    border:2px solid #aaa;</span><br><span class="line">    margin:<span class="number">20</span>px auto;</span><br><span class="line">    font:<span class="number">24</span>px/<span class="number">150</span>px helvetica, arial, sansserif;</span><br><span class="line">    text-align:center;</span><br><span class="line">    background:</span><br><span class="line">    url(images/turq_spiral.png) <span class="number">30</span>px <span class="number">-10</span>px no-repeat,</span><br><span class="line">    url(images/pink_spiral.png) <span class="number">145</span>px <span class="number">0</span>px no-repeat,</span><br><span class="line">    url(images/gray_spiral.png) 140px -30px no-repeat, #ffbd75;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.png" alt="attr"></p>
<h3 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h3><p>渐变就是在一定长度内两种或多种颜色之间自然的过渡。渐变分两种，一种线性渐变，一种放射性渐变。线性渐变从元素的一端延伸到另一端，放射性渐变则从元素内一点向四周发散。<br>下面来看一个简单的线性渐变的例子，HTML 标记如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">'gradient1'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class='gradient2'&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">'gradient3'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 规则如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*为元素盒子添加样式*/</span></span><br><span class="line">div &#123;</span><br><span class="line">    height:<span class="number">150</span>px;</span><br><span class="line">    width:<span class="number">200</span>px;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    float:left;</span><br><span class="line">    margin:<span class="number">16</span>px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例1：默认为从上到下*/</span></span><br><span class="line">.gradient1 &#123;</span><br><span class="line">background:linear-gradient(#e86a43, #fff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例2：从左到右*/</span></span><br><span class="line">.gradient2 &#123;</span><br><span class="line">background:linear-gradient(left, #64d1dd, #fff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例3：左上到右下*/</span></span><br><span class="line">.gradient3 &#123;</span><br><span class="line">background:linear-gradient(-45deg, #e86a43, #fff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示了三种简单的渐变效果。例1 声明了一种开始属性和一种结束颜色，这两种颜色会按照默认的方向（从下到下）实现平滑过渡。例2 起点关键字left，于是渐变方向变成了从左到另一端。例3 声明了-45deg（deg 是“度”），等于把起点从默认的中上设定到了左上。<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E4%B8%89%E7%A7%8D%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.png" alt="attr"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/HTML%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/HTML%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">HTML标记与文档结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 19:08:46" itemprop="dateModified" datetime="2019-11-17T19:08:46+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" itemprop="url" rel="index"><span itemprop="name">CSS权威指南</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>CSS的用途就是为HTML标记添加样式，所以，我们首先要先知道怎么编写和构造HTML标记，才能让CSS更方便地为它添加样式。用HTML标记内容的目的是为了赋予网页语义，我们平常用的浏览器、给视障用户朗读网页的屏幕阅读器，以及搜索引擎放出的Web爬虫都是用户代理，它们需要显示、朗读和分析网页。HTML规定了一组标签，用来给内容打上不同的标记，每个标签都是对所包含内容的一种描述，最常用的HTML标签描述的是标题、段落、链接和图片。目前，HTML一共有114个标签，但按照80/20的原则，使用其中25个左右的标签就可以满足80%的标记需要。<br>在给内容都打上标记之后，就可以使用CSS来给标签添加样式了，添加样式的依据有标签名、标签属性（如id和class）、以及标签与其他标签在标记中的相对位置关系，等等。HTML标签也会构成一个层次化的文档，从而可以通过CSS来设置网页的布局，为每个元素应用你想要的样式。</p>
<h2 id="HTML标记基础"><a href="#HTML标记基础" class="headerlink" title="HTML标记基础"></a>HTML标记基础</h2><h3 id="文本用闭合标签格式如下"><a href="#文本用闭合标签格式如下" class="headerlink" title="文本用闭合标签格式如下"></a>文本用闭合标签格式如下</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;标签名&gt;文本内容&lt;<span class="regexp">/标签名&gt;</span></span><br></pre></td></tr></table></figure>

<p>标题、段落等文本元素都要求闭合标签，也就是要有一个开标签和一个闭标签</p>
<h3 id="引用内容用自闭合标签格式如下"><a href="#引用内容用自闭合标签格式如下" class="headerlink" title="引用内容用自闭合标签格式如下"></a>引用内容用自闭合标签格式如下</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;标签名 属性_1=<span class="string">"属性值"</span> 属性_n=<span class="string">"属性值"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>非文本内容是通过自闭合标签显示的，比如图片等，闭合标签与自闭合标签的区别在于闭合标签包含的是会显示的实际内容，而自闭合标签只是给浏览器提供一个对要显示内容的引用。浏览器会在HTML页面加载的时候，额外想服务器发送请求，以取得自闭合标签引用的内容。下面就是使用自闭合标签标记的一张图片。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"images/cisco.jpg"</span> alt=<span class="string">"My dog Cisco"</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性负责为浏览器提供有关标签的额外信息，比如说，前面例子中的<code>&lt;img&gt;</code>标签有两个属性，一个属性是src(source，来源)，属性值是cisco.jpg，这个属性定义了图片的来源是一个名为cisco.jpg的文件，另一个属性是alt(alternative，替代内容)，定义的是在图片因故未能加载成功时在屏幕上显示的文本。</p>
<p><strong>视障用户使用的屏幕阅读器会大声读出alt属性的内容，因此一定要给<code>&lt;img&gt;</code>标签的这个alt属性添加让人一听（或一看）就能明白的内容。</strong></p>
<h3 id="标题与段落"><a href="#标题与段落" class="headerlink" title="标题与段落"></a>标题与段落</h3><p>一般来说，网页都会以一个<code>&lt;h1&gt;</code>标签开头，其中的文本用于告诉读者这个网页是干什么的，然后用<code>&lt;h2&gt;</code>标记下一级内容，或许是一个副标题，然后才是<code>&lt;h3&gt;</code>，以此类推。<br><code>&lt;h1&gt;</code>不仅是最大最突出的标题（除非你用CSS缩小它的字号），搜索引擎也会将其视为仅次于<code>&lt;title&gt;</code>标签的另一个搜索关键词的来源。<br>段落用于标记主要的文本内容，是所有文本元素中出场率最高的一个，简言之，只要有不适合放在其他文本标签中的文本，都可以把它放在一个段落里。</p>
<h3 id="复合元素"><a href="#复合元素" class="headerlink" title="复合元素"></a>复合元素</h3><p>HTML不仅规定了标题、图片和段落等基本的内容标记，还规定了用于创建列表、表格和表单等复杂用户界面组件的标记，这些就是所谓的复合元素，即它们是由多个标签共同完成的。比如，<code>&lt;li&gt;</code>是一个列表项，它只在<code>&lt;ol&gt;</code>(有序列表)和<code>&lt;ul&gt;</code>(无序列表)中才有效，在<code>&lt;dl&gt;</code>(定义列表)中则无效。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;Save HTML file&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Move file to Web server via FTP&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Preview <span class="keyword">in</span> browser&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>ol&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/HTML%E5%A4%8D%E5%90%88%E5%85%83%E7%B4%A0.png" alt="attr"></p>
<h3 id="嵌套标签"><a href="#嵌套标签" class="headerlink" title="嵌套标签"></a>嵌套标签</h3><p>在上面的例子中，基于<code>&lt;li&gt;</code>标签与<code>&lt;ol&gt;</code>标签的嵌套关系，可以说<code>&lt;li&gt;</code>标签是<code>&lt;ol&gt;</code>标签的子标签（或子元素），或者说<code>&lt;ol&gt;</code>标签是<code>&lt;li&gt;</code>标签的夫标签（父元素）。<br>**注意：在一个标签里嵌套另一个标签必须先关闭后一个标签再关闭前一个标签，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;That car is &lt;em&gt;fast&lt;<span class="regexp">/em&gt;.&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<p>HTML文档的结构正是通过类似这样的标签嵌套，以及就此建立起来标签间的“父——子”关系形成的。</p>
<h2 id="HTML文档剖析"><a href="#HTML文档剖析" class="headerlink" title="HTML文档剖析"></a>HTML文档剖析</h2><h3 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a>HTML模板</h3><p>按照HTML5语法编写的最简单的HTML页面的模板可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;!-- 这里是网页内容--&gt;</span><br><span class="line">    &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>模板的第一行代码是一种新语法，或者说是一种简化的DOCTYPE，这一行就是为了声明： “以下是一个HTML文档。”<strong>这个标签不用关闭。</strong><br><code>&lt;html&gt;</code>标签是根级标签，页面中所有的其他标签都嵌套在这个标签内部，而且它的闭标签也是整个页面中的最后一个闭标签，<code>&lt;html&gt;</code>标签只有两个直接的子标签：<code>&lt;head&gt;</code>和<br><code>&lt;body&gt;</code>。<br>帮助浏览器理解页面的信息都包含在<code>&lt;head&gt;</code>标签中，在上面的例子中，<code>&lt;head&gt;</code>标签里只包含<code>&lt;meta&gt;</code>和<code>&lt;title&gt;</code>两个标签，其中<code>&lt;meta&gt;</code>标签中有一个charset属性，它是在告诉浏览器这个页面使用的是UTF-8编码，<code>&lt;title&gt;</code>标签的文本会在页面显示时，作为整个页面的标题出现在浏览器窗口顶部的标题栏中。<br><code>&lt;body&gt;</code>标签则包含着标记所有内容的HTML元素。</p>
<h3 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h3><p><strong>下面介绍一些块级标签和行内标签：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">块级标签</span><br><span class="line">&lt;h1&gt;-&lt;h6&gt;: 6级标签，&lt;h1&gt;表示最重要</span><br><span class="line">&lt;p&gt;: 段落</span><br><span class="line">&lt;lo&gt;: 有序列表</span><br><span class="line">&lt;li&gt;：列表项</span><br><span class="line">&lt;blockquote&gt;: 独立引用</span><br><span class="line">行内标签</span><br><span class="line">&lt;a&gt;：链接（anchor，锚）</span><br><span class="line">&lt;img&gt;: 图片</span><br><span class="line">&lt;em&gt;：斜体</span><br><span class="line">&lt;strong&gt;：重要</span><br><span class="line">&lt;abbr&gt;：简写</span><br><span class="line">&lt;cite&gt;: 引证</span><br><span class="line">&lt;q&gt;: 文本内引用</span><br></pre></td></tr></table></figure>

<p>几乎所有HTML元素的display属性值要么是block，要么是inline。最明显的一个例外是table元素，它有自己的display属性值。<br>块级元素（比如标题和段落）会相互堆叠在一起沿页面向下排列，每个元素分别占一行，而行内元素（比如链接和图片）则会相互并列，只有在空间不足以并列的情况下才会折到下一行显示。</p>
<p><strong>使用块级元素和行内元素构建页面：</strong> 示例如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br><span class="line">    &lt;title&gt;Block and Inline Elements&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Types <span class="keyword">of</span> Guitars&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;Guitars come in two main types: electric and acoustic.&lt;/</span>p&gt;</span><br><span class="line">    &lt;h2&gt;Acoustic Guitars&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;Acoustic guitars have a large hollow body that projects the sound of the strings.&lt;/</span>p&gt;</span><br><span class="line">    &lt;h3&gt;Nylon <span class="built_in">String</span> Acoustic Guitars&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;Descendants of the gut-strung instruments pf yore,nylon string guitars have a mellow tone.&lt;/</span>p&gt;</span><br><span class="line">    &lt;h2&gt;Electric Guitars&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img src="images/</span>acoustic_nylon.jpg<span class="string">" alt="</span>nylon string acoustic guitar<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Electric guitars have a solid or hollow body with pickups that capture the string vibration so it can be amplified.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%95%E9%A1%B5%E9%9D%A2.png" alt="attr"></p>
<h3 id="嵌套的元素"><a href="#嵌套的元素" class="headerlink" title="嵌套的元素"></a>嵌套的元素</h3><p>嵌套标记实际上就是嵌套盒子，在后面CSS盒模型重点介绍</p>
<h2 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h2><p>HTML结构所对应的文档对象模型（以下简称”DOM”）,DOM是从浏览器的视角观察页面中的元素以及每个元素的属性，由此得出这些元素的一个家族树，通过DOM可以确定元素之间的相互关系，在CSS中引用DOM中特定的位置，就可以选中响应的HTML元素，并修改其样式属性。示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">        &lt;h1&gt;The Document <span class="built_in">Object</span> Model&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;The page's HTMLmarkup structure defines the DOM.&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<p>对于这个例子中的DOM层次，我们可以做如下表述。</p>
<ul>
<li>section是h1和p的父元素，也是直接祖先元素；</li>
<li>h1和p是section的子元素，也是直接后代元素；</li>
<li>h1和p是同胞元素，它们有共同的父元素section;</li>
<li>section、h1和p是body的后代元素，或者下面的元素（嵌套在后者的内部）；</li>
<li>section和body是h1和p的祖先元素，或者上面的元素（在某一层次上包含后者）。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">媒体查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 19:09:33" itemprop="dateModified" datetime="2019-11-17T19:09:33+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" itemprop="url" rel="index"><span itemprop="name">CSS权威指南</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>媒体查询提供一种查询语法去扩展媒体类型，这种查询语法可以更加具体地为用户的设备提供样式，媒体查询可以给你一种自由，让网站真正地与设备无关，不管用户如何访问网站，都为它们提供最佳的合适体验。</p>
<h2 id="媒体查询的优点"><a href="#媒体查询的优点" class="headerlink" title="媒体查询的优点"></a>媒体查询的优点</h2><p>媒体查询会基于设备的属性来检测设备，这样就不需要使用浏览器探测脚本，之后允许直接安装设备的功能区设定目标样式表，所以如果检测到用户适应小屏幕的设备，CSS规则就会调整以适应该屏幕尺寸，从屏幕上去掉无关元素，提供更小的图片，让文本变得更加清晰。</p>
<h2 id="HTML-lt-link-gt-标签"><a href="#HTML-lt-link-gt-标签" class="headerlink" title="HTML&lt;link&gt;标签"></a>HTML<code>&lt;link&gt;</code>标签</h2><p>实例：链接一个外部样式表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"theme.css"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br></pre></td></tr></table></figure>

<p>在用于样式表时，<code>&lt;link&gt;</code>标签得到了几乎所有浏览器的支持，但是几乎没有浏览器支持其他方面的用途。<br><strong>定义和用法：</strong><br><code>&lt;link&gt;</code> 标签定义文档与外部资源的关系。<br><code>&lt;link&gt;</code> 标签最常见的用途是链接样式表。<br><strong>HTML 与 XHTML 之间的差异:</strong></p>
<p>第一种是使用<code>&lt;link&gt;</code>元素区调用一个外部样式表：<br>在 HTML 中，<code>&lt;link&gt;</code> 标签没有结束标签。<br>在 XHTML 中，<code>&lt;link&gt;</code> 标签必须被正确地关闭。<br><strong>提示和注释：</strong><br>注释：link 元素是空元素，它仅包含属性。<br>注释：此元素只能存在于 head 部分，不过它可出现任何次数。<br><strong>属性：这里仅介绍HTML5中的新属性</strong></p>
<table>
    <tr>
        <td>属性</td>
        <td>值</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>href</td>
        <td>URL</td>
        <td>规定被链接文档的位置。</td>
    </tr>
    <tr>
        <td>hreflang</td>
        <td>language_code</td>
        <td>规定被链接文档中文本的语言。</td>
    </tr>
    <tr>
        <td>media</td>
        <td>media_query</td>
        <td>规定被链接文档将被显示在什么设备上。</td>
    </tr>
    <tr>
        <td rowspan="13">rel</td>
        <td >alternate</td>
        <td rowspan="13">规定当前文档与被链接文档之间的关系。</td>
    </tr>
    <tr>
        <td >author</td>
    </tr>
    <tr>
        <td >help</td>
    </tr>
    <tr>
        <td >icon</td>
    </tr>
    <tr>
        <td >licence</td>
    </tr>
    <tr>
        <td >next</td>
    </tr>
    <tr>
        <td >pingback</td>
    </tr>
    <tr>
        <td >prefetch</td>
    </tr>
    <tr>
        <td >prev</td>
    </tr>
    <tr>
        <td >search</td>
    </tr>
    <tr>
        <td >sidebar</td>
    </tr>
    <tr>
        <td >tag</td>
    </tr>
    <tr>
        <td >stylesheet</td>
    </tr>
    <tr>
        <td rowspan="2">sizes</td>
        <td>heightxwidth</td>
        <td rowspan="2">规定被链接资源的尺寸。仅适用于 rel="icon"。</td>
    </tr>
    <tr>
        <td>any</td>
    </tr>
    <tr>
        <td>type</td>
        <td>MIME_type</td>
        <td>规定被链接文档的 MIME 类型。</td>
    </tr>
</table>

<p><strong>全局属性</strong></p>
<table>
    <tr>
        <td>属性</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>accesskey</td>
        <td>规定激活元素的快捷键。</td>
    </tr>
    <tr>
        <td>class</td>
        <td>规定元素的一个或多个类名（引用样式表中的类）</td>
    </tr>
    <tr>
        <td>contenteditable</td>
        <td>规定元素内容是否可编辑。</td>
    </tr>
    <tr>
        <td>contextmenu</td>
        <td>规定元素的上下文菜单。上下文菜单在用户点击元素时显示。</td>
    </tr>
    <tr>
        <td>data-*</td>
        <td>用于存储页面或应用程序的私有定制数据。</td>
    </tr>
    <tr>
        <td>dir</td>
        <td>规定元素中内容的文本方向。</td>
    </tr>
    <tr>
        <td>draggle</td>
        <td>规定元素是否可拖动。</td>
    </tr>
    <tr>
        <td>dropzone</td>
        <td>规定在拖动被拖动数据时是否进行复制、移动或链接。</td>
    </tr>
    <tr>
        <td>hidden</td>
        <td>规定元素仍未或不再相关。</td>
    </tr>
    <tr>
        <td>id</td>
        <td>规定元素的唯一 id。</td>
    </tr>
    <tr>
        <td>lang</td>
        <td>规定元素内容的语言。</td>
    </tr>
    <tr>
        <td>spellcheck</td>
        <td>规定是否对元素进行拼写和语法检查。</td>
    </tr>
    <tr>
        <td>style</td>
        <td>规定元素的行内 CSS 样式。</td>
    </tr>
    <tr>
        <td>tabindex</td>
        <td>规定元素的 tab 键次序。</td>
    </tr>
    <tr>
        <td>title</td>
        <td>规定有关元素的额外信息。</td>
    </tr>
    <tr>
        <td>translate</td>
        <td>规定是否应该翻译元素内容。</td>
    </tr>
</table>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>媒体查询设置了一个参数（或者一系列参数），如果设备在查看页面的时候具有与该参数匹配的属性，就会显示与之相关的样式规则。有三种方式使用媒体查询，它们是和我们把CSS应用到文档中的不同方式相匹配的，第一种是使用一个link元素去调用一个外部样式表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"file"</span> rel=<span class="string">"stylesheet"</span> media=<span class="string">"logic media and (expression)"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>第二种是使用@import指令调用外部的样式表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">'file'</span>) logic media and (expression);</span><br></pre></td></tr></table></figure>

<p>第三种是在一个嵌入的style元素中或在样式表本身利用扩展的@media规则使用媒体查询：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media logic media and (expression) &#123; rules &#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/DOM%E9%80%89%E6%8B%A9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/DOM%E9%80%89%E6%8B%A9%E5%99%A8/" class="post-title-link" itemprop="url">DOM选择器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 19:08:46" itemprop="dateModified" datetime="2019-11-17T19:08:46+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" itemprop="url" rel="index"><span itemprop="name">CSS权威指南</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器是在CSS2中引入的，他们能够指定一些规则，这些规则根据元素的属性（诸如href或title）以及这些属性的值对元素进行匹配</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">lang</span>=<span class="string">"en-GB"</span> <span class="attr">rel</span>=<span class="string">"friend net"</span>&gt;</span>Peter<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;&lt;a href="" lang="es-ES" rel-"fiend"&gt;Pedro&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;&lt;a href="" lang="es-MX" rel-"contact"&gt;Pancho&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>

<h3 id="简单属性选择器"><a href="#简单属性选择器" class="headerlink" title="简单属性选择器"></a>简单属性选择器</h3><p>将规则应用到定义了指定属性的元素上，而不管属性的值是什么</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[rel] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于所有元素都有rel属性，所以所有元素都会应用这条规则</p>
<h3 id="精确属性值选择器"><a href="#精确属性值选择器" class="headerlink" title="精确属性值选择器"></a>精确属性值选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[rel=<span class="string">'friend'</span>] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码只会将规则标记到第二个a元素</p>
<h3 id="部分属性选择器"><a href="#部分属性选择器" class="headerlink" title="部分属性选择器"></a>部分属性选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[rel~=<span class="string">'friend'</span>] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码会选择rel属性中带有friend的值的元素，则这个规则会标记到第一与第二个</p>
<h3 id="语言属性选择器"><a href="#语言属性选择器" class="headerlink" title="语言属性选择器"></a>语言属性选择器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[lang|=<span class="string">'es'</span>] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选中所有属性值以es开头的lang语言，即会选中2和3</p>
<h2 id="CSS3的新属性选择器"><a href="#CSS3的新属性选择器" class="headerlink" title="CSS3的新属性选择器"></a>CSS3的新属性选择器</h2><h3 id="开始字串属性值选择器（开始选择器）"><a href="#开始字串属性值选择器（开始选择器）" class="headerlink" title="开始字串属性值选择器（开始选择器）"></a>开始字串属性值选择器（开始选择器）</h3><p>该选择器会选择一些元素，这些元素所选择的属性是以一个字符串为起始，该字符串会作为参数提供给选择器，这个选择器使用插入符号(^)修饰属性中的等号</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E[attr^=<span class="string">'value'</span>] &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码将在指定属性的起始处寻找指定的值<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Lorem ipsum dolor &lt;a href=<span class="string">"mailto:email@example.com"</span>&gt;email&lt;a&gt; sit amet.&lt;<span class="regexp">/a&gt;&lt;/</span>p&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">a[href^=<span class="string">'mailto'</span>] &#123;</span><br><span class="line">    background-image: url(<span class="string">'email_go.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lorem ipsum dolor email sit amet.  #这里的email是一个地址即上述href绑定的地址 email原为一图片索引，本人懒就没放图片</span><br></pre></td></tr></table></figure>

<h3 id="结束子串属性值选择器（结束选择器）"><a href="#结束子串属性值选择器（结束选择器）" class="headerlink" title="结束子串属性值选择器（结束选择器）"></a>结束子串属性值选择器（结束选择器）</h3><p>与开始选择器相反，使用该选择器去选择以指定的值结束的属性<br>语法差异为用($)去修饰(=)</p>
<h3 id="任意子串属性值选择器（任意选择器）"><a href="#任意子串属性值选择器（任意选择器）" class="headerlink" title="任意子串属性值选择器（任意选择器）"></a>任意子串属性值选择器（任意选择器）</h3><p>该选择器使用规则即在指定的属性字符串的内部任意位置搜索指定的子串<br>该选择器使用的符号是(*)</p>
<h3 id="多属性选择器"><a href="#多属性选择器" class="headerlink" title="多属性选择器"></a>多属性选择器</h3><p>可以把多个选择器串接在一起，这样在选择目标的时候能够做到非常的具体，使用多选择器，可以通过定义在开始、结束以及中间任意位置的值创建应用到属性上的规则</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com/folder1/file.pdf"</span>&gt;</span>Lorem ipsum<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="http:/</span><span class="regexp">/example.com/</span>folder2/file.pdf<span class="string">"&gt;Lorem ipsum&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<p> 如果要指定一条只应用到第二个p元素的规则，可以把一些选择器串接到一起：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[href^=<span class="string">'http://'</span>][href*=<span class="string">'/folder2/'</span>][href$=<span class="string">'.pdf'</span>] &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码会寻找这样的a元素，它具有一个href属性，是以 http: // 开始，以.pdf结束，并且在中间包含了/folder2/，非常明确</p>
<h3 id="普通兄弟连结符"><a href="#普通兄弟连结符" class="headerlink" title="普通兄弟连结符"></a>普通兄弟连结符</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E + F &#123;&#125; #相邻兄弟连结符</span><br><span class="line">E ~ F &#123;&#125; #普通兄弟连结符</span><br></pre></td></tr></table></figure>

<p>相邻兄弟连结符选择的是文档树的同一层级，紧邻在元素(E)之后的任意元素；<br>普通兄弟连结符选择的是文档树的同一层级，位于元素(E)之后的任意元素。<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;Next we are going to discuss ... &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;h2&gt;Ren&amp;eacute; Descartes&lt;/</span>h2&gt;</span><br><span class="line">&lt;p&gt;A highly influential French philosopher...&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;He only famously declared:&lt;/</span>p&gt;</span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">    &lt;p&gt;I think,therefore I am.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>blockquote&gt;  </span><br><span class="line">&lt;p&gt;However,<span class="keyword">this</span> presumes the existence <span class="keyword">of</span> the speaker.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">h2 + p &#123;</span></span><br><span class="line"><span class="regexp">    font-weight:bolder;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">h2 ~ p &#123;</span></span><br><span class="line"><span class="regexp">    font-style: italic;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ningning0908.github.io/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/CSS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="Ning Ning">
      <meta itemprop="description" content="光、温暖、温柔">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/CSS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">CSS工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 20:38:59" itemprop="dateCreated datePublished" datetime="2020-04-17T20:38:59+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-17 19:08:46" itemprop="dateModified" datetime="2019-11-17T19:08:46+08:00">2019-11-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" itemprop="url" rel="index"><span itemprop="name">CSS权威指南</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>每个HTML元素都有一组样式属性，可以通过CSS来设定。这些属性涉及元素在屏幕上显示时的不同方面，比如在屏幕上位置、边框的宽度，文本内容的字体、字号<br>和颜色，等等。CSS就是一种先选择HTML元素，然后设定选中元素CSS属性的机制。CSS选择符和要应用的样式构成了一条CSS 规则。</p>
<h2 id="剖析CSS规则"><a href="#剖析CSS规则" class="headerlink" title="剖析CSS规则"></a>剖析CSS规则</h2><p>规则实际上就是一条完整的CSS 指令。规则声明了要修改的元素和要应用给该元素的样式。下面就是一条CSS规则，它可以把段落的文本设置为红色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;<span class="attr">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>

<p>把以上代码放到我们的HTML5模板中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        /</span>*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        p &#123;color: red;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;This text is very important!&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;body&gt;</code>元素中的<code>&lt;p&gt;</code>字段就会变成红色。<br><strong>为文档添加样式的三种方法：</strong><br>有三种方法可以把CSS添加到网页中，分别是写在元素标签里（也叫行内样式）、写在<code>&lt;style&gt;</code>标签里（也叫嵌入样式）和写在单独的CSS样式表中（也叫链接样式）。<br><strong>行内样式</strong><br>行内样式是写在特定HTML标签的style属性里的，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;This paragraph simply takes on the browser <span class="keyword">default</span> paragraph style.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p style="font-size: 12px; font-weight:bold; font-style:italic; color:red;"&gt;By</span></span><br><span class="line"><span class="regexp">adding inline CSS styling to this paragraph, you override the default styles.&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<p>行内样式的作用范围非常有限，行内样式只能影响它所在的标签，而且总会覆盖嵌入样式和链接样式。<br><strong>嵌入样式</strong><br>嵌入的CSS样式是放在HTML文档的head元素中的，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;!-- 其他head 元素（如meta、title）放在这里 --&gt;</span><br><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">h1 &#123;font-size:<span class="number">16</span>px;&#125;</span><br><span class="line">p &#123;<span class="attr">color</span>:blue;&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br></pre></td></tr></table></figure>

<p>嵌入样式的应用范围仅限于当前页面。页面样式会覆盖外部样式表中的样式，但会被行内样式覆盖。像本书前面例子中那样使用嵌入方式为某个组件（比如菜单）设计样式是很方便的，因为HTML 和CSS 同在一页，可以互相参照。但是，等到CSS 样式设计完毕，组件功能齐备之后，还是应该把相应的样式转移到外部样式表，以便其他页面也能共用相同的样式。<br><strong>链接样式</strong><br>在创建包含多个页面的网站时，需要把样式集中在一个单独的文件里，这个文件就叫样式表。样式表其实就是一个扩展名为.css 的文本文件。可以在任意多个HTML 页面中链接同一个样式表文件，每个页面中只需加入类似下面的这一行代码即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">"style.css"</span> rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>链接样式的作用范围可以是整个网站。只要使用<code>&lt;link&gt;</code>标签把样式表链接到每个页面，相应的页面就可以使用其中的样式。随后，只要修改了样式表中的样式，改动就会在所有被选中的元素上体现出来，无论这个元素在哪个页面里。这样，既可以做到全站页面外观统一，又便于整站样式更新。<br>除了以上三种为页面添加样式的方法，还有一种在样式表中链接其他样式表的方法，那就应用@import 指令（是一种at 规则）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(css/styles2.css)</span><br></pre></td></tr></table></figure>

<p><strong>要注意的是，@import 指令必须出现在样式表中其他样式之前，否则@import 引用的样式表不会被加载。</strong><br>有一点很重要，那就是CSS 样式是通过<code>&lt;style&gt;</code>标签嵌入到页面里的。当浏览器遇到开标签<code>&lt;style&gt;</code>时，就会由解释HTML 代码切换为解释CSS 代码。等遇到闭标签<br><code>&lt;/style&gt;</code>时，它会再切换回解释HTML 代码。<br>对于写在样式表里的样式，就不需要<code>&lt;style&gt;</code>标签了。如果你在样式表里加上这个标签，样式表中的样式就不会被浏览器加载了。</p>
<h3 id="CSS规则命名惯例"><a href="#CSS规则命名惯例" class="headerlink" title="CSS规则命名惯例"></a>CSS规则命名惯例</h3><p>CSS规则由选择符和声明两部分组成，其中选择符用于指出规则所要选择的元素，声明则又由两部分组成：属性和值，属性指出要影响哪方面的样式，值就是属性的一个新状态。如下图所示：<img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/CSS%E8%A7%84%E5%88%99.png" alt="attr"><br>对这个基本的结构，有三种方法可以进行扩展。<br><strong>第一种方法：多个声明包含在一条规则里。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &#123;<span class="attr">color</span>:red; font-size:<span class="number">12</span>px; font-weight:bold;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种方法：多个选择符组合在一起。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;<span class="attr">color</span>:blue; font-weight:bold;&#125;</span><br><span class="line">h2 &#123;<span class="attr">color</span>:blue; font-weight:bold;&#125;</span><br><span class="line">h3 &#123;<span class="attr">color</span>:blue; font-weight:bold;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三种方法：多条规则应用给一个选择符。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h1, h2, h3 &#123;<span class="attr">color</span>:blue; font-weight:bold;&#125;</span><br><span class="line">h3 &#123;font-style:italic;&#125;</span><br></pre></td></tr></table></figure>

<p>所有用于选择特定元素的选择符又分三种。</p>
<ul>
<li>上下文选择符。基于祖先或同胞元素选择一个元素。</li>
<li>ID 和类选择符。基于id 和class 属性的值（你自己设定）选择元素。</li>
<li>属性选择符。基于属性的有无和特征选择元素。</li>
</ul>
<h2 id="上下文选择符"><a href="#上下文选择符" class="headerlink" title="上下文选择符"></a>上下文选择符</h2><p>像这种“基于位置”变换某个标签样式的问题，可以用上下文选择符来解决。<br>上下文选择符的格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签<span class="number">1</span> 标签<span class="number">2</span> &#123;声明&#125;</span><br></pre></td></tr></table></figure>

<p>其中，标签2就是我们想要选择目标，而且只有标签1是其祖先元素（不一定是父元素）的情况下才会被选中。<br>上下文选择符，也叫后代组合式选择符，就是一组以空格分隔的标签名，用于选择作为指定祖先元素后代的标签。如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article p &#123;font-weight: bold;&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子的上下文选择符表明，只有是article后代的p元素才会应用后面的样式。</p>
<h2 id="特殊的上下文选择符"><a href="#特殊的上下文选择符" class="headerlink" title="特殊的上下文选择符"></a>特殊的上下文选择符</h2><p>上面介绍的上下文选择符是以某个祖先标签作为上下文，不过，有时候我们可能还会需要比“某些祖先”更加具体的上下文。比如说吧，要是你想根据父元素或者同胞元素的标签<br>名来选择元素怎么办呢？下面我们再用另一段标记来演示几种特殊的上下文选择符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;h2&gt;An H2 Heading&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;This is paragraph 1&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;Paragraph <span class="number">2</span> has &lt;a href=<span class="string">"#"</span>&gt;a link&lt;<span class="regexp">/a&gt; in it.&lt;/</span>p&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;Link&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br></pre></td></tr></table></figure>

<h3 id="子选择符-gt"><a href="#子选择符-gt" class="headerlink" title="子选择符&gt;"></a>子选择符&gt;</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标签<span class="number">1</span> &gt; 标签<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>标签2必须是标签1的子元素，或者反过来说，标签1必须是标签2的父元素，不能是其他祖先元素。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        /</span>*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        section &gt; h2 &#123;font-style:italic;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;section&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h2&gt;An H2 Heading&lt;/</span>h2&gt;</span><br><span class="line">            &lt;p&gt;This is paragraph <span class="number">1</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;Paragraph 2 has &lt;a href="#"&gt;a link&lt;/</span>a&gt; <span class="keyword">in</span> it.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href="#"&gt;Link&lt;/</span>a&gt;</span><br><span class="line">        &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>展示效果如下所示：</p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%AD%90%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<h3 id="紧邻同胞选择符"><a href="#紧邻同胞选择符" class="headerlink" title="紧邻同胞选择符+"></a>紧邻同胞选择符+</h3><p>标签1 + 标签2<br>标签2必须紧跟在其同胞标签1的后面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h2 + p &#123;font-variant:small-caps;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E7%B4%A7%E9%82%BB%E5%90%8C%E8%83%9E%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<h3 id="一般同胞选择符"><a href="#一般同胞选择符" class="headerlink" title="一般同胞选择符~"></a>一般同胞选择符~</h3><p>标签1 ~ 标签2<br>标签2必须跟（不一定紧跟）在其同胞标签1后面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h2 ~ a &#123;<span class="attr">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E4%B8%80%E8%88%AC%E5%90%8C%E8%83%9E%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<h3 id="通用选择符"><a href="#通用选择符" class="headerlink" title="通用选择符*"></a>通用选择符*</h3><p>通用选择符是*（常被称为星号选择符）是一个通配符，它匹配任何元素，下面这条规则会导致所有元素（的文本和边框）都变成绿色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* &#123;<span class="attr">color</span>: green;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E9%80%9A%E7%94%A8%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<p>如上图所示，直接匹配会将所有元素都变成绿色，不过大多数情况在使用*选择符时，会同时使用另一个选择符，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将p包含的所有元素的文本变成红色。*/</span></span><br><span class="line">p * &#123;<span class="attr">color</span>: red;&#125;</span><br><span class="line"><span class="comment">/*，任何是section 孙子元素，而非子元素的a 标签都会被选中。至于a的父元素是什么，没有关系。*/</span></span><br><span class="line">section * a &#123;font-size:<span class="number">1.3</span>em;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ID和类选择符"><a href="#ID和类选择符" class="headerlink" title="ID和类选择符"></a>ID和类选择符</h2><p>ID 和类为我们选择元素提供了另一套手段，利用它们可以不用考虑文档的层次结构。只要你在HTML 标记中为元素添加了id 和class 属性，就可以在CSS 选择符中使用<br>ID 和类名，直接选中文档中特定的区域。<br><strong>可以给id 和class 属性设定任何值，但不能以数字或特殊符号开头</strong></p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>类属性就是HTML 元素的class 属性，body 标签中包含的任何HTML 元素都可以添加这个属性。下面这段代码展示了HTML class 属性的用法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        /</span>*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        p &#123;font-family:helvetica, sans-serif; font-size:1.2em;&#125;</span></span><br><span class="line"><span class="regexp">        .specialtext &#123;font-style:italic;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1 class="specialtext"&gt;This is a heading with the &lt;span&gt;same class&lt;/</span>span&gt;</span><br><span class="line">            <span class="keyword">as</span> the second paragraph.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;This tag has no class.&lt;/</span>p&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"specialtext"</span>&gt; When a tag has a <span class="class"><span class="keyword">class</span> <span class="title">attribute</span>, <span class="title">you</span> <span class="title">can</span> <span class="title">target</span> <span class="title">it</span></span></span><br><span class="line"><span class="class">            &lt;<span class="title">span</span>&gt;<span class="title">regardless</span>&lt;/<span class="title">span</span>&gt; <span class="title">of</span> <span class="title">its</span> <span class="title">position</span> <span class="title">in</span> <span class="title">the</span> <span class="title">hierarchy</span>.&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下所示： <strong>两个段落中文本的字体都变成了Helvetica，而标题和第二个段落都有specialtext 类，所以都变成了斜体</strong></p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E7%B1%BB%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<ul>
<li><p>类选择符：<br>p {font-family:helvetica, sans-serif; font-size:1.2em;}<br>.specialtext {font-style:italic;}</p>
</li>
<li><p>标签带类选择符：<br>p {font-family:helvetica, sans-serif; font-size:1.2em;}<br>.specialtext {font-style:italic;}<br>p.specialtext {color:red;}</p>
</li>
<li><p>多类选择符：<br><code>&lt;p class=&quot;specialtext featured&quot;&gt;</code>Here the span tag <code>&lt;span&gt;</code>may or may not<code>&lt;/span&gt;</code>be styled.<code>&lt;/p&gt;</code><br>.specialtext.featured {font-size:120%;}</p>
</li>
</ul>
<h3 id="ID属性"><a href="#ID属性" class="headerlink" title="ID属性"></a>ID属性</h3><p>ID 与类的写法相似，而且表示ID 选择符的#（井号）的用法，也跟表示类选择符的.（句号）类似。<br>如果有一个段落像下面这样设定了ID 属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">"specialtext"</span>&gt;This is the special text.&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，相应的ID 选择符就是这样的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#specialtext &#123;CSS 样式声明&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么时候用ID，什么时候用类"><a href="#什么时候用ID，什么时候用类" class="headerlink" title="什么时候用ID，什么时候用类"></a>什么时候用ID，什么时候用类</h3><p><strong>什么时候用ID:</strong>ID的用途是在页面中唯一地标识一个元素，每个ID在页面中都只能用一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        #mainmenu a &#123;color:orange;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;nav id="mainmenu"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                &lt;li&gt;&lt;a href="#"&gt;Yin&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                &lt;li&gt;&lt;a href="#"&gt;Yang&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/u</span>l&gt;</span><br><span class="line">        &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里，页面中就不能再有其他元素使用mainmenu 作为ID 名了。为了标识页面的某一部分，比如主导航菜单，可以为nav（navigation，导航）添加一个ID 属性，并让它包含菜单元素。</p>
<h3 id="什么时候使用类"><a href="#什么时候使用类" class="headerlink" title="什么时候使用类"></a>什么时候使用类</h3><p>类的目的是为了标识具有相同特征的元素，示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"boy"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Alan<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="boy"&gt;&lt;a href="#"&gt;Andrew&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="girl"&gt;&lt;a href="#"&gt;Angela&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="boy"&gt;&lt;a href="#"&gt;Angus&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="girl"&gt;&lt;a href="#"&gt;Anne&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="girl"&gt;&lt;a href="#"&gt;Annette&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的列表中用类标记出了性别，然后再用CSS为链接应用颜色</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.boy a &#123;color:#6CF;&#125;/*蓝色*/</span><br><span class="line">.girl a &#123;color:#F9C;&#125;/*粉红色*/</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>ID 的用途是在页面标记中唯一地标识一个特定的元素。它能够为我们编写CSS 规则提供必要的上下文，排除无关的标记，而只选择该上下文中的标签。相对来说，类是可以应用给任意多个页面中的任意多个HTML 元素的公共标识符，以便我们为这些元素应用相同的CSS 样式。而且，使用类也让为不同标签名的元素应用相同的样式成为可能。</p>
<h2 id="属性选择符"><a href="#属性选择符" class="headerlink" title="属性选择符"></a>属性选择符</h2><p>标签名[属性名]<br>选择任何带有属性名的标签名<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img[title] &#123;<span class="attr">border</span>: <span class="number">2</span>px solid blue;&#125;</span><br></pre></td></tr></table></figure>

<p>带有title 属性的HTML img 元素显示2 像素宽的蓝色边框</p>
<h3 id="属性值选择符"><a href="#属性值选择符" class="headerlink" title="属性值选择符"></a>属性值选择符</h3><p>标签名[属性名=”属性值”]<br>选择带有值为属性值的属性名的标签名<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img[title=<span class="string">"red flower"</span>] &#123;<span class="attr">border</span>:<span class="number">4</span>px solid green;&#125;</span><br></pre></td></tr></table></figure>

<p>在图片的title 属性值为red flower 的情况下，才会为图片添加边框。</p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上。伪类分两种。<br>UI(User Interface, 用户界面)伪类会在HTML元素处于某个状态时(比如鼠标指针位于链接上)，为该元素应用CSS样式。<br>结构化伪类会在标记中存在某种结构上的关系时(如某个元素是一组元素中的第一个或最后一个)，为相应元素应用CSS样式。</p>
<h3 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h3><p>UI伪类会基于特定HTML元素的状态应用样式。最常使用UI伪类的元素是链接（a元素），利用UI伪类，链接可以在用户鼠标悬停时改变文本颜色，或者去掉文本的下划线。</p>
<ol>
<li><strong>链接伪类</strong>：针对链接的伪类一共有4个，因为链接始终会处于如下4种状态之一。</li>
</ol>
<ul>
<li>Link: 此时，链接就在那儿等着用户点击；</li>
<li>Visited: 用户此前点击过这个链接；</li>
<li>Hover: 鼠标指针正悬停在链接上。</li>
<li>Active：链接正在被点击（鼠标在元素上按下，还没有释放）。<br>以下是这些状态对应的4个伪类选择符（使用了a选择符和一些示例声明）：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a: link &#123;<span class="attr">color</span>: black;&#125;</span><br><span class="line">a: visited &#123;<span class="attr">color</span>: gray;&#125;</span><br><span class="line">a: hover &#123;text-decoration:none;&#125;</span><br><span class="line">a: active &#123;<span class="attr">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个冒号（:）表示伪类，两个冒号（::）表示CSS3 新增的伪元素。</strong><br>根据前面的声明，链接在初始状态时是黑色（默认带下划线）。当鼠标移到上面时（悬停状态），链接的下划线消失，颜色仍然是黑色。当用户在链接上按下鼠标时（活动状态），链接变成红色。而在链接被点击后，也就是鼠标在链接上按下，又在链接上释放后，会触发浏览器打开URL，此后（或者更准确地说，到浏览器访问历史中的这个URL 过期或被用户删除之前），链接会一直显示为灰色。<br>注意：有些伪类可以用于任何元素，而不仅仅是a元素，比如下面这条规则能让段落背景在鼠标悬停时变成灰色:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p:hover &#123;background-color:gray;&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>:focus伪类</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e:focus           #在这个以及后续的例子中，e 表示任何元素，如p、h1、section，等等</span><br></pre></td></tr></table></figure>

<p>表单中的文本字段在用户单击它时会获得焦点，然后用户才能在其中输入字符。下面的规则会在光标位于input 字段中时，为该字段添加一个蓝色边框。这样可以让用户明确<br>地知道输入的字符会出现在哪里。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input:focus &#123;<span class="attr">border</span>:<span class="number">1</span>px solid blue;&#125;</span><br></pre></td></tr></table></figure>

<p>3.<strong>target 伪类</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e:target</span><br></pre></td></tr></table></figure>

<p>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target 伪类选中它。<br>示例如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#more_info"</span>&gt;More Information&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;h2 id="more_info"&gt;This is the information you are looking for.&lt;/</span>h2&gt;</span><br><span class="line">#more_info:target &#123;background:#eee;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的指的是在用户单击链接转向ID 为more_info 的元素时，为该元素添加浅灰色背景。</p>
<h3 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h3><p>结构化伪类可以根据标记的结构应用样式，比如根据某元素的父元素或前面的同胞元素是什么。</p>
<ol>
<li>:first-child 和 :last-child</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e:first-child</span><br><span class="line">e:last-child</span><br></pre></td></tr></table></figure>

<p>:first-child 代表一组同胞元素中的第一个元素，而:last-child 则代表最后一个。<br>比如，，把下面的规则</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ol.results li:first-child &#123;<span class="attr">color</span>:blue;&#125;</span><br></pre></td></tr></table></figure>

<p>应用给以下标记：文本“My Fast Pony”就会变成蓝色。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol <span class="class"><span class="keyword">class</span></span>=<span class="string">"results"</span>&gt;</span><br><span class="line">    &lt;li&gt;My Fast Pony&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Steady Trotter&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Slow Ol<span class="string">' Nag&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ol&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果选择符改成这样：那变成红色的文本就是“Slow Ol’ Nag”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ol.results li:last-child &#123;<span class="attr">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>

<p>2 :nth-child</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e:nth-child(n)</span><br></pre></td></tr></table></figure>

<p>e 表示元素名，n 表示一个数值（也可以使用odd 或even）<br>例如：下面会选择一组列表项中的每个第三项。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">li:nth-child(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素就是文档中若有实无的元素。以下我们介绍几个最有用的伪元素</p>
<p>1 ::first-letter 伪元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e::first-letter</span><br></pre></td></tr></table></figure>

<p>比如应用下面的CSS规则，可以得到段落首字符放大的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p::first-letter &#123;font-size:<span class="number">300</span>%;&#125;</span><br></pre></td></tr></table></figure>

<p>2 ::first-line 伪元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e::first-line</span><br></pre></td></tr></table></figure>

<p>可以选中文本段落（一般情况下是段落）的第一行，如下所示：可以把第一行以小型大写字母显示</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p::first-line &#123;font-variant:small-caps;&#125;</span><br></pre></td></tr></table></figure>

<p>3 ::before 和::after 伪元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e::before</span><br><span class="line">e::after</span><br></pre></td></tr></table></figure>

<p>可用于在特定元素前面或后面添加特殊内容。<br>如下面的样式所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.age::before &#123;<span class="attr">content</span>:<span class="string">"Age: "</span>;&#125;</span><br><span class="line">p.age::after &#123;<span class="attr">content</span>:<span class="string">" years."</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>放入以下标记：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"age"</span>&gt;<span class="number">25</span>&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p>得到结果如下所示：<br>Age: 25 years.</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>CSS 中有很多属性是可以继承的，其中相当一部分都跟文本有关，比如颜色、字体、字号。然而，也有很多CSS 属性不能继承，因为继承这些属性没有意义。这些不能<br>继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距，这些下一章专门讲解</p>
<h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>层叠，就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。</p>
<h3 id="样式来源"><a href="#样式来源" class="headerlink" title="样式来源"></a>样式来源</h3><p>浏览器层叠各个来源样式的顺序：</p>
<ul>
<li>浏览器默认样式表</li>
<li>用户样式表</li>
<li>作者链接样式表(按照它们连接到页面的先后顺序)</li>
<li>作者嵌入样式</li>
<li>作者行内样式</li>
</ul>
<p>浏览器会按照上述顺序依次检查每个来源的样式，并在有定义的情况下，更新对每个标签属性值的设定。整个检查更新过程结束后，再将每个标签以最终设定的样式<br>显示出来。<br>给网页添加样式的三种方法：链接样式、 嵌入样式、 行内样式。</p>
<h3 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a>层叠规则</h3><p><strong>层叠规则一：找到应用给每个元素和属性的所有声明。</strong>。浏览器在加载每个页面时，都会据此查到每一条CSS 规则，标识出所有受到影响的HTML 元素。<br><strong>层叠规则二：按照顺序和权重排序。</strong>浏览器依次检查5个来源，并设定匹配的属性。如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环，直到检查<br>完页面中所有标签受影响属性的全部5 个来源为止。最终某个属性被设定成什么值，就用什么值来显示。<br><strong>层叠规则三：按特指度排序。</strong>特指度（specificity）其实表示一条规则有多明确。类名选择符比普通的标签选择符具有更高的特指度。一条规则的特指度，由它的选择符中包含多少个标签、类名和ID 决定。</p>
<p>计算特指度方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I - C - E</span><br><span class="line">三个字母间的短横线是分隔符，并非减号。针对这个公式的计分办法如下：</span><br><span class="line"><span class="number">1.</span> 选择符中有一个ID，就在I 的位置上加<span class="number">1</span>；</span><br><span class="line"><span class="number">2.</span> 选择符中有一个类，就在C 的位置上加<span class="number">1</span>；</span><br><span class="line"><span class="number">3.</span> 选择符中有一个元素（标签）名，就在E 的位置上加<span class="number">1</span>；</span><br><span class="line"><span class="number">4.</span> 得到一个三位数。</span><br></pre></td></tr></table></figure>

<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">P                               <span class="number">0</span><span class="number">-0</span><span class="number">-1</span> 特指度=<span class="number">1</span></span><br><span class="line">p.largetext                     <span class="number">0</span><span class="number">-1</span><span class="number">-1</span> 特指度=<span class="number">11</span></span><br><span class="line">p#largetext                     1-0-1 特指度=101</span><br><span class="line">body p#largetext                1-0-2 特指度=102</span><br><span class="line">body p#largetext ul.mylist      1-1-3 特指度=113</span><br><span class="line">body p#largetext ul.mylist li   1-1-4 特指度=114</span><br><span class="line"></span><br><span class="line">在此，每个选择符都比前一个选择符的特指度更高。</span><br></pre></td></tr></table></figure>

<p><strong>层叠规则四：顺序决定权重。</strong>如果两条规则都影响某元素的同一个属性，而且它们的特指度也相同，则位置最靠下（或后声明）的规则胜出。</p>
<h2 id="规则声明"><a href="#规则声明" class="headerlink" title="规则声明"></a>规则声明</h2><p>一个声明包含两部分：属性和值。属性指出要影响元素的哪个方面（颜色、高度，等等），而值表示把属性设定为什么（绿色、12px，等等）。<br>CSS 属性值主要分以下三类：<br><strong>文本值：</strong>例如，font-weight:bold 声明中的bold 就一个文本值。文本值也叫做关键字。<br><strong>数字值：</strong>数字值后面都有一个单位，例如英寸或点。在声明font-size:12px 中，12是数字值，而px 是单位（像素）。如果数字值为0，那么就不用带单位了。<br><strong>颜色值：</strong>颜色值可以用几种不同的格式来写，包括RGB（Red, Green, Blue，红绿蓝）、HSL（Hue, Saturation, Luminance，色相，饱和度，亮度）和十六进制值（例如<br>color:#336699）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/7/">7</a><span class="page-number current">8</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ning Ning</p>
  <div class="site-description" itemprop="description">光、温暖、温柔</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ning Ning</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  




  
<script src="/blog/js/local-search.js"></script>













  

  

</body>
</html>
