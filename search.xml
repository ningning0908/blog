<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DOM选择器</title>
    <url>/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/DOM%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><p>属性选择器是在CSS2中引入的，他们能够指定一些规则，这些规则根据元素的属性（诸如href或title）以及这些属性的值对元素进行匹配</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">lang</span>=<span class="string">"en-GB"</span> <span class="attr">rel</span>=<span class="string">"friend net"</span>&gt;</span>Peter<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;&lt;a href="" lang="es-ES" rel-"fiend"&gt;Pedro&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;&lt;a href="" lang="es-MX" rel-"contact"&gt;Pancho&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br></pre></td></tr></table></figure>

<h3 id="简单属性选择器"><a href="#简单属性选择器" class="headerlink" title="简单属性选择器"></a>简单属性选择器</h3><p>将规则应用到定义了指定属性的元素上，而不管属性的值是什么</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a[rel] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于所有元素都有rel属性，所以所有元素都会应用这条规则</p>
<h3 id="精确属性值选择器"><a href="#精确属性值选择器" class="headerlink" title="精确属性值选择器"></a>精确属性值选择器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a[rel=<span class="string">'friend'</span>] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码只会将规则标记到第二个a元素</p>
<h3 id="部分属性选择器"><a href="#部分属性选择器" class="headerlink" title="部分属性选择器"></a>部分属性选择器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a[rel~=<span class="string">'friend'</span>] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码会选择rel属性中带有friend的值的元素，则这个规则会标记到第一与第二个</p>
<h3 id="语言属性选择器"><a href="#语言属性选择器" class="headerlink" title="语言属性选择器"></a>语言属性选择器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a[lang|=<span class="string">'es'</span>] &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选中所有属性值以es开头的lang语言，即会选中2和3</p>
<h2 id="CSS3的新属性选择器"><a href="#CSS3的新属性选择器" class="headerlink" title="CSS3的新属性选择器"></a>CSS3的新属性选择器</h2><h3 id="开始字串属性值选择器（开始选择器）"><a href="#开始字串属性值选择器（开始选择器）" class="headerlink" title="开始字串属性值选择器（开始选择器）"></a>开始字串属性值选择器（开始选择器）</h3><p>该选择器会选择一些元素，这些元素所选择的属性是以一个字符串为起始，该字符串会作为参数提供给选择器，这个选择器使用插入符号(^)修饰属性中的等号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">E[attr^=<span class="string">'value'</span>] &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码将在指定属性的起始处寻找指定的值<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Lorem ipsum dolor &lt;a href=<span class="string">"mailto:email@example.com"</span>&gt;email&lt;a&gt; sit amet.&lt;<span class="regexp">/a&gt;&lt;/</span>p&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">a[href^=<span class="string">'mailto'</span>] &#123;</span><br><span class="line">    background-image: url(<span class="string">'email_go.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor email sit amet.  #这里的email是一个地址即上述href绑定的地址 email原为一图片索引，本人懒就没放图片</span><br></pre></td></tr></table></figure>

<h3 id="结束子串属性值选择器（结束选择器）"><a href="#结束子串属性值选择器（结束选择器）" class="headerlink" title="结束子串属性值选择器（结束选择器）"></a>结束子串属性值选择器（结束选择器）</h3><p>与开始选择器相反，使用该选择器去选择以指定的值结束的属性<br>语法差异为用($)去修饰(=)</p>
<h3 id="任意子串属性值选择器（任意选择器）"><a href="#任意子串属性值选择器（任意选择器）" class="headerlink" title="任意子串属性值选择器（任意选择器）"></a>任意子串属性值选择器（任意选择器）</h3><p>该选择器使用规则即在指定的属性字符串的内部任意位置搜索指定的子串<br>该选择器使用的符号是(*)</p>
<h3 id="多属性选择器"><a href="#多属性选择器" class="headerlink" title="多属性选择器"></a>多属性选择器</h3><p>可以把多个选择器串接在一起，这样在选择目标的时候能够做到非常的具体，使用多选择器，可以通过定义在开始、结束以及中间任意位置的值创建应用到属性上的规则</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://example.com/folder1/file.pdf"</span>&gt;</span>Lorem ipsum<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;&lt;a href="http:/</span><span class="regexp">/example.com/</span>folder2/file.pdf<span class="string">"&gt;Lorem ipsum&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<p> 如果要指定一条只应用到第二个p元素的规则，可以把一些选择器串接到一起：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a[href^=<span class="string">'http://'</span>][href*=<span class="string">'/folder2/'</span>][href$=<span class="string">'.pdf'</span>] &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码会寻找这样的a元素，它具有一个href属性，是以 http: // 开始，以.pdf结束，并且在中间包含了/folder2/，非常明确</p>
<h3 id="普通兄弟连结符"><a href="#普通兄弟连结符" class="headerlink" title="普通兄弟连结符"></a>普通兄弟连结符</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">E + F &#123;&#125; #相邻兄弟连结符</span><br><span class="line">E ~ F &#123;&#125; #普通兄弟连结符</span><br></pre></td></tr></table></figure>

<p>相邻兄弟连结符选择的是文档树的同一层级，紧邻在元素(E)之后的任意元素；<br>普通兄弟连结符选择的是文档树的同一层级，位于元素(E)之后的任意元素。<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Next we are going to discuss ... &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;h2&gt;Ren&amp;eacute; Descartes&lt;/</span>h2&gt;</span><br><span class="line">&lt;p&gt;A highly influential French philosopher...&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt;He only famously declared:&lt;/</span>p&gt;</span><br><span class="line">&lt;blockquote&gt;</span><br><span class="line">    &lt;p&gt;I think,therefore I am.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>blockquote&gt;  </span><br><span class="line">&lt;p&gt;However,<span class="keyword">this</span> presumes the existence <span class="keyword">of</span> the speaker.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">h2 + p &#123;</span></span><br><span class="line"><span class="regexp">    font-weight:bolder;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">h2 ~ p &#123;</span></span><br><span class="line"><span class="regexp">    font-style: italic;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标记与文档结构</title>
    <url>/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/HTML%E6%A0%87%E8%AE%B0%E4%B8%8E%E6%96%87%E6%A1%A3%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>CSS的用途就是为HTML标记添加样式，所以，我们首先要先知道怎么编写和构造HTML标记，才能让CSS更方便地为它添加样式。用HTML标记内容的目的是为了赋予网页语义，我们平常用的浏览器、给视障用户朗读网页的屏幕阅读器，以及搜索引擎放出的Web爬虫都是用户代理，它们需要显示、朗读和分析网页。HTML规定了一组标签，用来给内容打上不同的标记，每个标签都是对所包含内容的一种描述，最常用的HTML标签描述的是标题、段落、链接和图片。目前，HTML一共有114个标签，但按照80/20的原则，使用其中25个左右的标签就可以满足80%的标记需要。<br>在给内容都打上标记之后，就可以使用CSS来给标签添加样式了，添加样式的依据有标签名、标签属性（如id和class）、以及标签与其他标签在标记中的相对位置关系，等等。HTML标签也会构成一个层次化的文档，从而可以通过CSS来设置网页的布局，为每个元素应用你想要的样式。</p>
<h2 id="HTML标记基础"><a href="#HTML标记基础" class="headerlink" title="HTML标记基础"></a>HTML标记基础</h2><h3 id="文本用闭合标签格式如下"><a href="#文本用闭合标签格式如下" class="headerlink" title="文本用闭合标签格式如下"></a>文本用闭合标签格式如下</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标签名&gt;文本内容&lt;<span class="regexp">/标签名&gt;</span></span><br></pre></td></tr></table></figure>

<p>标题、段落等文本元素都要求闭合标签，也就是要有一个开标签和一个闭标签</p>
<h3 id="引用内容用自闭合标签格式如下"><a href="#引用内容用自闭合标签格式如下" class="headerlink" title="引用内容用自闭合标签格式如下"></a>引用内容用自闭合标签格式如下</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;标签名 属性_1=<span class="string">"属性值"</span> 属性_n=<span class="string">"属性值"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>非文本内容是通过自闭合标签显示的，比如图片等，闭合标签与自闭合标签的区别在于闭合标签包含的是会显示的实际内容，而自闭合标签只是给浏览器提供一个对要显示内容的引用。浏览器会在HTML页面加载的时候，额外想服务器发送请求，以取得自闭合标签引用的内容。下面就是使用自闭合标签标记的一张图片。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"images/cisco.jpg"</span> alt=<span class="string">"My dog Cisco"</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性负责为浏览器提供有关标签的额外信息，比如说，前面例子中的<code>&lt;img&gt;</code>标签有两个属性，一个属性是src(source，来源)，属性值是cisco.jpg，这个属性定义了图片的来源是一个名为cisco.jpg的文件，另一个属性是alt(alternative，替代内容)，定义的是在图片因故未能加载成功时在屏幕上显示的文本。</p>
<p><strong>视障用户使用的屏幕阅读器会大声读出alt属性的内容，因此一定要给<code>&lt;img&gt;</code>标签的这个alt属性添加让人一听（或一看）就能明白的内容。</strong></p>
<h3 id="标题与段落"><a href="#标题与段落" class="headerlink" title="标题与段落"></a>标题与段落</h3><p>一般来说，网页都会以一个<code>&lt;h1&gt;</code>标签开头，其中的文本用于告诉读者这个网页是干什么的，然后用<code>&lt;h2&gt;</code>标记下一级内容，或许是一个副标题，然后才是<code>&lt;h3&gt;</code>，以此类推。<br><code>&lt;h1&gt;</code>不仅是最大最突出的标题（除非你用CSS缩小它的字号），搜索引擎也会将其视为仅次于<code>&lt;title&gt;</code>标签的另一个搜索关键词的来源。<br>段落用于标记主要的文本内容，是所有文本元素中出场率最高的一个，简言之，只要有不适合放在其他文本标签中的文本，都可以把它放在一个段落里。</p>
<h3 id="复合元素"><a href="#复合元素" class="headerlink" title="复合元素"></a>复合元素</h3><p>HTML不仅规定了标题、图片和段落等基本的内容标记，还规定了用于创建列表、表格和表单等复杂用户界面组件的标记，这些就是所谓的复合元素，即它们是由多个标签共同完成的。比如，<code>&lt;li&gt;</code>是一个列表项，它只在<code>&lt;ol&gt;</code>(有序列表)和<code>&lt;ul&gt;</code>(无序列表)中才有效，在<code>&lt;dl&gt;</code>(定义列表)中则无效。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;Save HTML file&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Move file to Web server via FTP&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Preview <span class="keyword">in</span> browser&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>ol&gt;</span><br></pre></td></tr></table></figure>

<p>结果如下图所示：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/HTML%E5%A4%8D%E5%90%88%E5%85%83%E7%B4%A0.png" alt="attr"></p>
<h3 id="嵌套标签"><a href="#嵌套标签" class="headerlink" title="嵌套标签"></a>嵌套标签</h3><p>在上面的例子中，基于<code>&lt;li&gt;</code>标签与<code>&lt;ol&gt;</code>标签的嵌套关系，可以说<code>&lt;li&gt;</code>标签是<code>&lt;ol&gt;</code>标签的子标签（或子元素），或者说<code>&lt;ol&gt;</code>标签是<code>&lt;li&gt;</code>标签的夫标签（父元素）。<br>**注意：在一个标签里嵌套另一个标签必须先关闭后一个标签再关闭前一个标签，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;That car is &lt;em&gt;fast&lt;<span class="regexp">/em&gt;.&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<p>HTML文档的结构正是通过类似这样的标签嵌套，以及就此建立起来标签间的“父——子”关系形成的。</p>
<h2 id="HTML文档剖析"><a href="#HTML文档剖析" class="headerlink" title="HTML文档剖析"></a>HTML文档剖析</h2><h3 id="HTML模板"><a href="#HTML模板" class="headerlink" title="HTML模板"></a>HTML模板</h3><p>按照HTML5语法编写的最简单的HTML页面的模板可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;!-- 这里是网页内容--&gt;</span><br><span class="line">    &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>模板的第一行代码是一种新语法，或者说是一种简化的DOCTYPE，这一行就是为了声明： “以下是一个HTML文档。”<strong>这个标签不用关闭。</strong><br><code>&lt;html&gt;</code>标签是根级标签，页面中所有的其他标签都嵌套在这个标签内部，而且它的闭标签也是整个页面中的最后一个闭标签，<code>&lt;html&gt;</code>标签只有两个直接的子标签：<code>&lt;head&gt;</code>和<br><code>&lt;body&gt;</code>。<br>帮助浏览器理解页面的信息都包含在<code>&lt;head&gt;</code>标签中，在上面的例子中，<code>&lt;head&gt;</code>标签里只包含<code>&lt;meta&gt;</code>和<code>&lt;title&gt;</code>两个标签，其中<code>&lt;meta&gt;</code>标签中有一个charset属性，它是在告诉浏览器这个页面使用的是UTF-8编码，<code>&lt;title&gt;</code>标签的文本会在页面显示时，作为整个页面的标题出现在浏览器窗口顶部的标题栏中。<br><code>&lt;body&gt;</code>标签则包含着标记所有内容的HTML元素。</p>
<h3 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h3><p><strong>下面介绍一些块级标签和行内标签：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">块级标签</span><br><span class="line">&lt;h1&gt;-&lt;h6&gt;: 6级标签，&lt;h1&gt;表示最重要</span><br><span class="line">&lt;p&gt;: 段落</span><br><span class="line">&lt;lo&gt;: 有序列表</span><br><span class="line">&lt;li&gt;：列表项</span><br><span class="line">&lt;blockquote&gt;: 独立引用</span><br><span class="line">行内标签</span><br><span class="line">&lt;a&gt;：链接（anchor，锚）</span><br><span class="line">&lt;img&gt;: 图片</span><br><span class="line">&lt;em&gt;：斜体</span><br><span class="line">&lt;strong&gt;：重要</span><br><span class="line">&lt;abbr&gt;：简写</span><br><span class="line">&lt;cite&gt;: 引证</span><br><span class="line">&lt;q&gt;: 文本内引用</span><br></pre></td></tr></table></figure>

<p>几乎所有HTML元素的display属性值要么是block，要么是inline。最明显的一个例外是table元素，它有自己的display属性值。<br>块级元素（比如标题和段落）会相互堆叠在一起沿页面向下排列，每个元素分别占一行，而行内元素（比如链接和图片）则会相互并列，只有在空间不足以并列的情况下才会折到下一行显示。</p>
<p><strong>使用块级元素和行内元素构建页面：</strong> 示例如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span> /&gt;</span><br><span class="line">    &lt;title&gt;Block and Inline Elements&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Types <span class="keyword">of</span> Guitars&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;Guitars come in two main types: electric and acoustic.&lt;/</span>p&gt;</span><br><span class="line">    &lt;h2&gt;Acoustic Guitars&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;Acoustic guitars have a large hollow body that projects the sound of the strings.&lt;/</span>p&gt;</span><br><span class="line">    &lt;h3&gt;Nylon <span class="built_in">String</span> Acoustic Guitars&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;Descendants of the gut-strung instruments pf yore,nylon string guitars have a mellow tone.&lt;/</span>p&gt;</span><br><span class="line">    &lt;h2&gt;Electric Guitars&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img src="images/</span>acoustic_nylon.jpg<span class="string">" alt="</span>nylon string acoustic guitar<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">    &lt;p&gt;Electric guitars have a solid or hollow body with pickups that capture the string vibration so it can be amplified.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E4%BD%BF%E7%94%A8%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%92%8C%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%95%E9%A1%B5%E9%9D%A2.png" alt="attr"></p>
<h3 id="嵌套的元素"><a href="#嵌套的元素" class="headerlink" title="嵌套的元素"></a>嵌套的元素</h3><p>嵌套标记实际上就是嵌套盒子，在后面CSS盒模型重点介绍</p>
<h2 id="文档对象模型"><a href="#文档对象模型" class="headerlink" title="文档对象模型"></a>文档对象模型</h2><p>HTML结构所对应的文档对象模型（以下简称”DOM”）,DOM是从浏览器的视角观察页面中的元素以及每个元素的属性，由此得出这些元素的一个家族树，通过DOM可以确定元素之间的相互关系，在CSS中引用DOM中特定的位置，就可以选中响应的HTML元素，并修改其样式属性。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;section&gt;</span><br><span class="line">        &lt;h1&gt;The Document <span class="built_in">Object</span> Model&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;The page's HTMLmarkup structure defines the DOM.&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>

<p>对于这个例子中的DOM层次，我们可以做如下表述。</p>
<ul>
<li>section是h1和p的父元素，也是直接祖先元素；</li>
<li>h1和p是section的子元素，也是直接后代元素；</li>
<li>h1和p是同胞元素，它们有共同的父元素section;</li>
<li>section、h1和p是body的后代元素，或者下面的元素（嵌套在后者的内部）；</li>
<li>section和body是h1和p的祖先元素，或者上面的元素（在某一层次上包含后者）。</li>
</ul>
]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS工作原理</title>
    <url>/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/CSS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>每个HTML元素都有一组样式属性，可以通过CSS来设定。这些属性涉及元素在屏幕上显示时的不同方面，比如在屏幕上位置、边框的宽度，文本内容的字体、字号<br>和颜色，等等。CSS就是一种先选择HTML元素，然后设定选中元素CSS属性的机制。CSS选择符和要应用的样式构成了一条CSS 规则。</p>
<h2 id="剖析CSS规则"><a href="#剖析CSS规则" class="headerlink" title="剖析CSS规则"></a>剖析CSS规则</h2><p>规则实际上就是一条完整的CSS 指令。规则声明了要修改的元素和要应用给该元素的样式。下面就是一条CSS规则，它可以把段落的文本设置为红色。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p &#123;<span class="attr">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>

<p>把以上代码放到我们的HTML5模板中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        /</span>*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        p &#123;color: red;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;This text is very important!&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;body&gt;</code>元素中的<code>&lt;p&gt;</code>字段就会变成红色。<br><strong>为文档添加样式的三种方法：</strong><br>有三种方法可以把CSS添加到网页中，分别是写在元素标签里（也叫行内样式）、写在<code>&lt;style&gt;</code>标签里（也叫嵌入样式）和写在单独的CSS样式表中（也叫链接样式）。<br><strong>行内样式</strong><br>行内样式是写在特定HTML标签的style属性里的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This paragraph simply takes on the browser <span class="keyword">default</span> paragraph style.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p style="font-size: 12px; font-weight:bold; font-style:italic; color:red;"&gt;By</span></span><br><span class="line"><span class="regexp">adding inline CSS styling to this paragraph, you override the default styles.&lt;/</span>p&gt;</span><br></pre></td></tr></table></figure>

<p>行内样式的作用范围非常有限，行内样式只能影响它所在的标签，而且总会覆盖嵌入样式和链接样式。<br><strong>嵌入样式</strong><br>嵌入的CSS样式是放在HTML文档的head元素中的，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;!-- 其他head 元素（如meta、title）放在这里 --&gt;</span><br><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">h1 &#123;font-size:<span class="number">16</span>px;&#125;</span><br><span class="line">p &#123;<span class="attr">color</span>:blue;&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br></pre></td></tr></table></figure>

<p>嵌入样式的应用范围仅限于当前页面。页面样式会覆盖外部样式表中的样式，但会被行内样式覆盖。像本书前面例子中那样使用嵌入方式为某个组件（比如菜单）设计样式是很方便的，因为HTML 和CSS 同在一页，可以互相参照。但是，等到CSS 样式设计完毕，组件功能齐备之后，还是应该把相应的样式转移到外部样式表，以便其他页面也能共用相同的样式。<br><strong>链接样式</strong><br>在创建包含多个页面的网站时，需要把样式集中在一个单独的文件里，这个文件就叫样式表。样式表其实就是一个扩展名为.css 的文本文件。可以在任意多个HTML 页面中链接同一个样式表文件，每个页面中只需加入类似下面的这一行代码即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link href=<span class="string">"style.css"</span> rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>链接样式的作用范围可以是整个网站。只要使用<code>&lt;link&gt;</code>标签把样式表链接到每个页面，相应的页面就可以使用其中的样式。随后，只要修改了样式表中的样式，改动就会在所有被选中的元素上体现出来，无论这个元素在哪个页面里。这样，既可以做到全站页面外观统一，又便于整站样式更新。<br>除了以上三种为页面添加样式的方法，还有一种在样式表中链接其他样式表的方法，那就应用@import 指令（是一种at 规则）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(css/styles2.css)</span><br></pre></td></tr></table></figure>

<p><strong>要注意的是，@import 指令必须出现在样式表中其他样式之前，否则@import 引用的样式表不会被加载。</strong><br>有一点很重要，那就是CSS 样式是通过<code>&lt;style&gt;</code>标签嵌入到页面里的。当浏览器遇到开标签<code>&lt;style&gt;</code>时，就会由解释HTML 代码切换为解释CSS 代码。等遇到闭标签<br><code>&lt;/style&gt;</code>时，它会再切换回解释HTML 代码。<br>对于写在样式表里的样式，就不需要<code>&lt;style&gt;</code>标签了。如果你在样式表里加上这个标签，样式表中的样式就不会被浏览器加载了。</p>
<h3 id="CSS规则命名惯例"><a href="#CSS规则命名惯例" class="headerlink" title="CSS规则命名惯例"></a>CSS规则命名惯例</h3><p>CSS规则由选择符和声明两部分组成，其中选择符用于指出规则所要选择的元素，声明则又由两部分组成：属性和值，属性指出要影响哪方面的样式，值就是属性的一个新状态。如下图所示：<img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/CSS%E8%A7%84%E5%88%99.png" alt="attr"><br>对这个基本的结构，有三种方法可以进行扩展。<br><strong>第一种方法：多个声明包含在一条规则里。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p &#123;<span class="attr">color</span>:red; font-size:<span class="number">12</span>px; font-weight:bold;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种方法：多个选择符组合在一起。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">h1 &#123;<span class="attr">color</span>:blue; font-weight:bold;&#125;</span><br><span class="line">h2 &#123;<span class="attr">color</span>:blue; font-weight:bold;&#125;</span><br><span class="line">h3 &#123;<span class="attr">color</span>:blue; font-weight:bold;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三种方法：多条规则应用给一个选择符。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">h1, h2, h3 &#123;<span class="attr">color</span>:blue; font-weight:bold;&#125;</span><br><span class="line">h3 &#123;font-style:italic;&#125;</span><br></pre></td></tr></table></figure>

<p>所有用于选择特定元素的选择符又分三种。</p>
<ul>
<li>上下文选择符。基于祖先或同胞元素选择一个元素。</li>
<li>ID 和类选择符。基于id 和class 属性的值（你自己设定）选择元素。</li>
<li>属性选择符。基于属性的有无和特征选择元素。</li>
</ul>
<h2 id="上下文选择符"><a href="#上下文选择符" class="headerlink" title="上下文选择符"></a>上下文选择符</h2><p>像这种“基于位置”变换某个标签样式的问题，可以用上下文选择符来解决。<br>上下文选择符的格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">标签<span class="number">1</span> 标签<span class="number">2</span> &#123;声明&#125;</span><br></pre></td></tr></table></figure>

<p>其中，标签2就是我们想要选择目标，而且只有标签1是其祖先元素（不一定是父元素）的情况下才会被选中。<br>上下文选择符，也叫后代组合式选择符，就是一组以空格分隔的标签名，用于选择作为指定祖先元素后代的标签。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">article p &#123;font-weight: bold;&#125;</span><br></pre></td></tr></table></figure>

<p>上面这个例子的上下文选择符表明，只有是article后代的p元素才会应用后面的样式。</p>
<h2 id="特殊的上下文选择符"><a href="#特殊的上下文选择符" class="headerlink" title="特殊的上下文选择符"></a>特殊的上下文选择符</h2><p>上面介绍的上下文选择符是以某个祖先标签作为上下文，不过，有时候我们可能还会需要比“某些祖先”更加具体的上下文。比如说吧，要是你想根据父元素或者同胞元素的标签<br>名来选择元素怎么办呢？下面我们再用另一段标记来演示几种特殊的上下文选择符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;h2&gt;An H2 Heading&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;This is paragraph 1&lt;/</span>p&gt;</span><br><span class="line">    &lt;p&gt;Paragraph <span class="number">2</span> has &lt;a href=<span class="string">"#"</span>&gt;a link&lt;<span class="regexp">/a&gt; in it.&lt;/</span>p&gt;</span><br><span class="line">    &lt;a href=<span class="string">"#"</span>&gt;Link&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br></pre></td></tr></table></figure>

<h3 id="子选择符-gt"><a href="#子选择符-gt" class="headerlink" title="子选择符&gt;"></a>子选择符&gt;</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">标签<span class="number">1</span> &gt; 标签<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>标签2必须是标签1的子元素，或者反过来说，标签1必须是标签2的父元素，不能是其他祖先元素。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        /</span>*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        section &gt; h2 &#123;font-style:italic;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;section&gt;</span></span><br><span class="line"><span class="regexp">            &lt;h2&gt;An H2 Heading&lt;/</span>h2&gt;</span><br><span class="line">            &lt;p&gt;This is paragraph <span class="number">1</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;Paragraph 2 has &lt;a href="#"&gt;a link&lt;/</span>a&gt; <span class="keyword">in</span> it.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;a href="#"&gt;Link&lt;/</span>a&gt;</span><br><span class="line">        &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>展示效果如下所示：</p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%AD%90%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<h3 id="紧邻同胞选择符"><a href="#紧邻同胞选择符" class="headerlink" title="紧邻同胞选择符+"></a>紧邻同胞选择符+</h3><p>标签1 + 标签2<br>标签2必须紧跟在其同胞标签1的后面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">h2 + p &#123;font-variant:small-caps;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E7%B4%A7%E9%82%BB%E5%90%8C%E8%83%9E%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<h3 id="一般同胞选择符"><a href="#一般同胞选择符" class="headerlink" title="一般同胞选择符~"></a>一般同胞选择符~</h3><p>标签1 ~ 标签2<br>标签2必须跟（不一定紧跟）在其同胞标签1后面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">h2 ~ a &#123;<span class="attr">color</span>: red;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E4%B8%80%E8%88%AC%E5%90%8C%E8%83%9E%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<h3 id="通用选择符"><a href="#通用选择符" class="headerlink" title="通用选择符*"></a>通用选择符*</h3><p>通用选择符是*（常被称为星号选择符）是一个通配符，它匹配任何元素，下面这条规则会导致所有元素（的文本和边框）都变成绿色。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="attr">color</span>: green;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E9%80%9A%E7%94%A8%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<p>如上图所示，直接匹配会将所有元素都变成绿色，不过大多数情况在使用*选择符时，会同时使用另一个选择符，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*将p包含的所有元素的文本变成红色。*/</span></span><br><span class="line">p * &#123;<span class="attr">color</span>: red;&#125;</span><br><span class="line"><span class="comment">/*，任何是section 孙子元素，而非子元素的a 标签都会被选中。至于a的父元素是什么，没有关系。*/</span></span><br><span class="line">section * a &#123;font-size:<span class="number">1.3</span>em;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ID和类选择符"><a href="#ID和类选择符" class="headerlink" title="ID和类选择符"></a>ID和类选择符</h2><p>ID 和类为我们选择元素提供了另一套手段，利用它们可以不用考虑文档的层次结构。只要你在HTML 标记中为元素添加了id 和class 属性，就可以在CSS 选择符中使用<br>ID 和类名，直接选中文档中特定的区域。<br><strong>可以给id 和class 属性设定任何值，但不能以数字或特殊符号开头</strong></p>
<h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p>类属性就是HTML 元素的class 属性，body 标签中包含的任何HTML 元素都可以添加这个属性。下面这段代码展示了HTML class 属性的用法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        /</span>*CSS样式要嵌入在页面head元素中的&lt;style&gt;标签里*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        p &#123;font-family:helvetica, sans-serif; font-size:1.2em;&#125;</span></span><br><span class="line"><span class="regexp">        .specialtext &#123;font-style:italic;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h1 class="specialtext"&gt;This is a heading with the &lt;span&gt;same class&lt;/</span>span&gt;</span><br><span class="line">            <span class="keyword">as</span> the second paragraph.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;This tag has no class.&lt;/</span>p&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"specialtext"</span>&gt; When a tag has a <span class="class"><span class="keyword">class</span> <span class="title">attribute</span>, <span class="title">you</span> <span class="title">can</span> <span class="title">target</span> <span class="title">it</span></span></span><br><span class="line"><span class="class">            &lt;<span class="title">span</span>&gt;<span class="title">regardless</span>&lt;/<span class="title">span</span>&gt; <span class="title">of</span> <span class="title">its</span> <span class="title">position</span> <span class="title">in</span> <span class="title">the</span> <span class="title">hierarchy</span>.&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下所示： <strong>两个段落中文本的字体都变成了Helvetica，而标题和第二个段落都有specialtext 类，所以都变成了斜体</strong></p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E7%B1%BB%E9%80%89%E6%8B%A9%E7%AC%A6.png" alt="attr"></p>
<ul>
<li><p>类选择符：<br>p {font-family:helvetica, sans-serif; font-size:1.2em;}<br>.specialtext {font-style:italic;}</p>
</li>
<li><p>标签带类选择符：<br>p {font-family:helvetica, sans-serif; font-size:1.2em;}<br>.specialtext {font-style:italic;}<br>p.specialtext {color:red;}</p>
</li>
<li><p>多类选择符：<br><code>&lt;p class=&quot;specialtext featured&quot;&gt;</code>Here the span tag <code>&lt;span&gt;</code>may or may not<code>&lt;/span&gt;</code>be styled.<code>&lt;/p&gt;</code><br>.specialtext.featured {font-size:120%;}</p>
</li>
</ul>
<h3 id="ID属性"><a href="#ID属性" class="headerlink" title="ID属性"></a>ID属性</h3><p>ID 与类的写法相似，而且表示ID 选择符的#（井号）的用法，也跟表示类选择符的.（句号）类似。<br>如果有一个段落像下面这样设定了ID 属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p id=<span class="string">"specialtext"</span>&gt;This is the special text.&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么，相应的ID 选择符就是这样的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#specialtext &#123;CSS 样式声明&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么时候用ID，什么时候用类"><a href="#什么时候用ID，什么时候用类" class="headerlink" title="什么时候用ID，什么时候用类"></a>什么时候用ID，什么时候用类</h3><p><strong>什么时候用ID:</strong>ID的用途是在页面中唯一地标识一个元素，每个ID在页面中都只能用一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        #mainmenu a &#123;color:orange;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;nav id="mainmenu"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                &lt;li&gt;&lt;a href="#"&gt;Yin&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                &lt;li&gt;&lt;a href="#"&gt;Yang&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/u</span>l&gt;</span><br><span class="line">        &lt;<span class="regexp">/nav&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这里，页面中就不能再有其他元素使用mainmenu 作为ID 名了。为了标识页面的某一部分，比如主导航菜单，可以为nav（navigation，导航）添加一个ID 属性，并让它包含菜单元素。</p>
<h3 id="什么时候使用类"><a href="#什么时候使用类" class="headerlink" title="什么时候使用类"></a>什么时候使用类</h3><p>类的目的是为了标识具有相同特征的元素，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"boy"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>Alan<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="boy"&gt;&lt;a href="#"&gt;Andrew&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="girl"&gt;&lt;a href="#"&gt;Angela&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="boy"&gt;&lt;a href="#"&gt;Angus&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="girl"&gt;&lt;a href="#"&gt;Anne&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;li class="girl"&gt;&lt;a href="#"&gt;Annette&lt;/</span>a&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">&lt;<span class="regexp">/nav&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的列表中用类标记出了性别，然后再用CSS为链接应用颜色</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">.boy a &#123;color:#6CF;&#125;/*蓝色*/</span><br><span class="line">.girl a &#123;color:#F9C;&#125;/*粉红色*/</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong>ID 的用途是在页面标记中唯一地标识一个特定的元素。它能够为我们编写CSS 规则提供必要的上下文，排除无关的标记，而只选择该上下文中的标签。相对来说，类是可以应用给任意多个页面中的任意多个HTML 元素的公共标识符，以便我们为这些元素应用相同的CSS 样式。而且，使用类也让为不同标签名的元素应用相同的样式成为可能。</p>
<h2 id="属性选择符"><a href="#属性选择符" class="headerlink" title="属性选择符"></a>属性选择符</h2><p>标签名[属性名]<br>选择任何带有属性名的标签名<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">img[title] &#123;<span class="attr">border</span>: <span class="number">2</span>px solid blue;&#125;</span><br></pre></td></tr></table></figure>

<p>带有title 属性的HTML img 元素显示2 像素宽的蓝色边框</p>
<h3 id="属性值选择符"><a href="#属性值选择符" class="headerlink" title="属性值选择符"></a>属性值选择符</h3><p>标签名[属性名=”属性值”]<br>选择带有值为属性值的属性名的标签名<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">img[title=<span class="string">"red flower"</span>] &#123;<span class="attr">border</span>:<span class="number">4</span>px solid green;&#125;</span><br></pre></td></tr></table></figure>

<p>在图片的title 属性值为red flower 的情况下，才会为图片添加边框。</p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上。伪类分两种。<br>UI(User Interface, 用户界面)伪类会在HTML元素处于某个状态时(比如鼠标指针位于链接上)，为该元素应用CSS样式。<br>结构化伪类会在标记中存在某种结构上的关系时(如某个元素是一组元素中的第一个或最后一个)，为相应元素应用CSS样式。</p>
<h3 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h3><p>UI伪类会基于特定HTML元素的状态应用样式。最常使用UI伪类的元素是链接（a元素），利用UI伪类，链接可以在用户鼠标悬停时改变文本颜色，或者去掉文本的下划线。</p>
<ol>
<li><strong>链接伪类</strong>：针对链接的伪类一共有4个，因为链接始终会处于如下4种状态之一。</li>
</ol>
<ul>
<li>Link: 此时，链接就在那儿等着用户点击；</li>
<li>Visited: 用户此前点击过这个链接；</li>
<li>Hover: 鼠标指针正悬停在链接上。</li>
<li>Active：链接正在被点击（鼠标在元素上按下，还没有释放）。<br>以下是这些状态对应的4个伪类选择符（使用了a选择符和一些示例声明）：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a: link &#123;<span class="attr">color</span>: black;&#125;</span><br><span class="line">a: visited &#123;<span class="attr">color</span>: gray;&#125;</span><br><span class="line">a: hover &#123;text-decoration:none;&#125;</span><br><span class="line">a: active &#123;<span class="attr">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一个冒号（:）表示伪类，两个冒号（::）表示CSS3 新增的伪元素。</strong><br>根据前面的声明，链接在初始状态时是黑色（默认带下划线）。当鼠标移到上面时（悬停状态），链接的下划线消失，颜色仍然是黑色。当用户在链接上按下鼠标时（活动状态），链接变成红色。而在链接被点击后，也就是鼠标在链接上按下，又在链接上释放后，会触发浏览器打开URL，此后（或者更准确地说，到浏览器访问历史中的这个URL 过期或被用户删除之前），链接会一直显示为灰色。<br>注意：有些伪类可以用于任何元素，而不仅仅是a元素，比如下面这条规则能让段落背景在鼠标悬停时变成灰色:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p:hover &#123;background-color:gray;&#125;</span><br></pre></td></tr></table></figure>

<p>2.<strong>:focus伪类</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">e:focus           #在这个以及后续的例子中，e 表示任何元素，如p、h1、section，等等</span><br></pre></td></tr></table></figure>

<p>表单中的文本字段在用户单击它时会获得焦点，然后用户才能在其中输入字符。下面的规则会在光标位于input 字段中时，为该字段添加一个蓝色边框。这样可以让用户明确<br>地知道输入的字符会出现在哪里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">input:focus &#123;<span class="attr">border</span>:<span class="number">1</span>px solid blue;&#125;</span><br></pre></td></tr></table></figure>

<p>3.<strong>target 伪类</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e:target</span><br></pre></td></tr></table></figure>

<p>如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标（target），可以用:target 伪类选中它。<br>示例如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#more_info"</span>&gt;More Information&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">&lt;h2 id="more_info"&gt;This is the information you are looking for.&lt;/</span>h2&gt;</span><br><span class="line">#more_info:target &#123;background:#eee;&#125;</span><br></pre></td></tr></table></figure>

<p>上面的指的是在用户单击链接转向ID 为more_info 的元素时，为该元素添加浅灰色背景。</p>
<h3 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h3><p>结构化伪类可以根据标记的结构应用样式，比如根据某元素的父元素或前面的同胞元素是什么。</p>
<ol>
<li>:first-child 和 :last-child</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e:first-child</span><br><span class="line">e:last-child</span><br></pre></td></tr></table></figure>

<p>:first-child 代表一组同胞元素中的第一个元素，而:last-child 则代表最后一个。<br>比如，，把下面的规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ol.results li:first-child &#123;<span class="attr">color</span>:blue;&#125;</span><br></pre></td></tr></table></figure>

<p>应用给以下标记：文本“My Fast Pony”就会变成蓝色。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;ol <span class="class"><span class="keyword">class</span></span>=<span class="string">"results"</span>&gt;</span><br><span class="line">    &lt;li&gt;My Fast Pony&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;Steady Trotter&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;Slow Ol<span class="string">' Nag&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ol&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果选择符改成这样：那变成红色的文本就是“Slow Ol’ Nag”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ol.results li:last-child &#123;<span class="attr">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>

<p>2 :nth-child</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e:nth-child(n)</span><br></pre></td></tr></table></figure>

<p>e 表示元素名，n 表示一个数值（也可以使用odd 或even）<br>例如：下面会选择一组列表项中的每个第三项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">li:nth-child(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素就是文档中若有实无的元素。以下我们介绍几个最有用的伪元素</p>
<p>1 ::first-letter 伪元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e::first-letter</span><br></pre></td></tr></table></figure>

<p>比如应用下面的CSS规则，可以得到段落首字符放大的效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p::first-letter &#123;font-size:<span class="number">300</span>%;&#125;</span><br></pre></td></tr></table></figure>

<p>2 ::first-line 伪元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e::first-line</span><br></pre></td></tr></table></figure>

<p>可以选中文本段落（一般情况下是段落）的第一行，如下所示：可以把第一行以小型大写字母显示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p::first-line &#123;font-variant:small-caps;&#125;</span><br></pre></td></tr></table></figure>

<p>3 ::before 和::after 伪元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e::before</span><br><span class="line">e::after</span><br></pre></td></tr></table></figure>

<p>可用于在特定元素前面或后面添加特殊内容。<br>如下面的样式所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.age::before &#123;<span class="attr">content</span>:<span class="string">"Age: "</span>;&#125;</span><br><span class="line">p.age::after &#123;<span class="attr">content</span>:<span class="string">" years."</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>放入以下标记：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"age"</span>&gt;<span class="number">25</span>&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure>

<p>得到结果如下所示：<br>Age: 25 years.</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>CSS 中有很多属性是可以继承的，其中相当一部分都跟文本有关，比如颜色、字体、字号。然而，也有很多CSS 属性不能继承，因为继承这些属性没有意义。这些不能<br>继承的属性主要涉及元素盒子的定位和显示方式，比如边框、外边距、内边距，这些下一章专门讲解</p>
<h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>层叠，就是层叠样式表中的层叠，是一种样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值的多个来源，确定最终使用哪个值。</p>
<h3 id="样式来源"><a href="#样式来源" class="headerlink" title="样式来源"></a>样式来源</h3><p>浏览器层叠各个来源样式的顺序：</p>
<ul>
<li>浏览器默认样式表</li>
<li>用户样式表</li>
<li>作者链接样式表(按照它们连接到页面的先后顺序)</li>
<li>作者嵌入样式</li>
<li>作者行内样式</li>
</ul>
<p>浏览器会按照上述顺序依次检查每个来源的样式，并在有定义的情况下，更新对每个标签属性值的设定。整个检查更新过程结束后，再将每个标签以最终设定的样式<br>显示出来。<br>给网页添加样式的三种方法：链接样式、 嵌入样式、 行内样式。</p>
<h3 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a>层叠规则</h3><p><strong>层叠规则一：找到应用给每个元素和属性的所有声明。</strong>。浏览器在加载每个页面时，都会据此查到每一条CSS 规则，标识出所有受到影响的HTML 元素。<br><strong>层叠规则二：按照顺序和权重排序。</strong>浏览器依次检查5个来源，并设定匹配的属性。如果匹配的属性在下一个来源也有定义，则更新该属性的值，如此循环，直到检查<br>完页面中所有标签受影响属性的全部5 个来源为止。最终某个属性被设定成什么值，就用什么值来显示。<br><strong>层叠规则三：按特指度排序。</strong>特指度（specificity）其实表示一条规则有多明确。类名选择符比普通的标签选择符具有更高的特指度。一条规则的特指度，由它的选择符中包含多少个标签、类名和ID 决定。</p>
<p>计算特指度方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">I - C - E</span><br><span class="line">三个字母间的短横线是分隔符，并非减号。针对这个公式的计分办法如下：</span><br><span class="line"><span class="number">1.</span> 选择符中有一个ID，就在I 的位置上加<span class="number">1</span>；</span><br><span class="line"><span class="number">2.</span> 选择符中有一个类，就在C 的位置上加<span class="number">1</span>；</span><br><span class="line"><span class="number">3.</span> 选择符中有一个元素（标签）名，就在E 的位置上加<span class="number">1</span>；</span><br><span class="line"><span class="number">4.</span> 得到一个三位数。</span><br></pre></td></tr></table></figure>

<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">P                               <span class="number">0</span><span class="number">-0</span><span class="number">-1</span> 特指度=<span class="number">1</span></span><br><span class="line">p.largetext                     <span class="number">0</span><span class="number">-1</span><span class="number">-1</span> 特指度=<span class="number">11</span></span><br><span class="line">p#largetext                     1-0-1 特指度=101</span><br><span class="line">body p#largetext                1-0-2 特指度=102</span><br><span class="line">body p#largetext ul.mylist      1-1-3 特指度=113</span><br><span class="line">body p#largetext ul.mylist li   1-1-4 特指度=114</span><br><span class="line"></span><br><span class="line">在此，每个选择符都比前一个选择符的特指度更高。</span><br></pre></td></tr></table></figure>

<p><strong>层叠规则四：顺序决定权重。</strong>如果两条规则都影响某元素的同一个属性，而且它们的特指度也相同，则位置最靠下（或后声明）的规则胜出。</p>
<h2 id="规则声明"><a href="#规则声明" class="headerlink" title="规则声明"></a>规则声明</h2><p>一个声明包含两部分：属性和值。属性指出要影响元素的哪个方面（颜色、高度，等等），而值表示把属性设定为什么（绿色、12px，等等）。<br>CSS 属性值主要分以下三类：<br><strong>文本值：</strong>例如，font-weight:bold 声明中的bold 就一个文本值。文本值也叫做关键字。<br><strong>数字值：</strong>数字值后面都有一个单位，例如英寸或点。在声明font-size:12px 中，12是数字值，而px 是单位（像素）。如果数字值为0，那么就不用带单位了。<br><strong>颜色值：</strong>颜色值可以用几种不同的格式来写，包括RGB（Red, Green, Blue，红绿蓝）、HSL（Hue, Saturation, Luminance，色相，饱和度，亮度）和十六进制值（例如<br>color:#336699）。</p>
]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>盒模型</title>
    <url>/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="理解盒模型"><a href="#理解盒模型" class="headerlink" title="理解盒模型"></a>理解盒模型</h2><p>元素盒子的属性分为以下三类：</p>
<ul>
<li>边框： 可以设置边框的宽窄、样式和颜色；</li>
<li>内边距：可以设置盒子内容区与边框的间距；</li>
<li>外边距：可以设置盒子与相邻元素的间距。</li>
</ul>
<p>如下面的这个盒模型示意图所示，展示了HTML 元素的边框、内边距和外边距之间的关系<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E7%9B%92%E6%A8%A1%E5%9E%8B.png" alt="attr"></p>
<p>外边距是边框向外推其他元素，而内边距是从边框向内推元素的内容，一个盒子有4条边，因此与边框、内边距和外边距相关的属性也各有4个，分别是上（top）、右（right）、下（bottom）、左（left）。<br><strong>CSS提供了简写样式</strong><br>CSS为边框、内边距和外边距分别规定了简写属性，可以通过一条声明就可以完成设定，在每个简写声明中，属性值的顺序都是上、右、下、左（顺时针旋转顺序）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">不使用简写属性</span><br><span class="line">&#123;</span><br><span class="line">    margin-top:<span class="number">5</span>px;</span><br><span class="line">    margin-right:<span class="number">10</span>px;</span><br><span class="line">    margin-bottom:<span class="number">12</span>px;</span><br><span class="line">    margin-left:<span class="number">8</span>px;</span><br><span class="line">&#125;</span><br><span class="line">使用简写属性</span><br><span class="line">&#123;</span><br><span class="line">    margin:<span class="number">5</span>px <span class="number">10</span>px <span class="number">12</span>px <span class="number">8</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：4个值之间有空格，但不能是其他分隔符（比如逗号之类的），甚至不用把4值都写出来，如果哪个值没有写，就使用对边的值。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    margin:12px 10px 6px;     #最后一个值没有写就会使用对边的值即10px</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    margin:12px;         #4个边都取这个值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个盒子的属性也分三种粒度，到底选择哪个粒度的属性，要看你想选择哪条边，以及那条边的哪个属性，这三种粒度从一般到特殊分别是举例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 全部三个属性，全部<span class="number">4</span>条边</span><br><span class="line">&#123;</span><br><span class="line">    border:<span class="number">2</span>px dashed red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> <span class="number">1</span>个属性，全部<span class="number">4</span>条边</span><br><span class="line">&#123;</span><br><span class="line">    border-style:dashed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span> <span class="number">1</span>个属性，<span class="number">1</span>条边</span><br><span class="line">&#123;</span><br><span class="line">    border-left-style:dashed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>混合使用这三种粒度的简写属性达成设计目标是很常见的，。比如说吧，我想为盒子的上边和下边添加4 像素宽的红色边框，为左边添加1 像素宽的红色边框，而右边没有边框。可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">border</span>:<span class="number">4</span>px solid red;&#125; <span class="comment">/* 先给4 条边设置相同的样式 */</span></span><br><span class="line">&#123;border-left-width:<span class="number">1</span>px;&#125; <span class="comment">/* 修改左边框宽度 */</span></span><br><span class="line">&#123;border-right:none;&#125; <span class="comment">/* 移除右边框 */</span></span><br></pre></td></tr></table></figure>

<h3 id="盒子边框"><a href="#盒子边框" class="headerlink" title="盒子边框"></a>盒子边框</h3><p>边框有3个相关属性</p>
<ul>
<li>宽度(border-width)：可以使用thin、medium和thick等文本值，也可以使用除百分比和负值之外的任何绝对值；</li>
<li>样式(border-style): 有none、hidden、dotted、dashed、solid、double、groove、ridge、inset 和outset 等文本值。</li>
<li>颜色(border-color): 可以使用任意颜色值，包括RGB、HSL、十六进制颜色值和颜色关键字。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">p.warning &#123;border:solid #f33;&#125;                #所有带有warning类的段落都会带有一个4像素宽的红色实心边框</span><br><span class="line">p.warning &#123;border-width:4px 1px 1px 4px;&#125;     #修改边框宽度</span><br></pre></td></tr></table></figure>

<h3 id="盒子内边距-padding"><a href="#盒子内边距-padding" class="headerlink" title="盒子内边距(padding)"></a>盒子内边距(padding)</h3><p>内边距是盒子内容区与盒子边框之间的距离。同样遵从简写样式，依据上、右、下、左的顺序。</p>
<h3 id="盒子外边距-margin"><a href="#盒子外边距-margin" class="headerlink" title="盒子外边距(margin)"></a>盒子外边距(margin)</h3><p>推荐使用下面的这条规则作为样式表的第一条规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">* &#123;<span class="attr">margin</span>:<span class="number">0</span>; padding:<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>根据不同需要修改外边距与内边距。</p>
<h3 id="叠加外边距"><a href="#叠加外边距" class="headerlink" title="叠加外边距"></a>叠加外边距</h3><p>垂直方向上的边距会叠加，但是像下例这样上下边距相遇时，他们就会相互叠加，直到一个外边距碰到另一个元素的边框。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*为简明起见，省略了字体声明*/</span></span><br><span class="line">p &#123;height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px;</span><br><span class="line">margin-bottom:<span class="number">30</span>px;&#125;</span><br></pre></td></tr></table></figure>

<p>上例中的第一段的下外边距与第二段的上外边距之间的外边距是50像素，不是（50+30），因为外边距叠加。<strong>较宽的外边距决定两个元素最终离多远</strong></p>
<h3 id="外边距的单位"><a href="#外边距的单位" class="headerlink" title="外边距的单位"></a>外边距的单位</h3><p>根据经验，为文本元素设置外边距时通常需要混合使用不同的单位。比如说，一个段落的左、右外边距可以使用像素，以便该段文本始终与包含元素边界保持固定间<br>距，不受字号变大或变小的影响。而对于上、下外边距，以em 为单位则可以让段间距随字号变化而相应增大或缩小，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*这里使用了简写属性把上、下外边距设置为.75em，把左、右外边距设置为30 像素*/</span></span><br><span class="line">p &#123;font-size:<span class="number">1</span>em; margin:<span class="number">.75</span>em <span class="number">30</span>px;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浮动与清除"><a href="#浮动与清除" class="headerlink" title="浮动与清除"></a>浮动与清除</h2><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p>CSS 设计float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属性居然也成了创建多栏布局最简单的方式。</p>
<ol>
<li><strong>文本绕排图片：为了实现文本绕排图片的浮动效果，必须在标记中先写图片，然后再写环绕它的文本。</strong><br>示例如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">       /</span>*为简明起见，省略了字体声明*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        p &#123;margin:0; border:1px solid red;&#125;</span></span><br><span class="line"><span class="regexp">        /</span>*外边距防止图片紧挨文本*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">        img &#123;float:left; margin:0 4px 4px 0;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;img src="images/</span>acoustic_nylon1.jpg<span class="string">" alt="</span>nylon string acoustic guitar<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;Do you know，guitar?I very like guitar!It's my favorite a kind of instrument! If you don't know guitar,piease read this article.I believe the article will be very helpful to you!</span></span><br><span class="line"><span class="string">        The guitar is used for various musical style, it in the pop music, rock music, r&amp;b, folk music, Buddha brother Ming is regarded as the main instrument. There are also in the guitar classical music, there have been a lot of solo, selects a use of and orchestra. It usually have six strings, but there are four strings, eight and ten strings, ten strings ErXian. There are two main categories: guitar ShiYou history, a wooden sound box with the timber guitar, 8031 ErShiEr 10th century were invented, electric guitars 8031. Loudspeakers Timber guitar is usually used to classical music, folk music and popular music. Guitars are often used to, rock music, blues and pop music. The invention of receiving of western pop culture and music had important influence.</span></span><br><span class="line"><span class="string">        Now,do you learn guitar and love it?&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果如下所示：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/acoustic_nylon1.png" alt="attr"></p>
<p><strong>浮动非图片元素时，必须给它设定宽度，否则后果难以预料。图片无所谓，因为它本身有默认的宽度。</strong></p>
<p>2.<strong>创建分栏</strong><br>在此基础上创建多栏，只要再用一次float 属性，如下图所示，只要给段落设定宽度，然后也浮动它即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p &#123;<span class="attr">float</span>:left; margin:<span class="number">0</span>; width:<span class="number">300</span>px; border:<span class="number">1</span>px solid red;&#125;</span><br><span class="line">img &#123;<span class="attr">float</span>:left; margin:<span class="number">0</span> <span class="number">4</span>px <span class="number">4</span>px <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/acoustic_nylon2.png" alt="attr"></p>
<h3 id="围住浮动元素的三种方法"><a href="#围住浮动元素的三种方法" class="headerlink" title="围住浮动元素的三种方法"></a>围住浮动元素的三种方法</h3><p>如果出现下面的这种情况应该怎么办？<strong>底部的标题跑到右边去了</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">section &#123;<span class="attr">border</span>:<span class="number">1</span>px solid blue; margin:<span class="number">0</span> <span class="number">0</span> <span class="number">10</span>px <span class="number">0</span>;&#125;</span><br><span class="line">img &#123;<span class="attr">float</span>:left;&#125;</span><br><span class="line">footer &#123;<span class="attr">border</span>:<span class="number">1</span>px solid red;&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/float1.png" alt="attr"></p>
<p><strong>方法一：为父元素添加overflow:hidden，以强制它包围浮动元素。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">section &#123;<span class="attr">border</span>:<span class="number">1</span>px solid blue; margin:<span class="number">0</span> <span class="number">0</span> <span class="number">10</span>px <span class="number">0</span>; overflow:hidden;&#125;</span><br><span class="line">img &#123;<span class="attr">float</span>:left;&#125;</span><br><span class="line">p &#123;<span class="attr">border</span>:<span class="number">1</span>px solid red;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二：同时浮动父元素。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">section &#123;<span class="attr">border</span>:<span class="number">1</span>px solid blue; float:left; width:<span class="number">100</span>%;&#125;</span><br><span class="line">img &#123;<span class="attr">float</span>:left;&#125;</span><br><span class="line">footer &#123;<span class="attr">border</span>:<span class="number">1</span>px solid red; clear:left;&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意：由于section浮动了，所有为了强制footer依然呆在section 下方，要给它应用clear:left。</p>
<p><strong>方法三：添加非浮动的清除元素。</strong><br>强制父元素包含其浮动子元素的方法，就是给父元素的最后添加一个非浮动的子元素，然后清除该子元素。由于包含元素一定会包围非浮动的子元素，而且清除会让这个子元素位于（清除一侧）浮动元素的下方，因此包含元素一定会包含这个子元素——以及前面的浮动元素。在包含元素最后添加子元素作为清除元素的方式有两种。<br><strong>第一种如下所示：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>/&gt;</span><br><span class="line">    &lt;title&gt;An HTML Template&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        section &#123;border:1px solid blue;&#125;</span></span><br><span class="line"><span class="regexp">        img &#123;float:left;&#125;</span></span><br><span class="line"><span class="regexp">        .clear_me &#123;clear:left;&#125;</span></span><br><span class="line"><span class="regexp">        footer &#123;border:1px solid red;&#125;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;section&gt;</span></span><br><span class="line"><span class="regexp">            &lt;img src="images/</span>acoustic_nylon1.jpg<span class="string">" alt="</span>nylon string acoustic guitar<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;It is fun to float.&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;div class="</span>clear_me<span class="string">"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/section&gt;</span></span><br><span class="line"><span class="string">        &lt;footer&gt; Here is the footer element…&lt;/footer&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>第二种如下所示：</strong> 用CSS 来添加这个清除元素的方法，添加clearfix类</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#html 部分</span><br><span class="line">&lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"clearfix"</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"images/rubber_duck.jpg"</span>&gt;</span><br><span class="line">    &lt;p&gt;It is fun to float.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>section&gt;</span><br><span class="line">&lt;footer&gt; Here is the footer element…&lt;<span class="regexp">/footer&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">## CSS样式</span></span><br><span class="line"><span class="regexp">.clearfix:after &#123;</span></span><br><span class="line"><span class="regexp">content:".";</span></span><br><span class="line"><span class="regexp">display:block;</span></span><br><span class="line"><span class="regexp">height:0;</span></span><br><span class="line"><span class="regexp">visibility:hidden;</span></span><br><span class="line"><span class="regexp">clear:both;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>使用clear:both 意味着section 中新增的子元素会清除左、右浮动元素（位于左、右浮动元素下方）。这里当然可以只用left，但both 也适用于将来图片float:right 的情况。</strong></p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>CSS 布局的核心是position 属性，对元素盒子应用这个属性，可以相对于它在常规文档流中的位置重新定位。position 属性有4 个值：static(静态定位)、relative(相对定位)、absolute(绝对定位)、fixed(固定定位)，默认值为static。<br>从完全移出文档流的角度说，固定定位与绝对定位类似。<strong>但不同之处在于，固定定位元素的定位上下文是视口（浏览器窗口或手持设备的屏幕），因此它不会随页面滚动而移动</strong></p>
<h2 id="定位上下文"><a href="#定位上下文" class="headerlink" title="定位上下文"></a>定位上下文</h2><p>把元素的position 属性设定为relative、absolute 或fixed 后，继而可以使用top、right、bottom 和left 属性，相对于另一个元素移动该元素的位置。这里的“另一个元素”，就是该元素的定位上下文。<br>示例代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"outer"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"inner"</span>&gt;This is text…&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">#搭配下面的CSS</span></span><br><span class="line"><span class="regexp">div#outer &#123;width:250px; margin:50px 40px; border-top:3px solid red;&#125;</span></span><br><span class="line"><span class="regexp">div#inner &#123;position:absolute; top:10px; left:20px; background:#ccc;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="显示属性"><a href="#显示属性" class="headerlink" title="显示属性"></a>显示属性</h2><p>正如所有元素都有position 属性，所有元素也都有display 属性。尽管display 属性的值有很多，但大多数元素display 属性的默认值不是block，就是inline</p>
<ul>
<li>块级元素，比如段落、标题、列表等，在浏览器中上下堆叠显示。</li>
<li>行内元素，比如a、span 和img，在浏览器中左右并排显示，只有前一行没有空间时才会显示到下一行。</li>
</ul>
<p>把块级元素变成行内元素（或者相反）的魔法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*默认为block*/</span></span><br><span class="line">p &#123;<span class="attr">display</span>:inline;&#125;</span><br><span class="line"><span class="comment">/*默认为inline*/</span></span><br><span class="line">a &#123;<span class="attr">display</span>:block;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>CSS中每个元素盒子都可以想象成由两个图层组成，元素的前景层包含内容（如文本或图片）和边框，元素的背景层可以用实色填充（使用background-color属性），也可以包含任意多个背景图片（使用background-image 属性），背景图片叠加在背景颜色之上</p>
<h3 id="CSS背景属性"><a href="#CSS背景属性" class="headerlink" title="CSS背景属性"></a>CSS背景属性</h3><p>CSS规定以下与背景相关属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">background-color</span><br><span class="line">background-image</span><br><span class="line">background-repeat</span><br><span class="line">background-position</span><br><span class="line">background-size</span><br><span class="line">background-attachment</span><br><span class="line">background(简写属性)</span><br><span class="line">background-clip、background-origin、background-<span class="keyword">break</span>（目前尚未得到广泛支持）</span><br></pre></td></tr></table></figure>

<p><strong>背景颜色：</strong>background-color 是背景属性中最简单的，通过它可以设定元素的颜色。然后，元素就会以设定的颜色填充背景图层。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body &#123;background-color:#caebff;&#125;</span><br><span class="line">p &#123;<span class="comment">/*盒子布局样式*/</span></span><br><span class="line">    font-family:helvetica, arial, sans-serif; font-size:<span class="number">18</span>px;</span><br><span class="line">    width:<span class="number">350</span>px; margin:<span class="number">20</span>px auto; padding:<span class="number">10</span>px;</span><br><span class="line">    <span class="comment">/*这个例子中讨论背景和前景样式*/</span></span><br><span class="line">    background-color:#fff; color:#666; border:4px solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中body 的background-color 是蓝绿色，段落的background-color是白色，前景色color是灰色，前景色既影响文本，也影响边框。</p>
<p><strong>背景图片</strong>默认情况下背景图片会以元素左上角为起点，沿水平和垂直方向重复出现，最终填满整个背景区域，背景图片来源方式如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">background-image:url(图片路径/图片文件名)</span><br></pre></td></tr></table></figure>

<p><strong>要改变默认的水平和垂直重复效果，可以修改background-repeat 属性；要改变背景图片的起点，可以修改background-position 属性。</strong></p>
<p><strong>背景重复：</strong>控制背景重复方式的background-repeat属性有4个值。默认值就是repeat，效果就是水平和垂直方向都重复，直至填满元素的背景区域为止。<br>另外3个值分别是只在水平方向重复的repeat-x、只在垂直方向上重复的repeat-y 和在任何方向上都不重复（或者说只让背景图片显示一次）的no-repeat。</p>
<ul>
<li>background-repeat:round：为确保图片不被剪切，通过调整图片大小来适应背景区域。</li>
<li>background-repeat:space，为确保图片不被剪切，通过在图片间添加空白来适应<br>背景区域。</li>
</ul>
<p><strong>背景位置：</strong>控制背景位置的background-position 属性，是所有背景属性中最复杂的。background-position 属性有5个关键字值，分别是top、left、bottom、right 和center，这些关键字中的任意两个组合起来都可以作为该属性的值<br>background-position 属性同时设定元素和图片的原点。原点决定了元素和图片中某一点的水平和垂直坐标。默认情况下，background-position 的原点位于左上角。换句话说，元素的左上角和图片的左上角是对齐的，随后图片向各个方向重复，都是以左上角为起点</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*center center 的简化写法*/</span></span><br><span class="line">p#center &#123;background-position:center;&#125;   #相当于background-position:center cetner</span><br></pre></td></tr></table></figure>

<p>background-position:center center 设定图片中心点与元素中心点重合，然后再向各个方向重复<br><strong>设定背景位置时可以使用三种值：关键字、百分比、绝对或相对单位的数值。可以使用两个值分别设定水平和垂直位置。</strong></p>
<p><strong>背景尺寸：</strong>background-size 是CSS3 规定的属性，但却得到了浏览器很好的支持。这个属性用来控制背景图片的尺寸，可以给它设定的值及含义如下。</p>
<ul>
<li>50%：缩放图片，使其填充背景区的一半。</li>
<li>100px 50px：把图片调整到100 像素宽，50 像素高。</li>
<li>cover：拉大图片，使其完全填满背景区；保持宽高比。</li>
<li>contain：缩放图片，使其恰好适合背景区；保持宽高比。</li>
</ul>
<p><strong>背景粘附：</strong>background-attachment 属性控制滚动元素内的背景图片是否随元素滚动而移动。这个属性的默认值是scroll，即背景图片随元素移动。如果把它的值改为fixed，那么背景图片不会随元素滚动而移动。<br>background-attachment:fixed 最常用于给body元素中心位置添加淡色水印，让水印不随页面滚动而移动。实现这种效果的CSS 规则如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-image:url(images/watermark.png);</span><br><span class="line">    background-position:center;</span><br><span class="line">    background-color:#fff;</span><br><span class="line">    background-repeat:no-repeat;</span><br><span class="line">    background-size:contain;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简写背景属性：</strong>background 属性可以用来设定所有背景相关的值。比如，前面那个backgroundattachment的例子使用简写的background 属性，可以写成这样一条规则：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">body &#123;background:url(images/watermark.png) center #fff no-repeat contain fixed;&#125;</span><br></pre></td></tr></table></figure>

<p>声明中少写了哪个属性的值（比如没写no-repeat），就会使用相应属性的默认值（repeat）。</p>
<h3 id="其他CSS3-背景属性"><a href="#其他CSS3-背景属性" class="headerlink" title="其他CSS3 背景属性"></a>其他CSS3 背景属性</h3><p>background-clip: 控制背景绘制区域的范围，比如可以让背景颜色和背景图片只出现在内容区，而不出现在内边距区域。默认情况下，背景绘制区域是扩展到边框外边界的。<br>background-origin: 控制背景定位区域的原点，可以设定为元素盒子左上角以外的位置。比如，可以设定以内容区左上角作为原点。<br>background-break: 控制分离元素（比如跨越多行的行内盒子）的显示效果。</p>
<h3 id="多背景图片"><a href="#多背景图片" class="headerlink" title="多背景图片"></a>多背景图片</h3><p>CSS3 还可以给元素背景添加多个背景图片，下面我们就使用简写属性background来说明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    height:<span class="number">150</span>px;</span><br><span class="line">    width:<span class="number">348</span>px;</span><br><span class="line">    border:2px solid #aaa;</span><br><span class="line">    margin:<span class="number">20</span>px auto;</span><br><span class="line">    font:<span class="number">24</span>px/<span class="number">150</span>px helvetica, arial, sansserif;</span><br><span class="line">    text-align:center;</span><br><span class="line">    background:</span><br><span class="line">    url(images/turq_spiral.png) <span class="number">30</span>px <span class="number">-10</span>px no-repeat,</span><br><span class="line">    url(images/pink_spiral.png) <span class="number">145</span>px <span class="number">0</span>px no-repeat,</span><br><span class="line">    url(images/gray_spiral.png) 140px -30px no-repeat, #ffbd75;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.png" alt="attr"></p>
<h3 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h3><p>渐变就是在一定长度内两种或多种颜色之间自然的过渡。渐变分两种，一种线性渐变，一种放射性渐变。线性渐变从元素的一端延伸到另一端，放射性渐变则从元素内一点向四周发散。<br>下面来看一个简单的线性渐变的例子，HTML 标记如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">'gradient1'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class='gradient2'&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">'gradient3'</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 规则如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*为元素盒子添加样式*/</span></span><br><span class="line">div &#123;</span><br><span class="line">    height:<span class="number">150</span>px;</span><br><span class="line">    width:<span class="number">200</span>px;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    float:left;</span><br><span class="line">    margin:<span class="number">16</span>px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例1：默认为从上到下*/</span></span><br><span class="line">.gradient1 &#123;</span><br><span class="line">background:linear-gradient(#e86a43, #fff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例2：从左到右*/</span></span><br><span class="line">.gradient2 &#123;</span><br><span class="line">background:linear-gradient(left, #64d1dd, #fff);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*例3：左上到右下*/</span></span><br><span class="line">.gradient3 &#123;</span><br><span class="line">background:linear-gradient(-45deg, #e86a43, #fff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示了三种简单的渐变效果。例1 声明了一种开始属性和一种结束颜色，这两种颜色会按照默认的方向（从下到下）实现平滑过渡。例2 起点关键字left，于是渐变方向变成了从左到另一端。例3 声明了-45deg（deg 是“度”），等于把起点从默认的中上设定到了左上。<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E4%B8%89%E7%A7%8D%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C.png" alt="attr"></p>
]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>媒体查询</title>
    <url>/blog/2020/04/17/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>媒体查询提供一种查询语法去扩展媒体类型，这种查询语法可以更加具体地为用户的设备提供样式，媒体查询可以给你一种自由，让网站真正地与设备无关，不管用户如何访问网站，都为它们提供最佳的合适体验。</p>
<h2 id="媒体查询的优点"><a href="#媒体查询的优点" class="headerlink" title="媒体查询的优点"></a>媒体查询的优点</h2><p>媒体查询会基于设备的属性来检测设备，这样就不需要使用浏览器探测脚本，之后允许直接安装设备的功能区设定目标样式表，所以如果检测到用户适应小屏幕的设备，CSS规则就会调整以适应该屏幕尺寸，从屏幕上去掉无关元素，提供更小的图片，让文本变得更加清晰。</p>
<h2 id="HTML-lt-link-gt-标签"><a href="#HTML-lt-link-gt-标签" class="headerlink" title="HTML&lt;link&gt;标签"></a>HTML<code>&lt;link&gt;</code>标签</h2><p>实例：链接一个外部样式表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"theme.css"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br></pre></td></tr></table></figure>

<p>在用于样式表时，<code>&lt;link&gt;</code>标签得到了几乎所有浏览器的支持，但是几乎没有浏览器支持其他方面的用途。<br><strong>定义和用法：</strong><br><code>&lt;link&gt;</code> 标签定义文档与外部资源的关系。<br><code>&lt;link&gt;</code> 标签最常见的用途是链接样式表。<br><strong>HTML 与 XHTML 之间的差异:</strong></p>
<p>第一种是使用<code>&lt;link&gt;</code>元素区调用一个外部样式表：<br>在 HTML 中，<code>&lt;link&gt;</code> 标签没有结束标签。<br>在 XHTML 中，<code>&lt;link&gt;</code> 标签必须被正确地关闭。<br><strong>提示和注释：</strong><br>注释：link 元素是空元素，它仅包含属性。<br>注释：此元素只能存在于 head 部分，不过它可出现任何次数。<br><strong>属性：这里仅介绍HTML5中的新属性</strong></p>
<table>
    <tr>
        <td>属性</td>
        <td>值</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>href</td>
        <td>URL</td>
        <td>规定被链接文档的位置。</td>
    </tr>
    <tr>
        <td>hreflang</td>
        <td>language_code</td>
        <td>规定被链接文档中文本的语言。</td>
    </tr>
    <tr>
        <td>media</td>
        <td>media_query</td>
        <td>规定被链接文档将被显示在什么设备上。</td>
    </tr>
    <tr>
        <td rowspan="13">rel</td>
        <td >alternate</td>
        <td rowspan="13">规定当前文档与被链接文档之间的关系。</td>
    </tr>
    <tr>
        <td >author</td>
    </tr>
    <tr>
        <td >help</td>
    </tr>
    <tr>
        <td >icon</td>
    </tr>
    <tr>
        <td >licence</td>
    </tr>
    <tr>
        <td >next</td>
    </tr>
    <tr>
        <td >pingback</td>
    </tr>
    <tr>
        <td >prefetch</td>
    </tr>
    <tr>
        <td >prev</td>
    </tr>
    <tr>
        <td >search</td>
    </tr>
    <tr>
        <td >sidebar</td>
    </tr>
    <tr>
        <td >tag</td>
    </tr>
    <tr>
        <td >stylesheet</td>
    </tr>
    <tr>
        <td rowspan="2">sizes</td>
        <td>heightxwidth</td>
        <td rowspan="2">规定被链接资源的尺寸。仅适用于 rel="icon"。</td>
    </tr>
    <tr>
        <td>any</td>
    </tr>
    <tr>
        <td>type</td>
        <td>MIME_type</td>
        <td>规定被链接文档的 MIME 类型。</td>
    </tr>
</table>

<p><strong>全局属性</strong></p>
<table>
    <tr>
        <td>属性</td>
        <td>描述</td>
    </tr>
    <tr>
        <td>accesskey</td>
        <td>规定激活元素的快捷键。</td>
    </tr>
    <tr>
        <td>class</td>
        <td>规定元素的一个或多个类名（引用样式表中的类）</td>
    </tr>
    <tr>
        <td>contenteditable</td>
        <td>规定元素内容是否可编辑。</td>
    </tr>
    <tr>
        <td>contextmenu</td>
        <td>规定元素的上下文菜单。上下文菜单在用户点击元素时显示。</td>
    </tr>
    <tr>
        <td>data-*</td>
        <td>用于存储页面或应用程序的私有定制数据。</td>
    </tr>
    <tr>
        <td>dir</td>
        <td>规定元素中内容的文本方向。</td>
    </tr>
    <tr>
        <td>draggle</td>
        <td>规定元素是否可拖动。</td>
    </tr>
    <tr>
        <td>dropzone</td>
        <td>规定在拖动被拖动数据时是否进行复制、移动或链接。</td>
    </tr>
    <tr>
        <td>hidden</td>
        <td>规定元素仍未或不再相关。</td>
    </tr>
    <tr>
        <td>id</td>
        <td>规定元素的唯一 id。</td>
    </tr>
    <tr>
        <td>lang</td>
        <td>规定元素内容的语言。</td>
    </tr>
    <tr>
        <td>spellcheck</td>
        <td>规定是否对元素进行拼写和语法检查。</td>
    </tr>
    <tr>
        <td>style</td>
        <td>规定元素的行内 CSS 样式。</td>
    </tr>
    <tr>
        <td>tabindex</td>
        <td>规定元素的 tab 键次序。</td>
    </tr>
    <tr>
        <td>title</td>
        <td>规定有关元素的额外信息。</td>
    </tr>
    <tr>
        <td>translate</td>
        <td>规定是否应该翻译元素内容。</td>
    </tr>
</table>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>媒体查询设置了一个参数（或者一系列参数），如果设备在查看页面的时候具有与该参数匹配的属性，就会显示与之相关的样式规则。有三种方式使用媒体查询，它们是和我们把CSS应用到文档中的不同方式相匹配的，第一种是使用一个link元素去调用一个外部样式表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link href=<span class="string">"file"</span> rel=<span class="string">"stylesheet"</span> media=<span class="string">"logic media and (expression)"</span>&gt;</span><br></pre></td></tr></table></figure>

<p>第二种是使用@import指令调用外部的样式表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">'file'</span>) logic media and (expression);</span><br></pre></td></tr></table></figure>

<p>第三种是在一个嵌入的style元素中或在样式表本身利用扩展的@media规则使用媒体查询：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@media logic media and (expression) &#123; rules &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS权威指南</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS_01</title>
    <url>/blog/2020/05/21/HTML5+CSS3/CSS_01/</url>
    <content><![CDATA[<h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><p>CSS是层叠样式表的简称，有时我们也会称之为CSS样式表或级联样式表，CSS主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽度、边框样式、边距等）以及版本的布局和外观显示样式。<br>CSS规则主要由两个主要部分组成：选择器以及一条或多条生命。即选择器{样式}。</p>
<h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><p>选择器分为基础选择器和复合选择器两大类，基础选择器是由单个选择器组成的，复合选择器是由两个或多个基础选择器复合组成的。基础选择器包括标签选择器、类选择器、id选择器和通配符选择器。</p>
<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3><p>标签选择器由HTML标签名作为选择器，示例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="comment">/* 标签选择器：标签名 */</span></span></span><br><span class="line">p &#123;</span><br><span class="line">    color: green</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p>如果想要差异化不同的标签，单独选一个或者某几个标签，可以使用类选择器。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.类名 &#123;</span><br><span class="line">    属性1：属性值1</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p>为标有特定id的HTML元素指定特定的样式，用”#”定义。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#id</span>名 &#123;</span></span><br><span class="line">    属性1：属性值1</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h3><p>在CSS中，通配符选择器用”*”定义，它表示选取页面中所有元素（标签）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">* &#123;</span><br><span class="line">    属性1：属性值1</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="CSS字体属性总结"><a href="#CSS字体属性总结" class="headerlink" title="CSS字体属性总结"></a>CSS字体属性总结</h2><table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>font-size</td>
<td>字号</td>
<td>通常用的单位是px，一定要跟上单位</td>
</tr>
<tr>
<td>font-family</td>
<td>字体</td>
<td>实际工作中按照团队工作来写字体</td>
</tr>
<tr>
<td>font-weight</td>
<td>字体粗细</td>
<td>加粗是700或者bold，不加粗是400或者normal，记住数字不加单位</td>
</tr>
<tr>
<td>font-style</td>
<td>字体样式</td>
<td>倾斜italic，不倾斜是normal</td>
</tr>
<tr>
<td>font</td>
<td>字体连写</td>
<td>font-style font-weight  font-size/line-height   font-family</td>
</tr>
</tbody></table>
<h2 id="CSS文本属性总结"><a href="#CSS文本属性总结" class="headerlink" title="CSS文本属性总结"></a>CSS文本属性总结</h2><p>em是一个相对单位，就是当前文字(font-size)个字体的大小，如果当前元素没有设置大小，则会按照父元素的一个文字大小。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>表示</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>文本颜色</td>
<td>通常用十进制，比如#fff</td>
</tr>
<tr>
<td>text-align</td>
<td>文本对齐</td>
<td>设定文字水平的对齐方式</td>
</tr>
<tr>
<td>text-indent</td>
<td>文本缩进</td>
<td>通常用于段落首行缩进2个字的距离</td>
</tr>
<tr>
<td>text-decoration</td>
<td>文本修饰</td>
<td>none:没有；underline:下划线；overline:上划线；line-through:删除线</td>
</tr>
<tr>
<td>line-height</td>
<td>行高</td>
<td>控制行与行之间你的距离</td>
</tr>
</tbody></table>
<h2 id="Emmet-语法"><a href="#Emmet-语法" class="headerlink" title="Emmet 语法"></a>Emmet 语法</h2><h3 id="快速生成HTML结构标签"><a href="#快速生成HTML结构标签" class="headerlink" title="快速生成HTML结构标签"></a>快速生成HTML结构标签</h3><ul>
<li><ol>
<li>生成标签，直接输入标签名按tab键即可，比如 <code>div</code>然后 <code>tab</code> 键，就可以生成<code>&lt;div&gt;&lt;/div&gt;</code></li>
</ol>
</li>
<li><ol start="2">
<li>如果想要生成多个相同标签，加上 <code>*</code> 就可以了，比如 <code>div*3</code> 就可以生成3个<code>div</code>标签</li>
</ol>
</li>
<li><ol start="3">
<li>如果有父子级关系的标签，可以用<code>&gt;</code>比如 <code>ul &gt; li</code> 就可以了</li>
</ol>
</li>
<li><ol start="4">
<li>如果有兄弟关系的标签，用 <code>+</code> 就可以了，比如 <code>div+p</code></li>
</ol>
</li>
<li><ol start="5">
<li>如果生成带有类名或者id名字的，直接写<code>.demo</code>或者 <code>#two</code> 按tab键就可以了</li>
</ol>
</li>
<li><ol start="6">
<li>如果生成的div类名是有顺序的，可以用自增符号 <code>$</code></li>
</ol>
</li>
<li><ol start="7">
<li>如果想要在生成的标签内部写内容可以用<code>{}</code> 表示</li>
</ol>
</li>
</ul>
<h3 id="快速生成CSS样式"><a href="#快速生成CSS样式" class="headerlink" title="快速生成CSS样式"></a>快速生成CSS样式</h3><p>每个单词的第一个字母然后按tab键就可以了</p>
<h3 id="快速格式化代码"><a href="#快速格式化代码" class="headerlink" title="快速格式化代码"></a>快速格式化代码</h3><p>在VScode里的右键有快速格式化文档选项，也可以用<code>shift + Alt + F</code></p>
<h2 id="CSS的复合选择器"><a href="#CSS的复合选择器" class="headerlink" title="CSS的复合选择器"></a>CSS的复合选择器</h2><p>复合选择器是建立在基础选择器之上的，对基本选择器进行组合形成的。<br>常用的复合选择器有后代选择器、子选择器、并集选择器、伪类选择器等等。</p>
<h3 id="后代选择器（重要）"><a href="#后代选择器（重要）" class="headerlink" title="后代选择器（重要）"></a>后代选择器（重要）</h3><p>后代选择器又称为包含选择器，可以选择父元素里面子元素，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔，当标签发生嵌套时，内层标签就称为外层标签的后代。<br>语法规则如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素1 元素2 &#123;样式声明&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面语法表示选择元素1里面的所有元素2(后代元素)。</li>
<li>元素1和元素2中间用空格隔开</li>
<li>元素1是父级，元素2是子级，最终选择的是元素2</li>
<li>元素2可以是儿子，也可以是孙子等，只要是元素2的后代即可</li>
<li>元素1和元素2可以是任意的基础选择器</li>
</ul>
<h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><p>子元素选择器只能选择作为某元素的最近一级元素，简单理解就是选亲儿子元素<br>语法规则如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素1&gt;元素2 &#123;样式声明&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>元素1额话元素2之间用<code>大于号</code>隔开</li>
<li>元素1是父级，元素2是子级，最终选择的是元素2</li>
<li>元素2必须是亲儿子，其孙子、重孙之类的都不归他管，你也可以叫他亲儿子选择器</li>
</ul>
<h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><p>并集选择器可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明。<br>并集选择器是各选择器通过英文(,)连接而成，任何形式的选择器都可以作为并集选择器的一部分。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">元素1,元素2 &#123;样式声明&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>元素1和元素2之间用逗号分开</li>
<li>约定的语法规范，并集选择器喜欢竖着写</li>
<li>逗号可以理解为和的意思</li>
<li>并集选择器通常用于集体声明</li>
</ul>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1个，第n个元素。<br>伪类选择器的最大的特点是用冒号(:)表示，比如：hover:first-child</p>
<ul>
<li>链接伪类选择器</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">a:link    /*选择所有未被访问的链接*/</span><br><span class="line">a:visited /*选择所有已被访问的链接*/</span><br><span class="line">a:hover   /*选择鼠标指针位于其上的链接*/</span><br><span class="line">a:active /*选择活动链接(鼠标按下未弹起的链接)*/</span><br></pre></td></tr></table></figure>
<p>示例程序如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>链接伪类选择器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="comment">/* 未访问的链接a:link，把没有点击过的(访问过的)链接选出来 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">color</span>: <span class="selector-id">#333</span>;</span></span><br><span class="line">            text-decoration: none;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* a:visited选择点击过的(访问过的)链接 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span></span><br><span class="line">            color: grey;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* a:hover选择鼠标经过那个链接 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line">            color: skyblue;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* a:active选择的是鼠标正在按下还没弹起鼠标的那个链接 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line">            color: tomato;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>小猪佩奇<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong>为了确保生效，按照LVHA的顺序声明 :link  :visited  :hover  :active</p>
<h3 id="focus伪类选择器"><a href="#focus伪类选择器" class="headerlink" title="focus伪类选择器"></a>focus伪类选择器</h3><p>:focus伪类选择器用于选取获得焦点的表单元素，焦点就是光标，一般情况<code>&lt;input&gt;</code>类元素才能获取，因此这个选择器也主要针对于表单元素来说。示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">input:focus &#123;</span><br><span class="line">    background-color:pink;  //获得焦点的那个input背景变为粉色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CSS的元素的显示模式"><a href="#CSS的元素的显示模式" class="headerlink" title="CSS的元素的显示模式"></a>CSS的元素的显示模式</h2><p>元素显示模式就是元素（标签）以什么方式进行显示。比如<code>&lt;div&gt;</code>自己占一行，一行可以放多个<code>&lt;span&gt;</code>。<br>HTML元素一般分为<code>块元素</code>和<code>行内元素</code>两种类型。</p>
<h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><p>常见的块元素有<code>&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;</code>等，其中<code>&lt;div&gt;</code>标签是<strong>最典形的元素</strong><br>块元素的特点：</p>
<ul>
<li>比较霸道，自己独占一行</li>
<li>高度、宽度、外边距以及内边距都可以控制</li>
<li>宽度默认是容器(父级宽度)的100%</li>
<li>是一个容器级盒子，里面可以放行内元素或者块级元素</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>文字类的元素不能使用块级元素</li>
<li><code>&lt;p&gt;</code>标签主要用于存放文字，因此<code>&lt;p&gt;</code>里面不能放块级元素，特别不能放<code>&lt;div&gt;</code></li>
<li>同理，<code>&lt;h1&gt;~&lt;h6&gt;</code>等都是文字类块级标签，里面也不能放其他块元素</li>
</ul>
<h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>常见的行内元素有<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;b&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;del&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;ins&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;span&gt;</code>等，其中<code>&lt;span&gt;</code>标签是最典形的行内元素，有的地方也将行内元素称为内联元素。</p>
]]></content>
      <categories>
        <category>HTML5+CSS3</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标签(上)</title>
    <url>/blog/2020/05/14/HTML5+CSS3/HTML5%E6%A0%87%E7%AD%BE(%E4%B8%8A)/</url>
    <content><![CDATA[<h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p>标题标签按照标题的大小分为6级，分别是<code>&lt;h1&gt;&lt;/h1&gt;——&lt;h6&gt;&lt;/h6&gt;</code></p>
<h2 id="段落标签和换行标签"><a href="#段落标签和换行标签" class="headerlink" title="段落标签和换行标签"></a>段落标签和换行标签</h2><p>段落标签：<code>&lt;p&gt;&lt;/p&gt;</code><br>换行标签：<code>&lt;br /&gt;</code></p>
<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><p>加粗： <code>&lt;strong&gt;&lt;/strong&gt;</code>或<code>&lt;b&gt;&lt;/b&gt;</code>  (推荐使用<code>&lt;strong&gt;&lt;/strong&gt;</code>)<br>倾斜： <code>&lt;em&gt;&lt;/em&gt;</code>或<code>&lt;i&gt;&lt;/i&gt;</code>    (推荐使用<code>&lt;em&gt;&lt;/em&gt;</code>)<br>删除线：<code>&lt;del&gt;&lt;/del&gt;</code>或<code>&lt;s&gt;&lt;/s&gt;</code> (推荐使用<code>&lt;del&gt;&lt;/del&gt;</code>)<br>下划线：<code>&lt;ins&gt;&lt;/ins&gt;</code>或<code>&lt;u&gt;&lt;/u&gt;</code> (推荐使用<code>&lt;ins&gt;&lt;/ins&gt;</code>)</p>
<h2 id="lt-div-gt-和-lt-span-gt"><a href="#lt-div-gt-和-lt-span-gt" class="headerlink" title="&lt;div&gt;和&lt;span&gt;"></a><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code></h2><p><code>&lt;div&gt;&lt;/div&gt;</code>是盒子标签，一行只能放一个<br><code>&lt;span&gt;&lt;/span&gt;</code>也是盒子标签，一行可以放多个，中间不占距离</p>
<h2 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h2><p><code>&lt;img src=&quot;图像URL&quot; /&gt;</code> src是<code>&lt;img&gt;</code>标签的必须属性，它用于指定图像文件的路径和文件名</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>图片路径</td>
<td>必须属性</td>
</tr>
<tr>
<td>alt</td>
<td>文本</td>
<td>替换文本，图像不能显示时的文字</td>
</tr>
<tr>
<td>title</td>
<td>文本</td>
<td>提示文本，鼠标放到图像上显示的文字</td>
</tr>
<tr>
<td>width</td>
<td>像素</td>
<td>设置图像的宽度</td>
</tr>
<tr>
<td>height</td>
<td>像素</td>
<td>设置图像的高度</td>
</tr>
<tr>
<td>border</td>
<td>像素</td>
<td>设置图像的边框粗细</td>
</tr>
</tbody></table>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>以引用文件位置为参考基础，而建立的目录路径。</p>
<table>
<thead>
<tr>
<th>相对路径分类</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>同一级路径</td>
<td></td>
<td>图像位于HTML文件同一级，如<code>&lt;img src=&quot;baidu.gif&quot; /&gt;</code></td>
</tr>
<tr>
<td>下一级路径</td>
<td>/</td>
<td>图像位于HTML文件同一级, 如<code>&lt;img src=&quot;images/baidu.gif&quot; /&gt;</code></td>
</tr>
<tr>
<td>上一级路径</td>
<td>../</td>
<td>图像位于HTML文件上一级， 如<code>&lt;img src=&quot;../baidu.gif&quot; /&gt;</code></td>
</tr>
</tbody></table>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>是指目录下的绝对位置，直接到达目标位置，通常是从盘符开始的路径。<br>例如：”D:\blog\images\logo.gif” 或者完整的网络地址 “<a href="https://www.itcast.cn/images/logo.gif&quot;" target="_blank" rel="noopener">https://www.itcast.cn/images/logo.gif&quot;</a></p>
<h2 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h2><p><code>&lt;a&gt;</code>标签用于定义超链接，作用是从一个页面到另一个页面。<br>语法：<code>&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或者图像&lt;/a&gt;</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>用于指定链接目标的url地址，是必须属性，当为标签应用href属性时，它就具有了超链接的功能</td>
</tr>
<tr>
<td>target</td>
<td>用于指定链接页面的打开方式，其中_self 为默认值，_blank为在新窗口中的打开方式</td>
</tr>
</tbody></table>
<p>链接分类</p>
<ul>
<li><ol>
<li>外部链接：例如<code>&lt;a href=&quot;http://www.qq.com&quot; target=&quot;_blank&quot;&gt;腾讯&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="2">
<li>内部链接： 网站内部页面之间的相互链接，直接链接内部页面名称即可。例如：<br><code>&lt;a href=&quot;gongsijianjie.html&quot;&gt;公司简介&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="3">
<li>空链接：如果当时没有确定链接目标时，可以设置<code>&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="4">
<li>下载链接：如果href里面地址是一个文件或者压缩包，会下载这个文件，地址链接的是文件、.exe或者.zip等形式。<br>例如：<code>&lt;a href=&quot;img.zip&quot;&gt;下载文件&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="5">
<li>网页元素链接：在网页中的各种网页元素，如文本、图像、表格、音频、视频等都可以。<br>添加超链接：如<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;&lt;img src=&quot;img.jpg&quot; /&gt;&lt;/a&gt;</code></li>
</ol>
</li>
<li><ol start="6">
<li>锚点链接：当我们点击链接，可以快速定位到页面中的某个位置。<ul>
<li>在链接的href属性中，设置属性值为 <code>#名字</code> 的形式，如 <code>&lt;a href=&quot;#two&quot;&gt;第二集&lt;/a&gt;</code></li>
<li>找到相同位置标签，里面添加一个<code>id属性=刚才的名字</code>，如<code>&lt;h3 id=two&gt;第二集介绍&lt;/h3&gt;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
<th>字符的代码</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格符</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&gt;</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;</td>
</tr>
<tr>
<td>￥</td>
<td>人民币</td>
<td>&yen;</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&copy;</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&reg;</td>
</tr>
<tr>
<td>±</td>
<td>加减号</td>
<td>&plusmn;</td>
</tr>
<tr>
<td>℃</td>
<td>摄氏度</td>
<td>&deg;</td>
</tr>
<tr>
<td>✖</td>
<td>乘号</td>
<td>&times;</td>
</tr>
<tr>
<td>➗</td>
<td>除号</td>
<td>&divide;</td>
</tr>
<tr>
<td>²</td>
<td>平方</td>
<td>&sup2;</td>
</tr>
<tr>
<td>³</td>
<td>立方3</td>
<td>&sup3;</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>HTML5+CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标签(下)</title>
    <url>/blog/2020/05/15/HTML5+CSS3/HTML5%E6%A0%87%E7%AD%BE(%E4%B8%8B)/</url>
    <content><![CDATA[<h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><h3 id="表格标签的基本语法"><a href="#表格标签的基本语法" class="headerlink" title="表格标签的基本语法:"></a>表格标签的基本语法:</h3><ul>
<li><ol>
<li><code>&lt;table&gt;&lt;/table&gt;</code>是用于定义表格的标签。</li>
</ol>
</li>
<li><ol start="2">
<li><code>&lt;tr&gt;&lt;/tr&gt;</code>标签用于定义表格中的行，必须嵌套在<code>&lt;table&gt;&lt;/table&gt;</code>标签中。</li>
</ol>
</li>
<li><ol start="3">
<li><code>&lt;td&gt;&lt;/td&gt;</code>用于定义表格中的单元格，必须嵌套在<code>&lt;tr&gt;&lt;/tr&gt;</code>标签中。</li>
</ol>
</li>
<li><ol start="4">
<li>字母td指表格数据(table data)，即数据单元格的内容。</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="表头单元格标签"><a href="#表头单元格标签" class="headerlink" title="表头单元格标签"></a>表头单元格标签</h3><p><code>&lt;th&gt;</code>标签表示HTML表格的表头部分(table head)：会加粗居中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span> <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>刘德华<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>56<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>张学友<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">td</span>&gt;</span>56<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><p>表格标签这部分属性在实际开发中不常用，后面用CSS来设置。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>align</td>
<td>left  center  right</td>
<td>规定相对周围元素的对齐方式</td>
</tr>
<tr>
<td>border</td>
<td>1或””</td>
<td>规定表格单元是否拥有边框，默认为””,表示没有边框</td>
</tr>
<tr>
<td>cellpadding</td>
<td>像素值</td>
<td>规定单元边沿其内容之间的空白，默认1像素</td>
</tr>
<tr>
<td>cellspacing</td>
<td>像素值</td>
<td>规定单元格之间的空白，默认2像素</td>
</tr>
<tr>
<td>width</td>
<td>像素值或百分比</td>
<td>规定表格的宽度</td>
</tr>
</tbody></table>
<h3 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h3><p>表格分为头部区域与主体区域<br><code>&lt;thead&gt;&lt;/thead&gt;</code>表示表格的头部区域，<code>&lt;tbody&gt;&lt;/tbody&gt;</code>表示表格的主体区域。</p>
<h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><ul>
<li>1.合并单元格的方式：<ul>
<li>跨行合并：rowspan=”合并单元格的个数”，最上侧为目标单元格，写合并代码；</li>
<li>跨列合并：colspan=”合并单元格的个数”，最左侧为目标单元格，写合并代码。</li>
</ul>
</li>
<li>2.合并单元格三部曲：<ul>
<li>先确定是跨行还是跨列</li>
<li>找到目标单元格，写上合并方式=”合并的单元格数量”，比如：<code>&lt;td colspan=&quot;2&quot;&gt;&lt;/td&gt;</code></li>
<li>删除多余的单元格</li>
</ul>
</li>
</ul>
<h2 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h2><p>表格是用来展示数据的，列表是用来布局的，列表最大的特点就是整洁、有序，它作为布局会更加自由和方便。</p>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p><code>&lt;ul&gt;&lt;/ul&gt;</code>标签表示HTML页面中的无序列表，一般会以项目符号呈现列表项，而列表项使用<code>&lt;li&gt;&lt;/li&gt;</code>标签定义。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.无序列表的各个列表项之间没有顺序级别之分，是并列的。</li>
<li>2.<code>&lt;ul&gt;&lt;/ul&gt;</code>中只能嵌套<code>&lt;li&gt;&lt;/li&gt;</code>，直接在<code>&lt;ul&gt;&lt;/ul&gt;</code>中输入其它标签或者文字的做法是不被允许的。</li>
<li>3.<code>&lt;li&gt;&lt;/li&gt;</code>相当于一个容器，可以容纳所有元素。</li>
<li>4.无序列表会带有自己的样式属性，但在实际应用时，我们使用CSS来设置。</li>
</ul>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>在HTML中，<code>&lt;ol&gt;</code>标签用于定义有序列表，列表排序以数字来显示，并且使用<code>&lt;li&gt;</code>标签来定义列表项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.<code>&lt;ol&gt;&lt;/ol&gt;</code>中只能放<code>&lt;li&gt;&lt;/li&gt;</code>，不允许放其他元素。</li>
<li>2.<code>&lt;li&gt;&lt;/li&gt;</code>相当于一个容器，可以容纳所有元素。</li>
<li>3.有序列表会带有自己的样式属性，但在实际应用时，我们使用CSS来设置。</li>
</ul>
<h3 id="自定义列表"><a href="#自定义列表" class="headerlink" title="自定义列表"></a>自定义列表</h3><p>自定义列表经常用于对术语或者名词进行解释和描述，定义列表的列表项前没有任何项目符号。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释3<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.<code>&lt;dl&gt;</code>里只能出现<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code></li>
<li>2.<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code>标签个数无限制</li>
</ul>
<h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>使用表单标签的目的是为了收集用户信息，在HTML中，一个完整的表单通常由表单域、表单控件(表单元素)和提示信息3个部分组成。</p>
<h3 id="表单域：是一个包含表单元素的区域。"><a href="#表单域：是一个包含表单元素的区域。" class="headerlink" title="表单域：是一个包含表单元素的区域。"></a>表单域：是一个包含表单元素的区域。</h3><p>在HTML中，<code>&lt;form&gt;&lt;/form&gt;</code>标签用于定义表单域，以实现用户信息的收集和传递。<code>&lt;form&gt;&lt;/form&gt;</code>会把它范围内的表单元素提交给服务器。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"url地址"</span> <span class="attr">method</span>=<span class="string">"提交方式"</span> <span class="attr">name</span>=<span class="string">"表单域名称"</span>&gt;</span>各种表单元素控件<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>action</td>
<td>url地址</td>
<td>用于指定接收并处理表单数据的服务器程序的url地址</td>
</tr>
<tr>
<td>method</td>
<td>get/post</td>
<td>用于设置表单数据的提交方式，其取值为get/post</td>
</tr>
<tr>
<td>name</td>
<td>名称</td>
<td>用于指定表单的名称，以区分一个页面中的多个表单域</td>
</tr>
</tbody></table>
<h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><p><strong><code>&lt;input&gt;</code>表单元素：用于手机用户信息。</strong><br>语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"属性"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>type属性的属性值及其描述如下：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>button</td>
<td>定义可点击按钮</td>
</tr>
<tr>
<td>checkbox</td>
<td>定义复选框</td>
</tr>
<tr>
<td>file</td>
<td>定义输入字段和”浏览”按钮，供文件上传</td>
</tr>
<tr>
<td>hidden</td>
<td>定义隐藏的输入字段</td>
</tr>
<tr>
<td>image</td>
<td>定义图像形式的提交按钮</td>
</tr>
<tr>
<td>password</td>
<td>定义密码字段，该字段的字符被掩码</td>
</tr>
<tr>
<td>radio</td>
<td>定义单选按钮</td>
</tr>
<tr>
<td>reset</td>
<td>定义重置按钮，重置按钮会清除表单中的所有数据</td>
</tr>
<tr>
<td>submit</td>
<td>定义提交按钮，提交按钮会把表单数据发送到服务器</td>
</tr>
<tr>
<td>text</td>
<td>定义单行的输入字段，用户可在其中输入文本，默认宽度20个字符</td>
</tr>
</tbody></table>
<p>除type属性外，还有其他属性，其常用属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>由用户定义</td>
<td>定义input元素的名称</td>
</tr>
<tr>
<td>value</td>
<td>由用户定义</td>
<td>定义input元素的值</td>
</tr>
<tr>
<td>checked</td>
<td>checked</td>
<td>规定此input元素首次加载时应当被选中</td>
</tr>
<tr>
<td>maxlength</td>
<td>正整数</td>
<td>规定输入字段的字符的最大长度</td>
</tr>
</tbody></table>
<p>**<code>&lt;label&gt;</code>标签为<code>&lt;input&gt;</code>元素标注（标签）<br><code>&lt;label&gt;</code>标签用于绑定一个表单元素，当点击<code>&lt;label&gt;</code>标签的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验。<br>语法如下：<code>&lt;label&gt;</code>标签中的for属性与相应的元素的id属性相同。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sex"</span>&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">id</span>=<span class="string">"sex"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>&lt;select&gt;</code>下拉表单元素</strong><br>在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<code>&lt;select&gt;</code>标签控件定义下拉列表。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.<code>&lt;select&gt;</code>中至少包含一对<code>&lt;option&gt;</code></li>
<li>2.在<code>&lt;option&gt;</code>中定义selected=”selected”时，当前项即为默认选项。</li>
</ul>
<p><strong><code>&lt;textarea&gt;</code>文本域元素</strong><br>当用户输入内容较多的情况下，不能使用文本框表单了，就使用文本域元素。<br>语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"3"</span> <span class="attr">cols</span>=<span class="string">"20"</span>&gt;</span>文本内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>&lt;textarea&gt;</code>可以轻松地创建行文本输入框,cols=”每行的字符数”，rows=”显示的行数”(实际开发中不会使用，都是用CSS来改变大小)</p>
]]></content>
      <categories>
        <category>HTML5+CSS3</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 BOM</title>
    <url>/blog/2020/04/18/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/BOM/</url>
    <content><![CDATA[<p>ECMAScript是JavaScript的核心，但如果要在Web中使用JavaScript，那么BOM（浏览器对象模型）则无疑才是真正的核心。,BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。</p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>BOM的核心对象是window，它表示浏览器的一个实例。在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。在window中定义的任何一个变量、函数和对象，都以window作为其Global对象，因此有权访问parseInt等方法。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>由于window对象同时扮演着ECMAScript中的Global对象的角色，因此所有在全局作用域中声明的变量、函数都会变成window对象的属性和方法。<br><strong>定义全局变量与在window对象上定义属性的差别：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。</strong></p>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中，可以通过数值索引（从0开始，从左至右，从上到下）或者框架名称来访问相应的window对象，每个window对象都有一个name属性，其中包含框架的名称。</p>
<div class="note info">
            <p>top 对象始终指向最高（最外层）的框架，也就是浏览器窗口。<br>parent （父）对象始终指向当前框架的直接上层框架。<br>self 对象始终指向window对象，可以与window互换使用。</p>
          </div>

<h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>使用window.open()方法可以导航到一个特定的URL,也可以打开一个新的浏览器窗口。这个方法可以接收四个参数：要加载的URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只传递第一个参数，最后一个参数只有在不打开新窗口的情况下使用。</p>
<h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><p>JavaScript是单线程语言，但它允许设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者是每隔指定的时间就执行一次代码。<br>超时调用需要使用window对象的setTimeout()方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是一个字符串（就和在eval()函数中使用的字符串一样），也可以是一个函数。实例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不建议传递字符串,有可能导致性能损失</span></span><br><span class="line">setTimeout(<span class="string">"alert('Hello world')"</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 推荐的调用方式</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>调用setTimeout()之后，该方法会返回一个数值ID，表示超值调用，这个超时调用ID是计划执行代码的唯一标识符，可以通过它来取消超时调用。采用clearTimeout()方法可以将尚未执行的超时调用计划取消，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置超时调用</span></span><br><span class="line"><span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">clearTimeout(timeoutId); <span class="comment">// 取消超时调用计划的ID即可取消调用</span></span><br></pre></td></tr></table></figure>

<p>间歇调用和超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是setInterval()，它接受的参数与setTimeout()相同：要执行的代码（字符串或函数）和每次执行之前需要等待的毫秒数。与超时调用类似，取消间歇调用也是取消间歇调用返回的ID，取消方法是clearInterval()看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置间歇调用</span></span><br><span class="line"><span class="keyword">var</span> timeoutId = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//取消间歇调用</span></span><br><span class="line">clearInterval(timeoutId)</span><br></pre></td></tr></table></figure>
<p><strong>取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用会执行到页面卸载。但是在开发中很少使用间歇调用，一般使用超时调用。</strong></p>
]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 函数表达式</title>
    <url>/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的，下面先看一个错误使用递归函数的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">1</span>));    <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">4</span>));    <span class="comment">//TypeError: factorial is not a function</span></span><br></pre></td></tr></table></figure>

<p>原因是：以上代码先把factorial()函数保存在变量anotherFactorial中，然后将factorial变量设置为null,结果指向原始函数的引用只剩下一个，但在接下来调用anotherFactorial()时，由于必须执行factorial()，而factorial已经不再是函数，所以就会导致错误，该问题可以用arguments.callee解决。<br><strong>arguments.callee是一个指向正在执行的函数的指针。但在严格模式下不能通过脚本访问arguments.callee，因此在严格模式下可以使用命名函数表达式来达成相同的效果</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 非严格模式下</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">4</span>));    <span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">#严格模式下</span><br><span class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * f(num<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial;</span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(anotherFactorial(<span class="number">4</span>));     <span class="comment">//24</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包是指有权访问另一个函数作用域中的变量的函数。</strong>创建闭包的常见方式就是在一个函数内部创建另一个函数。</p>
<h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>作用链的配置机制引出一个值得注意的副作用：<strong>即闭包只能取得包含函数中任何变量的最后一个值。但是闭包保存的是整个变量对象，而不是某个特殊的变量。</strong>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = createFunctions();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> result) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item())               <span class="comment">//0 1 2 3 4 5 6 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数没有直接将闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值，在调用每个匿名函数时，传入了变量i,由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num，在匿名函数内部，又创建并返回了一个访问num的闭包，<strong>注意这样的结果是result返回的是一个指向结果的指针组成的数组，调用数组中的每个指针才能得到结果。</strong></p>
<h3 id="关于this"><a href="#关于this" class="headerlink" title="关于this"></a>关于this</h3><p>在闭包中使用this对象有可能会导致一些问题，<strong>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。</strong>但是，<strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window</strong>，有时候由于编写闭包的方式不同，这一点不会那么明显。<br>先看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());   <span class="comment">//undefined(在严格模式下)  "The Window"(在非严格模式下)</span></span><br></pre></td></tr></table></figure>

<p><strong>上面的代码在严格模式下取得的是undefined，在做项目时经常出现的问题，非严格模式下取得的是全局name的变量，没有取得其包含作用域（或外部作用域）的this对象</strong><br>每个函数在被调用时，其活动对象都会自动取得两个特殊变量：this和arguments，内部函数在搜索这两个变量时，只会搜索到其活动对象为止，永远不可能直接访问外部函数中的这两个变量，但是，把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name: <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()());   <span class="comment">//'My Object'</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中最重要的不同时在定义匿名函数之前，把this对象赋值给了一个名为that的变量，在定义闭包之后，闭包也可以访问这个变量，即使在函数返回之后，this也仍然引用着object，所以上面的调用有返回值。<br><strong>this与arguments一样存在同样的问题，如果想访问arguments对象，必须将对该对象的引用保存在另一个闭包能够访问到的变量中。</strong></p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来说，JavaScript中没有私有成员的概念，所有对象属性都是公有的，不过倒是又一个私有变量的概念。<strong>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包含函数的参数、局部变量和在函数内部定义的其他函数。</strong>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个函数内部，有3个私有变量：num1、num2和sum。在函数内部可以访问这几个变量，但在函数外部则不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量，利用这一点就可以创建用于访问私有变量的公有方法。<br><strong>有权访问私有变量和私有函数的公有方法称为特权方法。</strong>有两种在对象上创建特权方法的方式，第一种是在构造函数中定义特权方法，基本模式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> privateVariable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="built_in">console</span>.log(myObject.publicMethod())     <span class="comment">//11</span></span><br></pre></td></tr></table></figure>

<p>这个模式在构造函数内部定义了所有私有变量和函数，然后又创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。上面的例子中的变量privateVariable和函数privateFunction()只能通过特权方法publicMethod()来访问。</p>
]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 DOM</title>
    <url>/blog/2020/07/04/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/DOM/</url>
    <content><![CDATA[<p>DOM(文档对象模型)是针对HTML和XML文档的一个API(应用程序编程接口)。DOM描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。</p>
<h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型，每种类型分别表示文档中不同的信息及（或）标记。每个节点都拥有各自的特点、数据和方法，另外也和其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。以下面的HTML为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以将这个简单的HTML文档表示为如下层次结构：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/DOM/10-1%E8%8A%82%E7%82%B9%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="attr"></p>
<p>文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即<code>&lt;html&gt;</code>元素，我们称之为文档元素。<strong>文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中</strong>。每个文档只能有一个文档元素。在HTML页面中，文档元素始终都是<html>元素。在XML中，没有预定义的元素，因此任何元素都可能成为文档元素。</p>
<p>每一段标记都可以通过树中的一个节点来表示；HTML元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有12种节点类型，这些类型有继承自一个基类型。</p>
<h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的；除了IE之外，在其他所有浏览器中都可以访问到这个类型。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享着相同的基本属性和方法。</p>
<div class="note info">
            <p>每个节点都有一个<code>nodeType</code>属性，用于表明节点的类型。节点类型有Node类型中定义的下列12个数值常量来表示，任何节点类型必居其一：</p><ul><li>Node.ELEMENT_NODE(1)；</li><li>Node.ATTRIBUTE_NODE(2)；</li><li>Node.TEXT_NODE(3)；</li><li>Node.CDATA_SECTION_NODE(4)；</li><li>Node.ENTITY_REFERENCE_NODE(5)；</li><li>Node.ENTITY_NODE(6)；</li><li>Node.PROCESSING_INSTRUCTION_NODE(7)；</li><li>Node.COMMENT_NODE(8)；</li><li>Node.DOCUMENT_NODE(9)；</li><li>Node.DOCUMENT_TYPE_NODE(10)；</li><li>Node.DOCUMENT_FRAGMENT_NODE(11)；</li><li>Node.NOTATION_NODE(12)；</li></ul>
          </div>

<p>通过比较上面这些常量，可以很容易地确定节点的类型，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在IE中无效</span></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Node is an element'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了确保跨浏览器兼容，最好还是将nodeType属性与数字值进行比较，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 适用于所有浏览器</span></span><br><span class="line"><span class="keyword">if</span> (someNode.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Node is an element'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了了解节点的具体信息，可以使用<code>nodeName</code>和<code>nodeType</code>这两个属性，这两个属性的值完全取决于节点的类型。</p>
<h4 id="节点关系属性"><a href="#节点关系属性" class="headerlink" title="节点关系属性"></a>节点关系属性</h4><div class="note info">
            <p>文档中所有的节点之间都存在这样或那样的关系，节点间的各种关系可以用传统的家族关系来描述，相当于把文档树比喻成家谱。每个节点都有如下属性，用于记录彼此之间的关系：</p><ul><li>childNodes：该属性可以看作一个保存着所有子节点的有序列表。</li><li>children：该属性可以看作一个保存着所有子元素的有序列表，它是非标准的，但是绝大多数浏览器都支持。</li><li>firstChild：指向childNodes列表的第一个节点，如果不存在，则为null。</li><li>lastChild：指向childNodes列表的最后一个节点，如果不存在，则为null。</li><li>parentNode：该属性指向文档中的父节点。</li><li>previousSibling：指向上一个同胞节点，如果不存在，则为null。</li><li>nextSibling：指向下一个同胞节点，如果不存在，则为null。</li><li>ownerDocument：指向表示整个文档的文档节点。</li></ul>
          </div>

<p>关于<code>childNodes</code>属性，该属性中保存着一个<code>NodeList</code>对象，<code>NodeList</code>对象是一种类数组对象，用于保存一组有序的节点。<strong><code>NodeList</code>对象的独特之处在于，它实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能够自动反映在<code>NodeList</code>对象中。</strong>如果要访问<code>NodeLis</code>t对象中的元素，可以使用方括号语法或者<code>item()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstChild = someNode.childNodes[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> secondChild = someNode.childNodes.item(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> count = someNode.childNodes.length</span><br></pre></td></tr></table></figure>

<p>下图形象的展示了这些属性的含义：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/DOM/10-2%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB%E5%B1%9E%E6%80%A7.png" alt="attr"></p>
<h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><div class="note info">
            <p>因为节点的关系属性都是只读的，所以DOM提供了一些操作子节点的方法，<strong>注意：这四种方法操做的都是某个节点的子节点，也就是说，要使用这几个方法必须要先取得父节点（使用<code>parentNode</code>属性）</strong>：</p><ul><li>appendChild( )：该方法接受单个参数：要新增的节点。操作成功后返回新增的节点。该操作会将新增的节点添加到childNodes列表的末尾。添加节点后，childNodes中相关节点的关系会自动更新；</li><li>insertBefore( )：该方法接受两个参数：要插入的节点和作为参照的节点。插入节点后，被插入的节点会变成参照节点的前一个同胞节点(previousSibling)同时被方法返回。如果第二个参数是null，则会将要插入的节点添加到childNodes列表的末尾。如果省略第二个参数，会抛出错误；</li><li>replaceChild( )：该方法接受两个参数：要插入的节点和要替换的节点。操作成功后返回被替换的节点；</li><li>removeChild( )：该方法接受单个参数：要移除的节点。操作成功后返回被移除的节点。</li></ul><hr><p>注意事项：</p><ul><li>任何一个DOM节点不能同时出现在文档中的多个位置上，所以当使用<code>appendChild()</code>、<code>insertBefore()</code>或<code>replaceChild()</code>方法并且传入的第一个参数为文档树中已经存在的节点时，该节点会从原位置转移到对应的新位置；</li><li>每个节点都有一个<code>ownerDocument</code>属性，表示所属的文档。如果调用<code>appendChild()</code>时传入的节点属于不同的文档，则会抛出错误。</li></ul>
          </div>

<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><div class="note info">
            <ul><li>cloneNode( )：用于创建调用这个方法的节点的一个完全相同的副本。该方法接受一个布尔值参数，表示是否执行深复制。在参数为true时，执行深复制，也就是复制节点及其整个子节点树；在参数为false时，执行浅复制，即只复制节点本身。复制后返回的节点副本属于文档所有，但并没有为它指定父节点。需要注意的是，该方法不会复制添加到DOM节点中的JavaScript属性，例如事件处理程序等；</li><li>normalize( )：该方法唯一的作用是处理文档树中的文本节点。由于解析器的实现或DOM操作等原因，可能会出现文本节点不包含文本，或者接连出现两个文本节点的情况。当在某个节点上调用这个方法时，就会在该节点的后代节点中查找上述两种情况。如果找到了空文本节点，则删除它；如果找到相邻的文本节点，则将它们合并为一个文本节点。</li></ul>
          </div>

<h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>JavaScript通过Document类型表示文档。在浏览器中，document对象是HTMLDocument（继承自Document类型）的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。Document节点具有下列特征：</p>
<div class="note info">
            <ul><li>nodeType的值为9；</li><li>nodeName的值为”#document”；</li><li>nodeValue的值为null；</li><li>parentNode的值为null；</li><li>ownerDocument的值为null；</li><li>其子节点可能是一个DocumentType（最多一个）、Element（最多一个）、ProcessingInstruction或Comment。</li></ul>
          </div>

<h4 id="document对象的属性"><a href="#document对象的属性" class="headerlink" title="document对象的属性"></a>document对象的属性</h4><div class="note info">
            <ul><li>documentElement：该属性指向HTML页面中的<html>元素,用法:document.documentElement;</li><li>body：该属性指向HTML页面中的<body>元素,用法:document.body；</li><li>doctype：该属性指向&lt;!DOCTYPE&gt;标签，但是不同浏览器对该属性的支持差别很大,用法:document.doctype；</li><li>title：通过该属性可以取得当前页面的标题，也可以修改当前页面的标题并反映在浏览器的标题栏中，用法:document.title；</li><li>URL：该属性保存着页面完整的URL，用法:document.URL；</li><li>domain：该属性保存着页面的域名，用法:document.domain；</li><li>referrer：该属性保存着链接到当前页面的那个页面的URL。在没有来源页面的情况下，该属性值可能会包含空字符串,用法:document.referrer</li></ul><hr><p><strong>关于domain属性，可以将低级域改为高级域，但是不能将高级域改为低级域。</strong></p>
          </div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'wrox.com'</span>        <span class="comment">// 成功</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">'p2p.wrox.com'</span>    <span class="comment">// 抛出错误！</span></span><br></pre></td></tr></table></figure>

<h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><div class="note info">
            <ul><li><strong>document.getElementById( )</strong>：该方法接受单个参数：要取得的元素ID。如果找到相应的元素则返回该元素，如果不存在则返回null。<strong>注意，这里的ID必须与页面中元素的id特性（attribute）严格匹配，包括大小写。如果页面中多个元素的ID值相同，则该方法只返回文档中第一次出现的元素</strong>。</li><li><strong>document.getElementsByTagName( )</strong>：该方法接受单个参数：要取得元素的标签名。该方法返回的是包含零或多个元素的<code>HTMLCollection</code>对象。如果想要取得文档中的所有元素，可以向该方法传入<code>&quot;*&quot;</code>；</li><li><strong>document.getElementsByName( )</strong>：该方法是只有HTMLDocument类型才有的方法，它接受单个参数：要取得元素的<code>name</code>特性值。该方法返回的是包含零或多个元素的<code>NodeList</code>对象（书上说的是返回<code>HTMLCollection</code>对象，MDN上说返回<code>NodeList</code>对象，不同浏览器可能实现的不同吧）。</li></ul><hr><p><code>HTMLCollection</code>对象与<code>NodeList</code>对象非常相似（它们都是动态的，都是类数组对象），它们之间只有两个区别：<br><code>HTMLCollection</code>对象是元素集合，而<code>NodeList</code>对象是节点集合；<br><code>HTMLCollection</code>对象多出了一个<code>namedItem()</code>方法，该方法可以通过元素的<code>name</code>特性取得集合中对应的元素，如果多个元素的<code>name</code>特性相同，则返回第一个元素。<code>HTMLCollection</code>对象支持按名称访问项，如果向方括号中传入字符串形式的索引值，在后台会自动调用<code>namedItem()</code>方法，即<code>elements[&#39;myImg&#39;] === htmls.namedItem(&#39;myImg&#39;)</code>。</p>
          </div>

<h4 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h4><div class="note info">
            <p>除了属性和方法，document对象还有一些特殊的集合。这些集合都是<code>HTMLCollection</code>对象，为访问文档常用的部分提供了快捷方式，包括：</p><ul><li><strong>document.anchors</strong>：包含文档中所有带name特性的<code>&lt;a&gt;</code>元素；</li><li><strong>document.applets</strong>：包含文档中所有的<code>&lt;applet&gt;</code>元素，因为不再推荐使用<code>&lt;applet&gt;</code>元素，所以这个集合已经不建议使用了；</li><li><strong>document.forms</strong>：包含文档中所有的<code>&lt;form&gt;</code>元素，与<code>document.getElementsByTagName(&#39;form&#39;)</code>得到的结果相同；</li><li><strong>document.images</strong>：包含文档中所有的<code>&lt;img&gt;</code>元素，与<code>document.getElementsByTagName(&#39;img&#39;)</code>得到的结果相同；</li><li><strong>document.links</strong>：包含文档中所有带<code>href</code>特性的<code>&lt;a&gt;</code>元素。</li></ul>
          </div>

<h4 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h4><p>有一个<code>document</code>对象的功能已经存在很多年了，那就是将输出流写入到网页中的能力。这个能力体现在下列4个方法中：<code>write()</code>、<code>writeln()</code>、<code>open()</code>和<code>close()</code>。其中<code>write()</code>和<code>writeln()</code>方法都接受单个字符串参数，即要写入到输出流中的文本。<code>write()</code>会原样写入，而<code>writeln(</code>)则会在字符串的末尾添加一个换行符<code>（\n）</code>。<strong>在页面被加载的过程中，可以使用这两个方法向页面中动态地加入内容</strong>，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            The current date and time is:</span><br><span class="line">            <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">'&lt;strong&gt;'</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()).toString() + <span class="string">'&lt;/strong&gt;'</span>)</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子展示了在页面加载过程中输出当前日期和时间的代码。其中，日期被包含在一个<code>&lt;strong&gt;</code>元素中，就像在HTML页面中包含普通的文本一样。这样做会创建一个DOM元素，而且可以在将来访问该元素。通过<code>write()</code>和<code>writeln()</code>输出的任何HTML代码都将如此处理。<br>此外，还可以使用<code>write()</code>和<code>writeln()</code>方法动态地包含外部资源，例如JavaScript文件等。在包含JavaScript文件时，必须注意不能直接包含字符串<code>&quot;&lt;/script&gt;&quot;</code>，因为这会导致该字符串被解释为脚本块的结束，它后面的代码将无法执行。为避免这个问题，可以使用<code>&quot;&lt;\/script&gt;&quot;</code>来替代。<br>前面的例子使用<code>document.write()</code>在页面被呈现的过程中直接向其中输出了内容。如果在文档加载结束后再调用<code>document.write()</code>，那么输出的内容将会重写整个页面，如下面的例子所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>document.write() Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>The is some content that you won't get to see because it will be overwritten<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.write(<span class="string">'Hello World'</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>方法<code>open()</code>和<code>close()</code>分别用于打开和关闭网页的输出流。如果是在页面加载期间使用<code>write()</code>或<code>writeln()</code>方法，则不需要用到这两个方法。</p>
<h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>除了Document类型之外，Element类型就要算是Web编程中最常用的类型了。Element类型用于表现XML或HTML元素，提供了对元素签名、子节点及特性的访问。Element节点具有以下特征：</p>
<div class="note info">
            <ul><li><strong>nodeType</strong>的值为1；</li><li><strong>nodeName</strong>的值为元素的标签名；</li><li><strong>nodeValue</strong>的值为null；</li><li><strong>parentNode</strong>可能是Document或Element；</li><li>其子节点可能是<code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code>或<code>EntityReference</code>。</li></ul>
          </div>
<p>要访问元素的标签名，可以使用<code>nodeName</code>属性，也可以使用<code>tagName</code>属性；这两个属性会返回相同的值。以下面的元素为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以像下面这样获得这个元素及其标签名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(div.tagName)                    <span class="comment">// DIV</span></span><br><span class="line"><span class="built_in">console</span>.log(div.tagName === div.nodeName)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这里的元素标签名是<code>div</code>，它拥有一个值为<code>myDiv</code>的ID。可是，<code>div.tagName</code>实际上输出的是<code>&quot;DIV&quot;</code>而非<code>&quot;div&quot;</code>。<strong>在HTML中，标签名始终都是以全部大写表示；而在XML（有时候也包括XHTML）中，标签名则始终会与源代码中的保持一致。</strong>假如你不确定自己的脚本将会在HTML还是XML文档中执行，最好是在比较之前将标签名转换为相同的大小写形式，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (element.tagName.toLowerCase === <span class="string">'div'</span>) &#123;</span><br><span class="line">    <span class="comment">// 在此执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HTML元素的属性"><a href="#HTML元素的属性" class="headerlink" title="HTML元素的属性"></a>HTML元素的属性</h4><p>所有HTML元素都是由HTMLElement类型表示，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承自Element并添加了一些属性。添加的这些属性分别对应于每个HTML元素中都存在的下列标准特性。</p>
<div class="note info">
            <ul><li><strong>id</strong>：元素在文档中的唯一标识符；</li><li><strong>title</strong>：有关元素的附加说明信息，一般通过工具提示条显示出来；</li><li><strong>lang</strong>：元素内容的语言代码，很少使用；</li><li><strong>dir</strong>：语言的方向，值为<code>ltr</code>(从左到右)或<code>rtl</code>(从右到左)，也很少使用；</li><li><strong>className</strong>：与元素的class特性对应，即为元素指定的CSS类。没有将这个属性命名为class，是因为class是ECMAScript的保留字。</li></ul>
          </div>
<p>上述这些属性都可以用来取得或修改相应的特性值。以下面的HTML元素为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">class</span>=<span class="string">"bd"</span> <span class="attr">title</span>=<span class="string">"Body text"</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">dir</span>=<span class="string">"ltr"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>元素中指定的所有信息，都可以通过下列JavaScript代码取得：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(div.id)         <span class="comment">// myDiv</span></span><br><span class="line"><span class="built_in">console</span>.log(div.className)  <span class="comment">// bd</span></span><br><span class="line"><span class="built_in">console</span>.log(div.title)      <span class="comment">// Body text</span></span><br><span class="line"><span class="built_in">console</span>.log(div.lang)       <span class="comment">// en</span></span><br><span class="line"><span class="built_in">console</span>.log(div.dir)        <span class="comment">// ltr</span></span><br></pre></td></tr></table></figure>
<p>像下面这样通过为每个属性赋予新的值，也可以修改对应的每个特性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.id = <span class="string">"someOtherId"</span></span><br><span class="line">div.className = <span class="string">'ft'</span></span><br><span class="line">div.title = <span class="string">'Some other text'</span></span><br><span class="line">div.lang = <span class="string">'fr'</span></span><br><span class="line">div.dir = <span class="string">'rtl'</span></span><br></pre></td></tr></table></figure>

<h4 id="操作特性"><a href="#操作特性" class="headerlink" title="操作特性"></a>操作特性</h4><p>每个元素都有一或多个特性，这些特性的用途是给出相应元素或内容的附加信息。操作特性的DOM方法主要有三个：<code>getAttribute()</code>、<code>setAttribute()</code>和<code>removeAttribute()</code>。用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得特性</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">alert(div.getAttribute(<span class="string">"id"</span>));     <span class="comment">//"myDiv"</span></span><br><span class="line">alert(div.getAttribute(<span class="string">"class"</span>));     <span class="comment">//"bd"</span></span><br><span class="line"><span class="comment">//设置特性</span></span><br><span class="line">div.setAttribute(<span class="string">"lang"</span>, <span class="string">"fr"</span>);</span><br><span class="line"><span class="comment">//移除特性</span></span><br><span class="line">div.removeAttribute(<span class="string">"class"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>使用这三个方法时有一些注意事项，如下所示：</strong></p>
<div class="note info">
            <ul><li>传递给三个方法的特性名必须与实际的特性名相同，但是不区分大小写。例如，如果想要得到class特性值，应传入class而不是className，后者只有在通过对象属性访问特性时才用。</li><li>根据HTML5规范，自定义特性应该加上data-前缀以便验证。</li><li>只有公认的特性会以属性的形式添加到DOM对象中，而用户自定义特性则不会。</li><li>用户自定义特性，只能通过这三个方法来操作，无法通过对象属性形式来操作。</li><li>有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()方法返回的值并不相同。它们分别是：style特性和像onclick这样的事件处理程序。它们的属性值分别为对象和函数，但是通过getAttribute()方法返回的都是是字符串。</li><li>在使用setAttribute()为元素设置属性时，无论你传递的是什么类型的值，它都会将该值转换为字符串在设置到元素的属性上。所以对于一些特殊的属性，比如<code>&lt;input&gt;</code>标签上的check属性，只要出现了，无论你给它传递任何属性值（哪怕是空字符串也不行），它的属性值就是true。只有使用removeAttribute()移除check属性，才会让该属性值变为false。所以有的属性最好不要使用setAttribute()来设置。</li></ul>
          </div>
<p>下面的例子展示了公认特性与自定义特性的区别：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-special</span>=<span class="string">"ningning"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"myInput"</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(div.id)                             <span class="comment">// myDiv</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'id'</span>))             <span class="comment">// myDiv</span></span><br><span class="line"><span class="built_in">console</span>.log(div[<span class="string">'data-special'</span>])                <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'data-special'</span>))   <span class="comment">// ningning</span></span><br><span class="line">div.setAttribute(<span class="string">'class'</span>, <span class="string">'myClass'</span>)</span><br><span class="line">div.setAttribute(<span class="string">'data-other'</span>, <span class="string">'other'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(div.className)                      <span class="comment">// myClass</span></span><br><span class="line"><span class="built_in">console</span>.log(div[<span class="string">'data-other'</span>])                  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(div.getAttribute(<span class="string">'data-other'</span>))     <span class="comment">// other</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'myInput'</span>)</span><br><span class="line">input.setAttribute(<span class="string">'checked'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="built_in">console</span>.log(input.checked)                      <span class="comment">// true</span></span><br><span class="line">input.removeAttribute(<span class="string">'checked'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(input.checked)                      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="attributes属性"><a href="#attributes属性" class="headerlink" title="attributes属性"></a>attributes属性</h4><p><code>Element</code>类型是使用<code>attributes</code>属性的唯一一个DOM节点类型。<code>attributes</code>属性中包含一个<code>NamedNodeMap</code>类数组对象，与<code>NodeList</code>类似，也是一个“动态”的集合。元素的每一个特性都由一个<code>Attr</code>节点表示，每个节点都保存在<code>NamedNodeMap</code>对象中。<code>NamedNodeMap</code>对象拥有下列方法：</p>
<div class="note info">
            <p><code>attributes</code>属性中包含一系列<code>Attr</code>节点，每个节点的<code>nodeName</code>就是特性的名称，而节点的<code>nodeValue</code>就是特性值。</p><ul><li><strong>getNamedItem(name)</strong>：返回<code>nodeName</code>属性等于<code>name</code>的节点；</li><li><strong>removeNamedItem(name)</strong>：从列表中移除<code>nodeName</code>属性等于<code>name</code>的节点；</li><li><strong>setNamedItem(node)</strong>：向列表中添加节点，以节点的<code>nodeName</code>属性为索引；</li><li><strong>item(pos)</strong>：返回位于数字<code>pos</code>位置处的节点。</li></ul>
          </div>
<p>下面简单的演示一下getNamedItem()方法的几种使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接使用</span></span><br><span class="line"><span class="keyword">var</span> id = element.attributes.getNamedItem(<span class="string">'id'</span>).nodeValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后台自动调用getNamedItem()方法</span></span><br><span class="line"><span class="keyword">var</span> id = element.attributes[<span class="string">'id'</span>].nodeValue</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先取得特性节点，然后修改它的nodeValue</span></span><br><span class="line">element.attributes[<span class="string">'id'</span>].nodeValue = <span class="string">'someOtherId'</span></span><br></pre></td></tr></table></figure>
<p>一般来说，由于<code>attributes</code>属性上的方法不够方便，开发人员更多的会使用<code>getAttribute()</code>、<code>setAttribute()</code>和<code>removeAttribute()</code>方法。不过当你想要遍历元素的特性时，<code>attributes</code>属性倒是可以派上用场。在需要将DOM结构序列化为XML或HTML字符串时，多数都会涉及遍历元素特性。以下代码展示了如何迭代元素的每一个特性，然后将它们构造成<code>name=&#39;value&#39;</code>这样的字符串格式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttributes</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pairs = <span class="keyword">new</span> <span class="built_in">Array</span>(),</span><br><span class="line">        attrName,</span><br><span class="line">        attrValue,</span><br><span class="line">        i,</span><br><span class="line">        len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = element.attributes.length; i &lt; len; i++) &#123;</span><br><span class="line">        attrName = element.attributes[i].nodeName</span><br><span class="line">        attrValue = element.attributes[i].nodeValue</span><br><span class="line">        pairs.push(attrName + <span class="string">'="'</span> + attrValue + <span class="string">'"'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pairs.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>关于以上代码的运行结果，以下是两点必要的说明：</p><ul><li>针对attributes中包含的特性，不同浏览器返回的顺序不同。这些特性在XML或HTML代码中出现的先后顺序，不一定与它们出现在attributes中的顺序一致；</li><li>IE7及更早的版本会返回HTML元素中所有可能的特性，包括没有指定的特性。换句话说，返回100多个特性的情况会很常见。</li></ul>
          </div>
<p>针对IE7及更早版本中存在的问题，可以对上面的函数加以改进，让它只返回指定的特性。每个特性节点都有一个名为<code>specified</code>的属性，这个属性的值如果为true，则意味着要么是在HTML中指定了相应特性，要么是通过<code>setAttribute()</code>方法设置了该特性。在IE中，所有未设置过的特性的该属性值都为false，而在其他浏览器中根本不会为这类特性生成对应的特性节点（因此，在这些浏览器中，任何特性节点的specified值始终为true）。改进后的代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputAttributes</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pairs = <span class="keyword">new</span> <span class="built_in">Array</span>(),</span><br><span class="line">        attrName,</span><br><span class="line">        attrValue,</span><br><span class="line">        i,</span><br><span class="line">        len;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = element.attributes.length; i &lt; len; i++) &#123;</span><br><span class="line">        attrName = element.attributes[i].nodeName</span><br><span class="line">        attrValue = element.attributes[i].nodeValue</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (element.attributes[i].specified) &#123;</span><br><span class="line">            pairs.push(attrName + <span class="string">'="'</span> + attrValue + <span class="string">'"'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pairs.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><p>使用<code>document.createElement()</code>方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。<strong>这个标签名在HTML文档中不区分大小写，而在XML（包括XHTML）文档中，则是区分大小写的。</strong>在使用该方法创建新元素的同时，也为新元素设置了<code>ownerDocument</code>属性。例如，使用以下代码可以创建一个<code>&lt;div&gt;</code>元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br></pre></td></tr></table></figure>
<p>在IE中，可以以另一种方式使用<code>document.createElement()</code>，即为这个方法传入完整的元素标签，也可以包含属性，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'&lt;div id="myNewDiv" class="box"&gt;&lt;/div&gt;'</span>)</span><br></pre></td></tr></table></figure>
<p>这种方式有助于避开在IE7及更早版本中动态创建元素的某些问题。<strong>建议只在需要避开IE7及更早版本中存在的问题时，才使用这种方式！</strong></p>
<h4 id="查找元素的子节点"><a href="#查找元素的子节点" class="headerlink" title="查找元素的子节点"></a>查找元素的子节点</h4><div class="note info">
            <ul><li><strong>getElementById()</strong>: 根据id获取一个元素节点对象</li><li><strong>getElementsByTagName()</strong>: 通过标签名获取一组元素节点对象</li><li><strong>getElementsByName()</strong>: 通过<code>name</code>属性获取一组元素节点对象</li><li><strong>querySelector()</strong>: 返回文档中匹配指定 CSS 选择器的第一个元素节点对象</li><li><strong>querySelectorAll()</strong>: 返回文档中匹配指定 CSS 选择器的所有元素节点对象，返回 NodeList 对象。</li></ul>
          </div>

<h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><p>文本节点由Text类型表示，包含的是可以照字面量解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。Text节点具有以下特性：</p>
<div class="note info">
            <ul><li><code>nodeType</code>的值为3；</li><li><code>nodeName</code>的值为<code>#text</code>；</li><li><code>nodeValue</code>的值为节点所包含的文本；</li><li><code>parentNode</code>是一个Element；</li><li>不支持（没有）子节点。</li></ul>
          </div>
<p>可以通过<code>nodeValue</code>属性或<code>data</code>属性访问<code>Text</code>节点中包含的文本，这两个属性中包含的值相同。对<code>nodeValue</code>的修改也会通过<code>data</code>反映出来，反之亦然。</p>
<div class="note info">
            <p>使用下列方法可以操作节点中的文本：</p><ul><li><strong>appendData(text)</strong>：将text添加到节点的末尾；</li><li><strong>deleteData(offset, count)</strong>：从offset指定的位置开始删除count个字符；</li><li><strong>insertData(offset, text)</strong>：在offset指定的位置插入text；</li><li><strong>replaceData(offset, count, text)</strong>：用text替换从offset指定的位置开始到offset + count为止处的文本；</li><li><strong>splitText(offset)</strong>：从offset指定的位置将当前文本节点分成两个文本节点；</li><li><strong>substringData(offset, count)</strong>：提取从offset指定的位置开始到offset + count为止处的字符串。</li><li>除了这些方法之外，文本节点还有一个<code>length</code>属性，保存着节点中字符的数目。而且，<code>nodeValue.length</code>和<code>data.length</code>中也保存着同样的值。</li></ul>
          </div>
<h4 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h4><p>可以使用<code>document.createTextNode()</code>方法创建新文本节点，这个方法接受一个参数：要插入节点中的文本。</p>
<p>一般情况下，每个元素只有一个文本子节点。不过，在某些情况下也可能包含多个文本子节点，这种情况下，相邻的文本子节点会连起来显示，中间不会有空格</p>
<h4 id="规范化文本节点"><a href="#规范化文本节点" class="headerlink" title="规范化文本节点"></a>规范化文本节点</h4><p>DOM文档中存在相邻的同胞文本节点很容易导致混乱，因为分不清哪个文本节点表示哪个字符串。另外，DOM文档中出现相邻文本节点的情况也不在少数，于是就催生了一个能够将相邻文本节点合并的方法。这个方法是由Node类型定义的（因而在所有节点类型中都存在），名叫<code>normalize()</code>。<strong><code>normalize()</code>方法移除空的文本节点，并连接相邻的文本节点。</strong>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.normalize()</span><br></pre></td></tr></table></figure>
<h4 id="分割文本节点"><a href="#分割文本节点" class="headerlink" title="分割文本节点"></a>分割文本节点</h4><p>Text类型提供了一个作用与<code>normalize()</code>相反的方法：<code>splitText()</code>。这个方法会将一个文本节点分成两个文本节点，即按照指定的位置分割<code>nodeValue</code>值。原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本。这个方法会返回一个新文本节点，该节点与原节点的<code>parentNode</code>相同。示例如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">element.className = <span class="string">"message"</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello world!"</span>); </span><br><span class="line">element.appendChild(textNode); </span><br><span class="line"> </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(element); </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> newNode = element.firstChild.splitText(<span class="number">5</span>);</span><br><span class="line">alert(element.firstChild.nodeValue);    <span class="comment">//"Hello"</span></span><br><span class="line">alert(newNode.nodeValue);               <span class="comment">//" world!"</span></span><br><span class="line">alert(element.childNodes.length);       <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h4 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h4><p>注释在DOM中是通过Comment类型来表示的。Comment节点具有下列特征：</p>
<div class="note info">
            <ul><li><code>nodeType</code>的值为8；</li><li><code>nodeName</code>的值为#comment；</li><li><code>nodeValue</code>的值是注释的内容；</li><li><code>parentNode</code>可能是Document或Element；</li><li>不支持（没有）子节点。</li></ul>
          </div>
<p>Comment类型与Text类型继承自相同的基类，因此它拥有除<code>splitText()</code>之外的所有字符串操作方法。与Text类型相似，也可以通过<code>nodeValue</code>或<code>data</code>属性来取得注释的内容。</p>
<p>使用<code>document.createComment()</code>并为其传递注释文本也可以创建注释节点。</p>
<h4 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h4><p>CDATASection类型只针对基于XML的文档，表示的是CDATA区域。与Comment类似，CDATASection类型继承自Text类型，因此拥有除<code>splitText()</code>之外的所有字符串操作方法。CDATASection节点具有下列特征：</p>
<div class="note info">
            <ul><li><code>nodeType</code>的值为4；</li><li><code>nodeName</code>的值为#cdata-section；</li><li><code>nodeValue</code>的值是CDATA区域的内容；</li><li><code>parentNode</code>可能是Document或Element；</li><li>不支持（没有）子节点。</li></ul>
          </div>
<p>在真正的XML文档中，可以使用<code>document.createCDataSection()</code>来创建CDATA区域，只需为其传入节点的内容即可。</p>
<h3 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h3><p>DocumentType类型在Web浏览器中并不常用，仅有Firefox、Safari和Opera支持它。DocumentType包含着与文档的<code>doctype</code>有关的所有信息，它具有下列特征：</p>
<div class="note info">
            <ul><li><code>nodeType</code>的值为<code>10</code>；</li><li><code>nodeName</code>的值为<code>doctype</code>的名称；</li><li><code>nodeValue</code>的值为<code>null</code>；</li><li><code>parentNode</code>是<code>Document</code>；</li><li>不支持（没有）子节点。</li></ul>
          </div>
<p>DOM1级中，DocumentType对象不能动态创建，而只能通过解析文档代码的方式来创建。支持它的浏览器会把DocumentType对象保存在<code>document.type</code>中。</p>
<div class="note info">
            <p>DOM1级描述了DocumentType对象的3个属性：</p><ul><li><strong>name</strong>：表示文档类型的名称；</li><li><strong>entities</strong>：由文档类型描述的实体的<code>NamedNodeMap</code>对象；</li><li><strong>notations</strong>：由文档类型描述的符号的<code>NamedNodeMap</code>对象。</li></ul>
          </div>
<p>通常，浏览器中的文档使用的都是HTML或XHTML文档类型，因而<code>entities</code>和<code>notations</code>都是空列表（列表中的项来自行内文档类型声明）。但不管怎样，只有<code>name</code>属性是有用的。这个属性中保存的是文档类型的名称，也就是出现在<code>&lt;!DOCTYPE</code>和<code>&gt;</code>之间的文本。</p>
<h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>在所有节点类型中，只有DocumentFragment在文档中没有对应的标记。DOM规定文档片段（document fragment）是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。DocumentFragment节点具有下列特征：</p>
<div class="note info">
            <ul><li><code>nodeType</code>的值为<code>11</code>；</li><li><code>nodeName</code>的值为<code>#document-fragment</code>；</li><li><code>nodeValue</code>的值为<code>null</code>；</li><li><code>parentNode</code>是值为<code>null</code>；</li><li>其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EntityReference。</li></ul>
          </div>
<p>虽然不能把文档片段直接添加到文档中，但可以将它作为一个“仓库”来使用，即可以在里面保存将来可能会添加到文档中的节点。要创建文档片段，可以使用<code>document.createDocumentFragment()</code>方法，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br></pre></td></tr></table></figure>
<p>文档片段继承了Node的所有方法，通常用于执行那些针对文档的DOM操作。如果将文档中的节点添加到文档片段中，就会从文档树中移除该节点，也不会从浏览器中再看到该节点。添加到文档片段中的新节点同样也不属于文档树。可以通过<code>appendChild()</code>或<code>insertBefore()</code>将文档片段中的内容添加到文档中。在将文档片段作为参数传递给这两个方法时，实际上只会将文档片段的所有字节点添加到相应位置上，文档片段本身永远不会称为文档树的一部分。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"myList"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    var fragment = document.createDocumentFragment();</span><br><span class="line">    var ul = document.getElementById('myList');</span><br><span class="line">    var li = null;</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">        li = document.createElement('li');</span><br><span class="line">        li.appendChild(document.createTextNode('Item' + (i+1)));</span><br><span class="line"><span class="css">        <span class="selector-tag">fragment</span><span class="selector-class">.appendChild</span>(<span class="selector-tag">li</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-tag">ul</span><span class="selector-class">.appendChild</span>(<span class="selector-tag">fragment</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><p>元素的特性在DOM中以Attr类型来表示。在所有浏览器中，都可以访问Attr类型的构造函数和原型。从技术角度讲，特性就是存在于元素的<code>attributes</code>属性中的节点。特性节点具有下列特征：</p>
<div class="note info">
            <ul><li><code>nodeType</code>的值为<code>2</code>；</li><li><code>nodeName</code>的值为特性的名称；</li><li><code>nodeValue</code>的值为特性的值；</li><li><code>parentNode</code>是值为null；</li><li>在HTML中不支持（没有）子节点；</li><li>在XML中子节点可以是Text或EntityReference。</li></ul>
          </div>
<p>尽管它们也是节点，但特性却不被认为是DOM文档树的一部分。开发人员最常使用的是<code>getAttribute()</code>、<code>setAttribute()</code>和<code>removeAttribute()</code>方法，很少直接引用特性节点.</p>
<div class="note info">
            <p>Attr对象有3个属性：</p><ul><li><code>name</code>：特性的名称，与<code>nodeName</code>的值相同；</li><li><code>value</code>：特性的值，与<code>nodeValue</code>的值相同；</li><li><code>specified</code>：是一个布尔值，用以区别特性是在代码中指定的，还是默认的。</li></ul>
          </div>
<p>使用<code>document.createAttribute()</code>并传入特性的名称可以创建新的特性节点。例如，要为元素添加<code>align</code>特性，可以使用下列代码:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> attr = <span class="built_in">document</span>.createAttribute(<span class="string">'align'</span>)</span><br><span class="line">attr.value = <span class="string">'left'</span></span><br><span class="line"></span><br><span class="line">element.attributes.setNamedItem(attr)</span><br></pre></td></tr></table></figure>
<h2 id="DOM操作技术"><a href="#DOM操作技术" class="headerlink" title="DOM操作技术"></a>DOM操作技术</h2><h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><p>创建动态脚本有两种方式：插入外部文件和直接插入JavaScript代码。</p>
<h4 id="插入外部文件"><a href="#插入外部文件" class="headerlink" title="插入外部文件"></a>插入外部文件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"></span><br><span class="line">    script.type = <span class="string">'text/javascript'</span></span><br><span class="line">    script.src = url</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadScript(<span class="string">'clent.js'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="插入JavaScript代码"><a href="#插入JavaScript代码" class="headerlink" title="插入JavaScript代码"></a>插入JavaScript代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line"></span><br><span class="line">    script.type = <span class="string">'text/javascript'</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        script.appendChild(<span class="built_in">document</span>.createTextNode(code))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        script.text = code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadScriptString(<span class="string">'function sayHi () &#123;console.log("hi")&#125;'</span>)</span><br></pre></td></tr></table></figure>
<p>以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。实际上，这样执行代码与在全局作用域中把相同的字符串传递给<code>eval()</code>是一样的。</p>
<h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>能够把CSS样式包含到HTML页面中的元素有两个。其中，<code>&lt;link&gt;</code>元素用于包含来自外部的文件，而<code>&lt;style&gt;</code>元素用于指定嵌入的样式。与动态脚本类似，所谓动态样式是指在页面刚加载时不存在的样式；动态样式是在页面加载完成后动态添加到页面中的。</p>
<p>创建动态样式也有两种方式：通过<code>&lt;link&gt;</code>和通过<code>&lt;style&gt;</code>。</p>
<h4 id="通过link"><a href="#通过link" class="headerlink" title="通过link"></a>通过link</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyle</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">'link'</span>)</span><br><span class="line"></span><br><span class="line">    link.rel = <span class="string">'stylesheet'</span></span><br><span class="line">    link.type = <span class="string">'text/css'</span></span><br><span class="line">    link.href = url</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]</span><br><span class="line">    head.appendChild(link)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadStyle(<span class="string">'style.css'</span>)</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>注意事项：</p><ul><li>必须将<code>&lt;link&gt;</code>元素添加到<code>&lt;head&gt;</code>而不是<code>&lt;body&gt;</code>元素，才能保证在所有浏览器中的行为一致；</li><li>加载外部样式文件的过程是异步的。</li></ul>
          </div>

<h4 id="通过style"><a href="#通过style" class="headerlink" title="通过style"></a>通过style</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadStyleString</span> (<span class="params">css</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> style = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span><br><span class="line"></span><br><span class="line">    style.type = <span class="string">'text/css'</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        style.appendChild(<span class="built_in">document</span>.createTextNode(css))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        style.styleSheet.cssText = css</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementByTagName(<span class="string">'head'</span>)[<span class="number">0</span>]</span><br><span class="line">    head.appendChild(link)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadStyleString(<span class="string">'body &#123;background-color: red&#125;'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h3><p>为了方便构建表格，HTML DOM为<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tr&gt;</code>元素添加了一些属性和方法：</p>
<div class="note info">
            <p>为<code>&lt;table&gt;</code>元素添加的属性和方法：</p><ul><li><code>caption</code>：保存着对<code>&lt;caption&gt;</code>元素（如果有）的引用；</li><li><code>tHead</code>：保存着对<code>&lt;thead&gt;</code>元素（如果有）的引用；</li><li><code>tBodies</code>：是一个<code>&lt;tbody</code>&gt;元素的HTMLCollection；</li><li><code>tFoot</code>：保存着对<code>&lt;tfoot&gt;</code>元素（如果有）的引用；</li><li><code>rows</code>：是一个表格中所有行的<code>HTMLCollection</code>；</li><li><code>createCaption()</code>：创建<code>&lt;caption&gt;</code>元素，将其放到表格中，返回引用；</li><li><code>createTHead()</code>：创建<code>&lt;thead&gt;</code>元素，将其放到表格中，返回引用；</li><li><code>createTFoot()</code>：创建<code>&lt;tfoot&gt;</code>元素，将其放到表格中，返回引用；</li><li><code>deleteCaption()</code>：删除<code>&lt;caption&gt;</code>元素；</li><li><code>deleteTHead()</code>：删除<code>&lt;thead&gt;</code>元素；</li><li><code>deleteTFoot()</code>：删除<code>&lt;tfoot&gt;</code>元素；</li><li><code>deleteRow(pos)</code>：删除指定位置的行；</li><li><code>insertRow(pos)</code>：向rows集合中的指定位置插入一行。</li></ul><hr><p>为<code>&lt;tbody&gt;</code>元素添加的属性和方法：</p><ul><li><strong>rows</strong>：保存着<code>&lt;tbody&gt;</code>元素中行的<code>HTMLCollection</code>；</li><li><strong>deleteRow(pos)</strong>：删除指定位置的行；</li><li><strong>insertRow(pos)</strong>：向rows集合中的指定位置插入一行，返回对新插入行的引用。</li></ul><hr><p>为<code>&lt;tr&gt;</code>元素添加的属性和方法：</p><ul><li><strong>cells</strong>：保存着<code>&lt;tr&gt;</code>元素中单元格的<code>HTMLCollection</code>；</li><li><strong>deleteCell(pos)</strong>：删除指定位置的单元格；</li><li><strong>insertCell(pos)</strong>：向<code>cells</code>集合中的指定位置插入一个单元格，返回对新插入单元格的引用。</li></ul>
          </div>
<p><strong>想创建下面的HTML表格：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"100%"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, col 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, col 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, col 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, col 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>创建的代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> table = <span class="built_in">document</span>.createElement(<span class="string">'table'</span>)</span><br><span class="line">table.border = <span class="number">1</span></span><br><span class="line">table.width = <span class="string">'100%'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="built_in">document</span>.createElement(<span class="string">'tbody'</span>)</span><br><span class="line">table.appendChild(tbody)</span><br><span class="line"></span><br><span class="line">tbody.insertRow(<span class="number">0</span>)</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">0</span>)</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'row 1, col 1'</span>))</span><br><span class="line">tbody.rows[<span class="number">0</span>].insertCell(<span class="number">1</span>)</span><br><span class="line">tbody.rows[<span class="number">0</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'row 1, col 2'</span>))</span><br><span class="line"></span><br><span class="line">tbody.insertRow(<span class="number">1</span>)</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">0</span>)</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">0</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'row 2, col 1'</span>))</span><br><span class="line">tbody.rows[<span class="number">1</span>].insertCell(<span class="number">1</span>)</span><br><span class="line">tbody.rows[<span class="number">1</span>].cells[<span class="number">1</span>].appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'row 2, col 2'</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(table)</span><br></pre></td></tr></table></figure>

<h3 id="使用Nodelist"><a href="#使用Nodelist" class="headerlink" title="使用Nodelist"></a>使用Nodelist</h3><p>理解<code>Nodelist</code>及其“近亲”<code>NamedNodeMap</code>和<code>HTMLCollection</code>，是从整体上透彻理解DOM的关键所在。这三个集合都是“动态的”；换句话说，每当文档结构发生变化时，它们都会得到更新。因此，它们始终都会保存着最新、最准确的信息。从本质上说，所有<code>Nodelist</code>对象都是在访问DOM文档时实时运行的查询。</p>
<p>例如，下列代码会导致无限循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>),</span><br><span class="line">    i,</span><br><span class="line">    div;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; divs.length; i++) &#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行代码会取得文档中所有<code>&lt;div</code>元素的<code>HTMLCollection</code>。由于这个集合是“动态的”，因此只要有新<code>&lt;div&gt;</code>元素被添加到页面中，这个元素也会被添加到该集合中。浏览器不会将所有集合都保存在一个列表中，而是在下一次访问时再更新集合。结果，在遇到上例中所示的循环代码时，就会导致一个有趣的问题。每次循环都要对条件<code>i&lt;divs.length</code>求值，意味着会运行取得所有<code>&lt;div&gt;</code>元素的查询。考虑到循环体每次都会创建一个新<code>&lt;div&gt;</code>元素并将其添加到文档中，因此<code>divs.length</code>的值在每次循环后都会递增。既然<code>i</code>与<code>divs.length</code>每次都会同时递增，结果他们的值永远不会相等。<br>如果想要迭代一个<code>NodeList</code>，最好是使用<code>length</code>属性初始化第二个变量，然后将迭代器与该变量进行比较，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>),</span><br><span class="line">    i,</span><br><span class="line">    div;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; len = divs.length;i &lt; len; i++) &#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中初始化了第二个变量<code>len</code>。由于<code>len</code>中保存着对<code>divs.length</code>在循环开始时的一个快照。因此就会避免上一个例子中出现的无限循环问题。</p>
<p>一般来说，应该尽量减少访问<code>NodeList</code>的次数，因为每次访问<code>NodeList</code>，都会运行一次基于文档的查询。所以应该考虑将<code>NodeList</code>中取得的值缓存起来。</p>
]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>第二十一章 Ajax与Comet</title>
    <url>/blog/2020/06/26/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Ajax%E4%B8%8EComet/</url>
    <content><![CDATA[<p>Ajax的核心是XMLHttpRequest对象（简称XHR），这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。XHR为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器取得更多信息，意味着用户单击后，可以不必刷新页面也能取得新数据。也就是说，可以使用XHR对象取得新数据，然后再通过DOM将新数据插入到页面中。</p>
<p>熟练使用XHR对象已经称为所有Web开发人员必须掌握的一项技能。</p>
<p>具体参考师兄博客：<a href="https://aadonkeyz.com/posts/5ffed448/" target="_blank" rel="noopener">https://aadonkeyz.com/posts/5ffed448/</a></p>
]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript高级程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一章 DOM扩展</title>
    <url>/blog/2020/07/06/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/DOM%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<p><strong>关于DOM全面的干货博客：<a href="https://www.cnblogs.com/sugartang/p/11342453.html" target="_blank" rel="noopener">https://www.cnblogs.com/sugartang/p/11342453.html</a></strong></p>
<h2 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h2><p>Selectors API是由W3C发起指定的一个标准，致力于让浏览器原生支持CSS查询。Selectors API Level1级的核心是两个方法：<code>querySelector()</code>和<code>querySelectorAll()</code>。在兼容的浏览器中，可以通过Document及Element类型的实例调用它们。目前已完全支持Selectors API Level1级的浏览器有IE8+、Firefox3.5+、Safari3.1+、Chrome和Opera10+。</p>
<h3 id="querySelector-方法"><a href="#querySelector-方法" class="headerlink" title="querySelector( )方法"></a>querySelector( )方法</h3><p>该方法接受单个CSS选择符作为参数，返回与该模式匹配的第一个元素，如果没有找到匹配的元素则返回<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得body元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得ID为"myDiv"元素</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="built_in">document</span>.querySelector(<span class="string">'#myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类为"selected"的第一个元素</span></span><br><span class="line"><span class="keyword">var</span> selected = <span class="built_in">document</span>.querySelector(<span class="string">'.selected'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得类为"button"的第一个图像元素</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'img.button'</span>)</span><br></pre></td></tr></table></figure>
<p>通过Document类型调用<code>querySelector()</code>方法时，会在文档元素的范围内查找匹配的元素。而通过Element类型调用<code>querySelector()</code>方法时，只会在该元素后代元素的范围内查找匹配的元素。CSS选择符可以简单也可以复杂，视情况而定。如果传入了不被支持的选择符，<code>querySelector()</code>方法会抛出错误。</p>
<h3 id="querySelectorAll-方法"><a href="#querySelectorAll-方法" class="headerlink" title="querySelectorAll( )方法"></a>querySelectorAll( )方法</h3><p><code>querySelectorAll()</code>方法接受的参数与<code>querySelector()</code>方法一样，都是一个CSS选择符，但返回的是所有匹配元素而不仅仅是一个元素。这个方法返回的是一个带有<code>NodeList</code>所有属性和方法的一个快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用<code>NodeList</code>对象通常会引起的大多数性能问题。</p>
<p><code>querySelectorAll()</code>的用法类似于<code>querySelector()</code>，就不介绍了。</p>
<h3 id="matchesSelector-方法"><a href="#matchesSelector-方法" class="headerlink" title="matchesSelector( )方法"></a>matchesSelector( )方法</h3><p>Selectors API Level2级规范为Element类型新增了一个方法<code>matchesSelector()</code>。这个方法接收一个参数，即CSS选择符，如果调用元素与该选择符匹配，返回<code>true</code>；否则返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.matchesSelector(<span class="string">'body.page1'</span>)) &#123;</span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在取得某个元素引用的情况下，使用这个方法能够方便地检测它是否会被<code>querySelector()</code>或<code>querySelectorAll()</code>方法返回。</p>
<p>截止2011年年中，还没有浏览器支持<code>matchesSelector()</code>方法，不过，也有一些实验性的实现。IE9+通过<code>msMatchesSelector()</code>支持该方法，Firefox3.6+通过<code>mozMatchesSelector()</code>支持该方法，Chrome通过`webkitMatchesSelector()支持该方法。因此若是想使用该方法，最好是编写一个包装函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Element.prototype.matchesSelector) &#123;</span><br><span class="line">    Element.prototype.matchesSelector = </span><br><span class="line">        Element.prototype.mozMatchesSelector ||</span><br><span class="line">        Element.prototype.msMatchesSelector || </span><br><span class="line">        Element.prototype.oMatchesSelector || </span><br><span class="line">        Element.prototype.webkitMatchesSelector ||</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> matches = (<span class="keyword">this</span>.document || <span class="keyword">this</span>.ownerDocument).querySelectorAll(s),</span><br><span class="line">                i = matches.length</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; matches.item(i) !== <span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> i &gt; <span class="number">-1</span>     </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><p>对于元素间的空格，IE9及之前的版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用<code>childNodes</code>和<code>firstChild</code>等属性时的行为不一致，为了弥补这一差异，而同时又要保持DOM规范不变，Element Traversal规范新定义了一组属性：</p>
<div class="note info">
            <ul><li><strong>childElementCount</strong>: 返回子元素（不包括文本节点和注释）的个数；</li><li><strong>firstElementChild</strong>: 指向第一个子元素；</li><li><strong>lastElementChild</strong>: 指向最后一个子元素；</li><li><strong>previousElementSibling</strong>: 指向前一个同辈元素；</li><li><strong>nextElementSibling</strong>: 指向后一个同辈元素</li></ul>
          </div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child = element.firstElementChild;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (child !== element.lastElementChild) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(child);</span><br><span class="line">    child = child.nextElementSibling;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="与类相关的扩充"><a href="#与类相关的扩充" class="headerlink" title="与类相关的扩充"></a>与类相关的扩充</h3><div class="note info">
            <ul><li><strong>getElementsByClassName()</strong>: 该方法接收一个参数，即一个包含一个或多个类名的字符串，返回带有指定类的所有元素的<code>HTMLCollection</code>，传入多个类名时，类名的先后顺序不重要，该方法可以通过<code>document</code>对象及所有HTML元素调用；</li><li><strong>classList</strong>: 该属性是一个只读属性，保存着一个元素的类属性的实时<code>DOMTokenList</code>集合。<code>DOMTokenList</code>有一个表示自己包含多少元素的<code>length</code>属性，而要取得每一个元素可以使用方括号语法或<code>item()</code>方法；</li><li><strong>classList.add(value)</strong>：将给定的字符串值添加到<code>classList</code>中，如果值已经存在了，就不添加了；</li><li><strong>classList.contains(value)</strong>： 表示<code>classList</code>中是否已经存在给定的值，如果存在则返回<code>true</code>，否则返回<code>false</code>；</li><li><strong>classList.remove(value)</strong>：从<code>classList</code>中删除给定的字符串；</li><li><strong>classList.toggle(value)</strong>：如果<code>classList</code>中已经存在给定的值，删除它。如果classList中没有给定的值，添加它。</li></ul>
          </div>

<h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><p>HTML5添加了辅助管理DOM焦点的功能。首先就是<code>document.activeElement</code>属性，这个属性始终会引用DOM中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入(通常是通过按Tab键)和在代码中调用<code>focus()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>)</span><br><span class="line">button.focus()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.activeElement === button)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，文档加载期间，<code>document.activeElement</code>的值为<code>null</code>。文档刚刚加载完成时，<code>document.activeElement</code>中保存的是<code>document.body</code>元素的引用。通过检测文档是否获得了焦点，可以知道用户是不是正在与页面交互。</p>
<p>另外就是新增了<code>document.hasFocus()</code>方法，这个方法用于确定文档是否获得了焦点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>)</span><br><span class="line">button.focus()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.hasFocus())  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a>HTMLDocument的变化</h3><p>HTML5扩展了<code>HTMLDocument</code>，为<code>document</code>对象新增了三个属性：</p>
<div class="note info">
            <ul><li><strong>readyState</strong>：该属性有两个可能的值：<code>loading</code>和<code>complete</code>。通过该属性可以知道文档是否加载完成；</li><li><strong>compatMode</strong>：在标准模式下，<code>document.compatMode</code>的值等于<code>CSS1Compat</code>，而在混杂模式下，<code>document.compatMode</code>的值等于<code>BackCompat</code>；</li><li><strong>head</strong>：该属性保存着<code>&lt;head&gt;</code>元素的引用。</li></ul>
          </div>
<h3 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h3><div class="note info">
            <p>HTML5新增了两个个与文档字符集有关的属性：</p><ul><li><strong>charset</strong>：表示文档中实际使用的字符集，也可以用来指定新字符集。默认情况下，这个属性的值为<code>&quot;UTF-16&quot;</code>，但可以通过<code>&lt;meta&gt;</code>元素、响应头部或直接设置<code>charset</code>属性修改这个值；</li><li><strong>defaultCharset</strong>：表示根据默认浏览器及操作系统的设置，当前文档默认的字符集应该是什么。如果文档没有使用默认的字符集，那<code>charset</code>和<code>defaultCharset</code>属性的值可能会不一样。</li></ul>
          </div>
<h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><p>HTML5规定可以为元素添加非标准的属性，但要添加前缀<code>data-</code>，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以<code>data-</code>开头即可。</p>
<p>添加了自定义属性之后，可以通过元素的<code>dataset</code>属性来访问/修改自定义属性的值。<code>dataset</code>属性的值是<code>DOMStringMap</code>的一个实例，也就是一个键值对的映射。</p>
<div class="note info">
            <p>自定义数据属性转化为<code>DOMStringMap</code>的键值对时会遵循以下规则：</p><ul><li>前缀<code>data-</code>被去除（包括减号）；</li><li>对于每个在ASCII小写字母a到z前面的减号，会被去除，并且字母会转变成对应的大写字母；</li><li>其他字符（包含其他减号）都不发生变化。</li></ul>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">data-app-id</span>=<span class="string">"12345"</span> <span class="attr">data-my-name</span>=<span class="string">"Nicholas"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(div.dataset.appId)</span><br><span class="line"><span class="built_in">console</span>.log(div.dataset.myName)</span><br><span class="line"></span><br><span class="line">div.dataset.appId = <span class="number">23456</span></span><br><span class="line">div.dataset.myName = <span class="string">'Michael'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会为元素添加data-new-attr属性，其值为"new"</span></span><br><span class="line">div.dataset.newAttr = <span class="string">'new'</span></span><br></pre></td></tr></table></figure>
<h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><p>虽然DOM为操作节点提供了细致入微的控制手段，但在需要给文档插入大量新HTML标记的情况下，通过DOM操作仍然非常麻烦，因为不仅要创建一系列DOM节点，而且还要小心地按照正确的顺序把他们连接起来。相对而言，使用插入标记的技术，直接插入HTML字符串不仅更简单，速度也更快。</p>
<h4 id="innerHTML属性"><a href="#innerHTML属性" class="headerlink" title="innerHTML属性"></a>innerHTML属性</h4><p>在读模式下，<code>innerHTML</code>属性返回与调用元素的所有子节点（包括元素、注释和文本节点）对应的HTML标记。在写模式下，<code>innerHTML</code>会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。</p>
<p>需要注意的是，为<code>innerHTML</code>设置的值与返回的值不一定相同，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.innerHTML = <span class="string">"hello &amp; welcome,&lt;b&gt;\"reader\"&lt;/b&gt;"</span></span><br><span class="line"><span class="built_in">console</span>.log(div.innerHTML)  <span class="comment">// hello &amp;amp; welcome,&lt;b&gt;"reader"&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>使用innerHTML的限制：</p><ul><li>不可以使用<code>innerHTML</code>插入<code>&lt;script&gt;</code>标签；</li><li>并不是所有元素都支持<code>innerHTML</code>属性，不支持的元素有：<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;frameset&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;html&gt;</code>、<code>&lt;style&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tfoot&gt;</code>和<code>&lt;tr&gt;</code>。</li></ul>
          </div>
<h4 id="outerHTML属性"><a href="#outerHTML属性" class="headerlink" title="outerHTML属性"></a>outerHTML属性</h4><p>在读模式下，<code>outerHTML</code>返回调用它的元素及所有子节点的HTML标签。在写模式下，<code>outerHTML</code>会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。</p>
<p>其他方面，<code>outerHTML</code>属性与<code>innerHTML</code>属性相同。</p>
<h4 id="insertAdjacentHTML-方法"><a href="#insertAdjacentHTML-方法" class="headerlink" title="insertAdjacentHTML( )方法"></a>insertAdjacentHTML( )方法</h4><div class="note info">
            <p>插入标记的最后一个新增方式是<code>insertAdjacentHTML()</code>方法。它接收两个参数：插入位置和要插入的HTML文本。第一个参数必须是下列字符串之一：</p><ul><li><strong>beforebegin</strong>：在当前元素之前插入一个紧邻的同辈元素；</li><li><strong>afterbegin</strong>：在当前元素的第一个子元素之前再插入新的子元素；</li><li><strong>beforeend</strong>：在当前元素的最后一个子元素之后再插入新的子元素；</li><li><strong>afterend</strong>：在当前元素之后插入一个紧邻的同辈元素。</li></ul>
          </div>
<h3 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView( )方法"></a>scrollIntoView( )方法</h3><p>示例参考博客： <a href="https://blog.csdn.net/hyl94/article/details/77472154/" target="_blank" rel="noopener">https://blog.csdn.net/hyl94/article/details/77472154/</a><br>该方法可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。</p>
<div class="note info">
            <p>该方法的参数比较有意思，如下所示：</p><ul><li>如果传递一个对象，该对象包含如下属性：<ul><li><strong>behavior</strong>：定义缓动动画，<code>&quot;auto&quot;</code>、<code>&quot;instant&quot;</code>或<code>&quot;smooth&quot;</code>，默认为<code>&quot;auto&quot;</code>；</li><li><strong>block</strong>：定义垂直对齐，<code>&quot;start&quot;</code>、<code>&quot;center&quot;</code>、<code>&quot;end&quot;</code>或<code>&quot;nearest&quot;</code>，默认为<code>&quot;start&quot;</code>；</li><li><strong>inline</strong>：定义水平对齐，<code>&quot;start&quot;</code>、<code>&quot;center&quot;</code>、<code>&quot;end&quot;</code>或<code>&quot;nearest&quot;</code>，默认为<code>&quot;nearest&quot;</code>。</li></ul></li><li>如果传递<code>true</code>或不传递参数，则此时相当于传递了<code>{block: &quot;start&quot;, inline: &quot;nearest&quot;}</code>；</li><li>如果传递<code>false</code>，则此时相当于传递了<code>{block: &quot;end&quot;, inline: &quot;nearest&quot;}</code>。</li></ul>
          </div>]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 变量、作用域和内存问题</title>
    <url>/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>ECMAScript变量可能包含不同数据类型的值：基本类型值和引用类型值。<br>基本类型值：指的是简单的数据段，Undefined、Null、Boolean、Number和String这五种基本数据类型是按值访问的。<br>引用类型值：指的是那些可能由多个值构成的对象，引用类型的值是保存在内存中的对象。<br>与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p>
<h3 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h3><p>引用类型的值可以动态地添加属性和方法，也可以改变和删除其属性和方法，但是不能给基本类型的值添加属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为引用类型的值添加属性并给属性赋值</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">// "Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为基本类型的值添加属性会返回undefined,但是不会报错</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Nicholas"</span>;</span><br><span class="line">name.age = <span class="number">27</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name.age);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><p>基本类型值与引用类型值复制变量是不同的。<br>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上，这两个变量可以参与任何操作而不会相互影响。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> num2 = num1;  <span class="comment">// num1与num2的值都是5，但是他们两个相互之间没有影响</span></span><br></pre></td></tr></table></figure>

<p>如果一个变量向另一个变量复制引用类型的值，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，但是这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制结束后，两个变量实际上将引用同一个对象，改变一个变量，就会影响另一个变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line">obj1.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>ECMAScript中所有函数的参数都是按值传递的。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数），<br>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = addTen(count);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(result);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p>typeof 可以检测基本数据类型，instanceof可以检测引用数据类型。<br>根据规定，所有引用类型的值都是Object的实例，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true，<br>使用instanceof操作符检测基本类型的值，则该操作符始终会返回false。</p>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。<br>全局执行环境是最外围的一个执行环境，在Web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。<br>当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。<br>作用域链的前端始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象，活动对象在一开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。<br>作用域链中的下一个变量对象包含（外部）环境，而再下一个变量对象则来自下一个包含环境，这样，一直延续到全局执行环境，全局执行环境中的变量对象始终都是作用域链中的最后一个对象。<br>标识符解析是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直到找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(color == <span class="string">"blue"</span>)&#123;</span><br><span class="line">        color = <span class="string">"red"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        color == <span class="string">"grey"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Color is "</span> + color);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Color is red</span><br></pre></td></tr></table></figure>

<p>上面例子中的函数changColor()的作用域链的中包含两个对象，它自己的变量对象（其中定义着arguments）和全局环境的变量对象。<br>作用域链为它自己的变量对象 ——&gt; 全局环境的变量对象</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除，在两种情况下会发生这种现象，出现以下两种现象时，执行流进入下列任何一个语句时，作用域链就会得到加长：</p>
<ul>
<li>try-catch 语句的 catch 块；</li>
<li>with 语句。</li>
</ul>
<p>这两个语句都会在作用域的前端添加一个变量对象，对with语句来说，会将指定的对象添加到作用域链中；<br>对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。<br>如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">    <span class="keyword">with</span>(location)[</span><br><span class="line">        <span class="keyword">var</span> url = href + qs;</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加进了作用域链的前端，buildUrl()函数中定义了一个变量qs，当在with语句中引用变量href时（实际引用的是location.href），可以在当前执行环境的变量对象中找到，当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中，因此with内部的url就成了函数执行环境的一部分，可以作为函数的值返回。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>JavaScript没有块级作用域，在其他类C的语言中，由花括号封闭的代码都有自己的作用域（用ECMAScript的话来说就是他们自己的执行环境）。<br>因而支持根据条件来定义变量，例如，下面的代码在JavaScript中并不会得到想象中的结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>

<p>这个例子，如果是在C、C++或Java中，color会在if语句执行完毕后被销毁，但是在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。<br>使用for语句时也会发生这样的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">    doSomething(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>for循环执行结束后，由for语句创建的i依旧存在于循环外部的执行环境中。<br><strong>解决这种办法ES6使用let声明变量，用let声明可以将作用域限制在当前块中。</strong><br><strong>声明变量：</strong>使用var声明的变量会自动被添加进最接近的环境中，在函数内部，最接近的环境就是函数的局部环境，在with语句中，最接近的环境是函数环境，如果初始化变量时没有使用var声明，该变量会自动添加进全局环境。<br><strong>查询标识符：</strong>搜索过程从作用域链的前端开始，向上逐级查询给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪；如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索，搜索过程一直追溯到全局环境的变量对象，如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。</p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>JavaScript具有自动垃圾收集机制，垃圾收集器跟踪哪个变量有用，哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，用于标识无用变量的策略主要有以下两种办法：<br>标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去除环境中的变量以及被环境中的变量引用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。<br>引用计数：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给变量时，则这个值的引用次数就是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1；相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1，当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间收回来。</p>
]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端交互</title>
    <url>/blog/2020/05/25/Vue/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h2 id="前后端交互模式"><a href="#前后端交互模式" class="headerlink" title="前后端交互模式"></a>前后端交互模式</h2><h3 id="接口调用方式"><a href="#接口调用方式" class="headerlink" title="接口调用方式"></a>接口调用方式</h3><ul>
<li><ol>
<li>原生ajax</li>
</ol>
</li>
<li><ol start="2">
<li>基于jQuery的ajax</li>
</ol>
</li>
<li><ol start="3">
<li>fetch</li>
</ol>
</li>
<li><ol start="4">
<li>axios</li>
</ol>
</li>
</ul>
<h3 id="URL地址格式"><a href="#URL地址格式" class="headerlink" title="URL地址格式"></a>URL地址格式</h3><p><strong>1. 传统形式的URL</strong></p>
<ul>
<li>格式：schema://host:port/path?query#fragment<ul>
<li>schema: 协议，例如http、https、ftp等</li>
<li>host: 域名或者IP地址</li>
<li>port: 端口，http默认端口80，可以省略</li>
<li>path: 路径，例如/abc/a/b/c</li>
<li>query: 查询参数，例如 uname=list&amp;age=12</li>
<li>fragment: 锚点(哈希Hash)，用于定位页面的某个位置</li>
</ul>
</li>
</ul>
<ul>
<li>符合规则的URL<ul>
<li><a href="http://www.itcast.cn" target="_blank" rel="noopener">http://www.itcast.cn</a></li>
<li><a href="http://www.itcast.cn/java/web" target="_blank" rel="noopener">http://www.itcast.cn/java/web</a></li>
<li><a href="http://www.itcast.cn/java/web?flag=1" target="_blank" rel="noopener">http://www.itcast.cn/java/web?flag=1</a></li>
<li><a href="http://www.itcast.cn/java/web?flag=1#function" target="_blank" rel="noopener">http://www.itcast.cn/java/web?flag=1#function</a></li>
</ul>
</li>
</ul>
<p><strong>2. Restful形式的URL</strong></p>
<ul>
<li>HTTP请求方式<ul>
<li>GET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询</li>
<li>POST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加</li>
<li>PUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改</li>
<li>DELETE&nbsp;&nbsp;&nbsp;&nbsp;删除</li>
</ul>
</li>
<li>符合规则的URL地址<ul>
<li><a href="http://www.hello.com/books" target="_blank" rel="noopener">http://www.hello.com/books</a> &nbsp;&nbsp;        GET</li>
<li><a href="http://www.hello.com/books" target="_blank" rel="noopener">http://www.hello.com/books</a>    &nbsp;&nbsp;     POST</li>
<li><a href="http://www.hello.com/books/123" target="_blank" rel="noopener">http://www.hello.com/books/123</a>   &nbsp;&nbsp;  PUT</li>
<li><a href="http://www.hello.com/books/123" target="_blank" rel="noopener">http://www.hello.com/books/123</a>  &nbsp;&nbsp;   DELETE</li>
</ul>
</li>
</ul>
<h2 id="Promise-用法"><a href="#Promise-用法" class="headerlink" title="Promise 用法"></a>Promise 用法</h2><h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><ul>
<li>异步效果分析：定时任务、Ajax、事件函数</li>
<li>多次异步调用的结果分析<ul>
<li>多次异步调用的结果顺序不确定</li>
<li>异步调用结果如果存在依赖需要嵌套（容易产生回调地狱）</li>
</ul>
</li>
</ul>
<h3 id="Promise-概述"><a href="#Promise-概述" class="headerlink" title="Promise 概述"></a>Promise 概述</h3><p>Promise是异步编程的一种解决方案，从语法上讲，Promise是一个对象，从它可以获取异步操作的消息。<br>使用Promise主要有以下好处：<br>    - 可以避免多层嵌套问题（回调地狱）<br>    - Promise对象提供了简洁的API，使得控制异步操作更加容易<br><strong>官方Promise文档：</strong><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Promise</a></p>
<h3 id="Promise-基本用法"><a href="#Promise-基本用法" class="headerlink" title="Promise 基本用法"></a>Promise 基本用法</h3><ul>
<li><ol>
<li>实例化<code>Promise</code>对象，构造函数中传递函数，该函数用于处理异步任务</li>
</ol>
</li>
<li><ol start="2">
<li><code>resolve</code>和<code>reject</code>两个参数用于处理成功和失败两种情况，并通过<code>p.then</code>获取处理结果。</li>
</ol>
</li>
</ul>
<p><strong>基于Promise处理定时任务</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//成功时调用resolve()</span></span><br><span class="line">    <span class="comment">//失败时调用reject()</span></span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//从resolve得到正常结果</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//从reject得到错误信息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//定时异步操作任务</span></span></span><br><span class="line"><span class="actionscript">            setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> flag = <span class="literal">true</span></span></span><br><span class="line">                if(flag) &#123;</span><br><span class="line"><span class="actionscript">                    resolve(<span class="string">"hello world"</span>)</span></span><br><span class="line"><span class="actionscript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                    reject(<span class="string">"出错了"</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="actionscript">        p.then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data)     <span class="comment">//hello world(flag=true)</span></span></span><br><span class="line"><span class="actionscript">        &#125;,<span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>&#123;      </span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(error)    <span class="comment">//出错了(flag=false)</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>基于Promise处理Ajax请求</strong><br>这里请求的后台没有写，只是示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=&lt;device-width&gt;, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">queryData</span><span class="params">(url)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">                xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">if</span>(xhr.readyState != <span class="number">4</span>) <span class="keyword">return</span>;</span></span><br><span class="line">                    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">                        resolve(xhr.responseText);</span><br><span class="line"><span class="actionscript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                        reject(<span class="string">"服务器错误"</span>)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="actionscript">                xhr.open(<span class="string">'get'</span>,url);</span></span><br><span class="line"><span class="actionscript">                xhr.send(<span class="literal">null</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> p;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        queryData(<span class="string">'http://localhost:3000/data'</span>)</span></span><br><span class="line"><span class="actionscript">        .then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="actionscript">        &#125;,<span class="function"><span class="keyword">function</span><span class="params">(error)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(error)</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>发送多次Ajax请求</strong><br>通过then的链式操作解决回调地狱问题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=&lt;device-width&gt;, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">queryData</span><span class="params">(url)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">                xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">if</span>(xhr.readyState != <span class="number">4</span>) <span class="keyword">return</span>;</span></span><br><span class="line">                    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">                        resolve(xhr.responseText);</span><br><span class="line"><span class="actionscript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                        reject(<span class="string">"服务器错误"</span>)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="actionscript">                xhr.open(<span class="string">'get'</span>,url);</span></span><br><span class="line"><span class="actionscript">                xhr.send(<span class="literal">null</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> p;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        queryData(<span class="string">'http://localhost:3000/data'</span>)</span></span><br><span class="line"><span class="actionscript">            .then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> queryData(<span class="string">'http://localhost:3000/data1'</span>)</span></span><br><span class="line">            &#125;)</span><br><span class="line"><span class="actionscript">            .then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(data);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> queryData(<span class="string">'http://localhost:3000/data2'</span>)</span></span><br><span class="line">            &#125;)</span><br><span class="line"><span class="actionscript">            .then(<span class="function"><span class="keyword">function</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(data);</span></span><br><span class="line">            &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>then参数中的函数返回值</strong></p>
<ul>
<li><ol>
<li>返回Promise实例对象: 返回的该实例对象会调用下一个then</li>
</ol>
</li>
<li><ol start="2">
<li>返回普通值: 返回的普通值会直接传递给下一个then，通过then参数中函数的参数接收该值</li>
</ol>
</li>
</ul>
<h3 id="Promise常用的API"><a href="#Promise常用的API" class="headerlink" title="Promise常用的API"></a>Promise常用的API</h3><p><strong>实例方法</strong></p>
<ul>
<li><ol>
<li>p.then()得到异步任务的正确结果</li>
</ol>
</li>
<li><ol start="2">
<li>p.catch()获取异常信息</li>
</ol>
</li>
<li><ol start="3">
<li>p.finally()成功与否都会执行(尚且不是正是标准)</li>
</ol>
</li>
</ul>
<p><strong>对象方法</strong></p>
<ul>
<li><ol>
<li>Promise.all() 并发处理多个异步任务，所有任务都执行完成才能得到结果</li>
</ol>
</li>
<li><ol start="2">
<li>Promise.race() 并发处理多个异步任务，只要有一个任务完成就能得到结果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([p1,p2,p3]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.race([p1,p2,p3]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h2 id="接口调用-axios方法"><a href="#接口调用-axios方法" class="headerlink" title="接口调用-axios方法"></a>接口调用-axios方法</h2><p>axios（官网: <a href="https://github.com/axios/axios）是一个基于Promise用于浏览器和node.js的HTTP客户端。" target="_blank" rel="noopener">https://github.com/axios/axios）是一个基于Promise用于浏览器和node.js的HTTP客户端。</a><br>它具有以下特征：</p>
<ul>
<li><ol>
<li>支持浏览器和node.js</li>
</ol>
</li>
<li><ol start="2">
<li>支持promise</li>
</ol>
</li>
<li><ol start="3">
<li>能拦截请求和响应</li>
</ol>
</li>
<li><ol start="4">
<li>自动转换JSON数据</li>
</ol>
</li>
</ul>
<h3 id="axios的基本用法"><a href="#axios的基本用法" class="headerlink" title="axios的基本用法"></a>axios的基本用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'http://localhost:3000/adata'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//注意data属性是固定用法，用于获取后台的实际数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="axios常用的API"><a href="#axios常用的API" class="headerlink" title="axios常用的API"></a>axios常用的API</h3><p>axios常用的API主要是get、post、put、delete<br><strong>GET传递参数</strong><br>通过URL传递参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统URL传递参数</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/adata?id=123'</span>).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//restful形式的URL传递参数</span></span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/adata/123'</span>).then(<span class="function"><span class="params">ret</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过params选项传递参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">'http://localhost:3000/adata'</span>,&#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        id: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>POST传递参数(默认是json格式的数据)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'http://localhost:3000/adata'</span>,&#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        uname: <span class="string">'tom'</span>,</span><br><span class="line">        pwd: <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>PUT传递参数(默认是json格式的数据)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.put(<span class="string">'http://localhost:3000/adata/123'</span>,&#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        uname: <span class="string">'tom'</span>,</span><br><span class="line">        pwd: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>DELETE传递参数(默认是json格式的数据)</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.delete(<span class="string">'http://localhost:3000/adata/123'</span>,&#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        id: <span class="number">111</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="axios的相应结果"><a href="#axios的相应结果" class="headerlink" title="axios的相应结果"></a>axios的相应结果</h3><p><strong>响应结果的主要属性</strong></p>
<ul>
<li><ol>
<li>data: 实际响应回来的数据</li>
</ol>
</li>
<li><ol start="2">
<li>headers: 响应头信息</li>
</ol>
</li>
<li><ol start="3">
<li>status: 响应状态码</li>
</ol>
</li>
<li><ol start="4">
<li>statusText: 响应状态信息<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">'http://localhost:3000/axios-json'</span>).then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h3 id="axios的全局配置"><a href="#axios的全局配置" class="headerlink" title="axios的全局配置"></a>axios的全局配置</h3><ul>
<li><ol>
<li>axios.defaults.timeout = 3000;   //超时时间</li>
</ol>
</li>
<li><ol start="2">
<li>axios.defaults.baseURL = “<a href="http://localhost:3000/app&quot;" target="_blank" rel="noopener">http://localhost:3000/app&quot;</a> //默认地址</li>
</ol>
</li>
<li><ol start="3">
<li>axios.defaults.headers[‘mytoken’] = ‘aqwererqretewterw23’ //设置请求头</li>
</ol>
</li>
</ul>
<h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><p><strong>请求拦截器：</strong>在请求发出之前设置一些信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在请求发出之前进行一些信息设置</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理响应的错误信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>响应拦截器：</strong>在获取数据之前对数据做一些加工处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加一个响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在这里对返回的数据进行处理</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//处理响应的错误信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="接口调用-async-await用法"><a href="#接口调用-async-await用法" class="headerlink" title="接口调用-async/await用法"></a>接口调用-async/await用法</h2><ul>
<li><ol>
<li>async/await是ES7引入的新语法，可以更加方便的进行异步操作</li>
</ol>
</li>
<li><ol start="2">
<li>async关键字用于函数上（async函数的返回值是Promise实例对象）</li>
</ol>
</li>
<li><ol start="3">
<li>await关键字用于async函数中（await可以得到异步的结果）</li>
</ol>
</li>
<li><ol start="4">
<li>async/await处理多个异步请求<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="keyword">await</span> axios.get(<span class="string">'/async1'</span>);</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="keyword">await</span> axios.get(<span class="string">'async2?info='</span> + info.data)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line">queryData.then(<span class="function"><span class="params">ret</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ret)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>




</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>python 基本函数</title>
    <url>/blog/2020/04/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="基本函数语法"><a href="#基本函数语法" class="headerlink" title="基本函数语法"></a>基本函数语法</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。<br>我们以自定义一个求绝对值的my_abs函数为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(my_abs(<span class="number">-99</span>))</span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure>

<h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><p>定义一个什么也不做的空函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span>   <span class="comment"># pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来</span></span><br></pre></td></tr></table></figure>

<h3 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h3><p>参数个数检查，python解释器会自动检查出来，并抛出TypeError<br>参数类型检查，使用isinstance()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, (int, float)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">'bad operand type'</span>)</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<p>若输入参数出现错误，会抛出一个错误</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">25</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">125</span></span><br></pre></td></tr></table></figure>

<p>根据定义的参数个数传入几个位置参数</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>设置的默认参数也可以在函数调用时明确传入，更改默认参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    s = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">        s = s * x</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> power(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>power(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">125</span></span><br></pre></td></tr></table></figure>

<p>注意：默认参数必须指向不变对象</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>当参数个数不确定时，我们可以把这些不确定的参数当作一个list或者tuple传递进来<br>例如：以数学题为例，给定一组a,b,c,……，计算他们的平方和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc((<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>))</span><br><span class="line"><span class="number">84</span></span><br></pre></td></tr></table></figure>

<p>这种方式需要先组装出一个list或者tuple<br>但是利用可变参数，调用函数的方式可以简化成这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        sum = sum + n * n</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc()</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个 * 号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数<br>如果已经有一个list或者tuple，要调用一个可变参数,Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure>

<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>可变参数传入0个或者任意多个参数，在调用时自动组装为一个tuple，关键字参数传入0个或者多个含参数名的参数，这些关键字参数在函数内部自动组装成一个dict<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **kw)</span>:</span></span><br><span class="line">    print(<span class="string">'name:'</span>, name, <span class="string">'age:'</span>, age, <span class="string">'other:'</span>, kw)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Bob'</span>, <span class="number">35</span>, city=<span class="string">'Beijing'</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">'city'</span>: <span class="string">'Beijing'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Adam'</span>, <span class="number">45</span>, gender=<span class="string">'M'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">'gender'</span>: <span class="string">'M'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>关键字参数有什么用？<br>它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。</p>
<h3 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h3><p>如果要限制关键字参数的名字，可以用命名关键字参数<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *, city, job)</span>:</span></span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">'Jack'</span>, <span class="number">24</span>, city=<span class="string">'Beijing'</span>, job=<span class="string">'Engineer'</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br></pre></td></tr></table></figure>

<p>和关键字参数*<em>kw不同，命名关键字参数需要一个特殊分隔符</em>，<em>后面的参数被视为命名关键字参数<br>但是如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符</em>了<br>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, *args, city, job)</span>:</span></span><br><span class="line">    print(name, age, args, city, job)</span><br><span class="line">&gt;&gt; person(<span class="string">'Jack'</span>, <span class="number">24</span>, <span class="string">'Beijing'</span>, <span class="string">'Engineer'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: person() takes <span class="number">2</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></table></figure>

<h3 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h3><p>在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数<br>** 关键字参数与命名关键字参数对应的是字典dict，可变参数对应的是元组</p>
]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 引用类型</title>
    <url>/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>引用类型的值（对象）是引用类型的一个实例，在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称作类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>

<p>这行代码创建了Object引用类型的一个新实例，然后把该实例保存在了变量person中。使用的构造函数是Object，它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型（例如Object），以便开发人员用以实现常见的计算任务。</p>
<h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p>创建Object类型的方式有两种，第一种是使用new操作符后跟Object构造函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>

<p>另一种方法是使用对象字面量的方法，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于对象字面量语法，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;      <span class="comment">// 与new Object()相同</span></span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>

<p><strong>开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉，实际上，对象字面量也是向函数传递大量可选参数的首选方式。</strong></p>
<p>访问对象属性有两种办法：点表示法和方括号表示法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person[<span class="string">"name"</span>]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);    <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>从功能上看，这两种访问对象属性的方法没有任何区别，但方括号语法的主要优点是可以通过变量来访问属性，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[propertyName]);  <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>Array类型与Object类型一样都是ECMAScript中最常用的类型，ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据，创建数组的基本方式有两种，第一种是使用Array构造函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>

<p>创建数组也可以按照下面几种方式进行创建：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);  <span class="comment">// 创建length为20的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);  <span class="comment">// 创建了一个包含三个字符串值的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含3项的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Grey"</span>); <span class="comment">// 创建一个包含1项，即字符串"Grey"的数组</span></span><br></pre></td></tr></table></figure>

<p>在使用Array构造函数时也可以省略new操作符，省略new操作符与不省略new操作符的结果相同。</p>
<p>创建数组的第二种基本方式是使用数组字面量表示法，数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含3个字符串的数组</span></span><br><span class="line"><span class="keyword">var</span> name = [];   <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,];   <span class="comment">// 不要这样！这样会创建一个包含2项或3项的数组</span></span><br><span class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">// 不要这样！这样会创建一个包含5项或6项的数组</span></span><br></pre></td></tr></table></figure>

<p>在读取和设置数组的值时，要使用方括号并提供响应值的基于0的数字索引，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 定义一个字符串数组</span></span><br><span class="line"><span class="built_in">console</span>.log(color[<span class="number">0</span>]);  <span class="comment">// 显示第一项</span></span><br><span class="line">color[<span class="number">2</span>] = <span class="string">"black"</span>;  <span class="comment">// 修改第三项</span></span><br><span class="line">color[<span class="number">3</span>] = <span class="string">"brown"</span>;  <span class="comment">// 新增第四项</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面例子的数组的length属性不是只读的，通过设置这个属性，可以从数组的末尾移除或向数组中添加新项，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>下面介绍数组会用到的一些方法</p>
<h3 id="检测数组方法"><a href="#检测数组方法" class="headerlink" title="检测数组方法"></a>检测数组方法</h3><p>ECMAScript新增Array.isArray()方法，这个方法能确定某个值最终到底是不是数组，不管在哪个全局环境下创建的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="comment">// 对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>数组继承的<code>toString()</code>返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串，<code>valueOf()</code>返回的还是Array 对象的原始值。<br>使用<code>join()</code>方法，则可以使用不同的分隔符来构建字符串，<code>join()</code>方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colors.toString());</span><br><span class="line"><span class="built_in">console</span>.log(colors.valueOf());</span><br><span class="line"><span class="built_in">console</span>.log(colors.join(<span class="string">"||"</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">red,blue,green</span><br><span class="line">[ <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span> ]</span><br><span class="line">red||blue||green</span><br></pre></td></tr></table></figure>

<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。<br>push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度；pop()方法则从数组末尾移除最后一项，减少数组的length()值，然后返回移除的项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item);  <span class="comment">//"black"</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length);  <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>实现这一操作的方法有两组：<br>从数组末端添加项，从数组前端取得项：push()与shift()方法<br>从数组前端添加项，从数组末端取得项：unshift()与pop()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.shift();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">//"red"</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个数组并使用push()方法先后推入了3个值，首先是”red”和”green”，然后是”black”，数组中各项的顺序为”red”,”green”,”black”，在调用shift()方法时，移除并返回的是第一项，即”red”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.unshift(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(count);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop();</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">//"green"</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这个例子创建了一个数组并使用unshift()方法先后推入了3个值，首先是”red”和”green”，然后是”black”，数组中各项的顺序为”black”,”red”,”green”，在调用pop()方法时，移除并返回的是最后一项，即”green”。</p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>reverse()方法：反转数组项的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(values);  <span class="comment">//5,4,3,2,1</span></span><br></pre></td></tr></table></figure>

<p>sort()方法：按照升序或者降序顺序排列数组项，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，然后接收一个比较函数作为参数，以确定排列顺序。<br>示例如下：这个示例是按照升序进行排列的，若是按照降序排列，只需交换比较函数返回的值即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line"><span class="built_in">console</span>.log(values)；  <span class="comment">// 0，1，5，10，15</span></span><br></pre></td></tr></table></figure>

<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>要介绍的concat()方法、slice()方法都不影响原始数组。<br>concat()方法：可以基于当前数组中的所有项创建一个新数组，具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors1 = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors1.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors1);  <span class="comment">// red,green,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure>

<p>slice()方法：能够基于当前数组中的一个或多个项创建一个新数组，slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项；<strong>如果有两个参数，该方法返回起始和结束位置之间的项但不包括结束位置的项。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors1 = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors1.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors1.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2);  <span class="comment">// green,blue,yellow,purple</span></span><br><span class="line"><span class="built_in">console</span>.log(clolors3); <span class="comment">// green,blue,yellow</span></span><br></pre></td></tr></table></figure>

<p>splice()方法：该方法包括对原始数组的删除、插入以及替换功能</p>
<ul>
<li>删除：可以删除任意数量的项，只需提供2个参数：要删除的第一项的位置和要删除的项数；</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项；</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起始位置、要删除的项数和要插入的任意数量的项，插入的项不必等于删除的项数。<br>实例如下所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);   <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);  <span class="comment">// green,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// red</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">"yellow"</span>, <span class="string">"orange"</span>);  <span class="comment">// 从位置1开始插入两项</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);  <span class="comment">// green,yellow,orange,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// 返回的是一个空数组</span></span><br><span class="line"></span><br><span class="line">removed = colors.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">"red"</span>, <span class="string">"purple"</span>);     <span class="comment">// 插入两项，删除一项</span></span><br><span class="line"><span class="built_in">console</span>.log(colors);  <span class="comment">// green,red,purple,orange,blue</span></span><br><span class="line"><span class="built_in">console</span>.log(removed); <span class="comment">// yellow</span></span><br></pre></td></tr></table></figure>

<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()方法，这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。<br>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1，在比较第一个参数与数组中的每一项时，使用全等操作符（===）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>, <span class="string">"black"</span>, <span class="string">"blue"</span>, <span class="string">"purple"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(<span class="string">"blue"</span>);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(<span class="string">"blue"</span>,<span class="number">2</span>);  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.latIndexOf(<span class="string">"blue"</span>);  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(<span class="string">"yellow"</span>);  <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">#比较时全等</span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"blue"</span>);</span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"blue"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str1));  <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(str2));  <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(str1));  <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.indexOf(str2));  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript提供了5个迭代方法，每个方法都接受两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值,传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。以下方法都不会修改数组中的包含的值。</p>
<ul>
<li>every(): 对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true。</li>
<li>filter(): 对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数，这个方法没有返回值。</li>
<li>map(): 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some(): 对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。<br>实例如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(everyResult); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(someResult); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(filterResult); <span class="comment">// [3,4,5,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mapResult); <span class="comment">// [2,4,6,8,10,8,6,4,2]</span></span><br><span class="line"></span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,array&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="regexp">//</span> 执行某些操作，这个方法没有返回值，本质上与for循环迭代数组一样</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>))</span></span><br></pre></td></tr></table></figure>

<h3 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h3><p>ECMAScript5新增了两个缩小数组的方法：reduce()和reduceRight()。这两个数组都会迭代数组的所有项，然后构建一个最终返回的值。<br>reduce()方法从数组的第一项开始，逐个遍历到最后；reduceRight()则从数组的最后一项开始，向前遍历到第一项。<br>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为缩小基础的初始值，传给reduce()和reduceRight()的函数接收4个参数：前一个值、当前值、项的索引和数组对象，这个函数返回的任何值都会作为第一个参数自动传给下一项，第一次迭代发生在数组的第二项上，因此第一个参数就是数组的第一项，第二个参数就是数组的第二项。<br>使用reduce()方法可以执行求数组中所有值之和的操作，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev,cur,index,array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>reduceRight()的作用类似，只不过方向相反而已。</p>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>ECMAScript中的Date类型是在早期Java中的java.utip.Date类基础上构建的，为此，Date类型使用自UTC1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。<br>要创建一个日期对象，使用new操作符和Date构造函数即可，若需要在构造函数中传递一个表示时间的字符串作为参数，那么日期的格式为<strong>月份/日/年 时：分：秒</strong>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();   </span><br><span class="line"><span class="built_in">console</span>.log(now)     <span class="comment">//2020-07-02T09:00:51.471Z</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"12/03/2016"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(date)   <span class="comment">//2016-12-02T16:00:00.000Z</span></span><br></pre></td></tr></table></figure>

<p>在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数，为了简化这一计算，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。<br>Date.parse()是Date对象的静态方法，parse()方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。<br>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"12/03/2016"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.parse(date))  <span class="comment">//1480694400000</span></span><br><span class="line"><span class="comment">//时间戳形式的毫秒数(计算机底层保存的都是时间戳形式的日期)</span></span><br><span class="line"><span class="keyword">var</span> time = date.getTime()</span><br><span class="line"><span class="built_in">console</span>.log(time)      <span class="comment">////1480694400000</span></span><br></pre></td></tr></table></figure>

<p>UTC() 方法可根据世界时间返回 1970 年 1 月 1 日 到指定日期的毫秒数。Date.UTC() 是一种静态方法，因为需要使用构造函数 Date() 来调用它，而不是通过某个 Date 对象调用。</p>
<p>Date.UTC() 方法的参数指定日期和时间，它们都是 UTC 时间，处于 GMT 时区。指定的UTC时间将转换成毫秒的形式，这样构造函数 Date() 和方法 Date.setTime() 就可以使用它了。<br>语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Date</span>.UTC(year,month,day,hours,minutes,seconds,ms)</span><br></pre></td></tr></table></figure>
<p>关于日期的其他方法参考一下链接：<a href="http://www.w3s.com.cn/js/jsref_obj_date.asp" target="_blank" rel="noopener">http://www.w3s.com.cn/js/jsref_obj_date.asp</a></p>
<h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>与其他引用类型一样，Date类型也重写了toLocalString()、toString()和valueOf()方法，但这些方法返回的值与其他类型中的方法不同。Date()类型的toLocalString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间，这大致意味着时间格式中会包含AM或PM，但不会包含时区信息；而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。<br>Date类型的valueOf()方法则根本不返回字符串，而是返回日期的毫秒表示。</p>
<h3 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h3><ul>
<li><p>toDateString(): 以特定实现的格式显示星期几、月、日和年；</p>
</li>
<li><p>toTimeString(): 以特定于实现的格式显示时、分、秒和时区；</p>
</li>
<li><p>toLocalTimeString(): 以特定于实现的格式显示时、分、秒；</p>
</li>
<li><p>toLocalDateString(): 以特定于地区的格式显示星期几、月、日和年；</p>
</li>
<li><p>toUTCString(): 以特定于实现的格式显示完整的UTC日期。</p>
</li>
<li><p>还有很多关于日期的函数方法：</p>
</li>
</ul>
<p>更多参考：<a href="https:#www.w3school.com.cn/jsref/jsref_obj_date.asp">Date对象方法</a></p>
<h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>ECMAScript通过RegExp类型来支持正则表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure>

<p>其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标名正则表达式的行为，正则表达式的匹配模式支持下列3个标志：</p>
<ul>
<li>g: 表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；</li>
<li>i: 表示不区分大小写模式，，即在确定匹配项时忽略模式与字符串的大小写；</li>
<li>m: 表示多行模式，即在到达一行文末末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>因此一个正则表达式就是一个模式与上述3个标志的组合体，不同组合产生不同结果，如下面的例子所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有"at"的实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配第一个"bat"或者"cat"，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有以"at"结尾的3个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure>

<p>与其他语言中的正则表达式一样，模式中所使用的所有元字符都必须转义，正则表达式中的元字符包括：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">( | &#123; \ ^ $ ) ? * + . ]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字符串和正则表达式相关的方法以及元字符的具体含义参考：<a href="http://www.w3s.com.cn/js/jsref_obj_regexp.asp" target="_blank" rel="noopener">http://www.w3s.com.cn/js/jsref_obj_regexp.asp</a></strong><br>这些元字符在正则表达式中都有一或多种特殊用途，因此想要匹配字符串中包含的这些字符，就必须对它们进行转义，下面给出几个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配第一个"[bc]at"，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有以"at"结尾的3个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern3 = <span class="regexp">/.at/gi</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配字符串中所有以".at"结尾的3个字符的组合，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> patttern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure>

<p>前面举得这些例子都是以字面量形式来定义的正则表达式，另一种创建正则表达式的方式是使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串，可以使用字面量定义的任何表达式，都可以使用构造函数来定义，如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 匹配第一个"bat"或"cat"，不区分大小写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 与pattern1相同，只不过是使用构造函数创建的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure>

<p>使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样，在ECMAScript3 中，正则表达式字面量始终会共享一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="literal">null</span>,i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    re = <span class="regexp">/cat/g</span>;</span><br><span class="line">    <span class="built_in">console</span>.log((re.test(<span class="string">"catastrophe"</span>)));   <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"cat"</span>, <span class="string">"g"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(re.test(<span class="string">"catastrophe"</span>));    <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第一个循环中，即使是循环体指定的，但实际上只为/cat/创建了一个RegExp实例，由于实例属性不会重置，所以在循环中再次调用text()方法会失败，这是因为第一次调用test()找到了”cat”，但第二次调用是从索引为3的字符（上一次匹配的末尾）开始的，所以就找不到它了，由于会测试到字符串末尾，所以下一次再调用test()就又从开头开始了。<br>第二个循环使用RegExp构造函数在每次循环中创建正则表达式，因为每次迭代都会创建一个新的RegExp构造函数一样，每次创建新的RegExp实例。</p>
<h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li>global: 布尔值，表示是否设置了g标志；</li>
<li>ignoreCase: 布尔值，表示是否设置了i标志；</li>
<li>lastIndex: 整数，表示开始搜索下一个匹配项的字符位置，从0算起；</li>
<li>multiline: 布尔值，表示是否设置了m标志；</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。<br>实例如下所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/\[bc]at/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pattern1.global);    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.ignoreCase);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);  <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.multiline);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.source);    <span class="comment">//"\[bc]at"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\[bc\\]at"</span>, <span class="string">"i"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pattern2.global);    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.ignoreCase);  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);  <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.multiline);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.source);    <span class="comment">//"\[bc]at"</span></span><br></pre></td></tr></table></figure>

<h3 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h3><p>RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接收一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组，或者在没有匹配项的情况下返回null。返回的数组包含两个额外的属性：<br>index与input属性，index表示匹配项在字符串中的位置，input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有匹配组，则该数组只包含一项）<br>实例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/mom(and dad(and baby)?)?/gi</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern.exec(text);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(matches.index);    <span class="comment">// 0 与整个模式匹配的字符串的第一项的位置</span></span><br><span class="line"><span class="built_in">console</span>.log(matches.input);    <span class="comment">// "mom and dad and baby" 与整个模式匹配的字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);       <span class="comment">// "mom and dad and baby" 整个字符串本身的匹配项</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">1</span>]);       <span class="comment">// "and dad and baby"    与第一个捕获组匹配的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">2</span>]);       <span class="comment">// "and baby"    与第二个捕获组匹配的内容</span></span><br></pre></td></tr></table></figure>

<p>对于exec()方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项，在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息，而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。如下面例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line"><span class="comment">// 非全局模式下：</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern1.exec[text];</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);   <span class="comment">//0</span></span><br><span class="line"><span class="comment">// 每次调用exec()返回的都是第一个匹配项("cat")</span></span><br><span class="line">matches = pattern1.exec[text];</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern1.lastIndex);   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="regexp">/.at/g</span>;</span><br><span class="line"><span class="keyword">var</span> matches = pattern2.exec[text];</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">//4</span></span><br><span class="line"><span class="comment">// 每次调用exec()返回的都是下一个匹配项，直到搜索到字符串末尾为止</span></span><br><span class="line">matches = pattern1.exec[text];</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//bat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern2.lastIndex);   <span class="comment">//8</span></span><br></pre></td></tr></table></figure>

<p>正则表达式的第二个方法是test(),它接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便，因此test()方法经常被用在if语句中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"000-00-0000"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这个模式有匹配项"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RegExp构造函数属性"><a href="#RegExp构造函数属性" class="headerlink" title="RegExp构造函数属性"></a>RegExp构造函数属性</h3><p>RegExp构造函数包含一些属性，这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化，并且这些属性可以以两种方式访问，下表列出了RegExp构造函数的一些属性</p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串，Opera未实现此属性</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项，Opera未实现此功能</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组，Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本</td>
</tr>
<tr>
<td>mulitiline</td>
<td>$*</td>
<td>布尔值，表示是否所有表达式都是使用多行模式，IE和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>input字符串中lastMatch之后的文本</td>
</tr>
</tbody></table>
<p>使用这些属性可以从exec()或test()执行的操作中提取出更具体的信息，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span>;</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(.)hort/g</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.input);        <span class="comment">// this has been a short summer</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.lastMatch);    <span class="comment">//short</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.leftContext);  <span class="comment">//this has been a</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.rightContext); <span class="comment">//summer</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.mulitiline);   <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以通过短属性来访问它们，这里就不介绍了，与长属性用法相同</p>
<p>除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性，访问这些属性的方法是RegExp.$1、RegExp.$2 … RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组，在调用exec()或test()方法时，这些属性会被自动填充，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"this has been a short summer"</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/(..)or(.)/g</span>;</span><br><span class="line"><span class="keyword">if</span>(pattern.test(text))&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">1</span>);   <span class="comment">//sh</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$<span class="number">2</span>);   <span class="comment">//t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Function-类型"><a href="#Function-类型" class="headerlink" title="Function 类型"></a>Function 类型</h2><p>函数是对象，函数名是一个指向函数对象的指针，不会与某个函数绑定，函数声明定义形式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数没有重载"><a href="#函数没有重载" class="headerlink" title="函数没有重载"></a>函数没有重载</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    reurn num +<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    reurn num +<span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>);  <span class="comment">//300</span></span><br></pre></td></tr></table></figure>

<p>第二个函数覆盖了第一个函数的变量，函数没有重载</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在向执行环境中加载数据时，会先读取函数声明，并使其在执行任何代码之前可用（可以访问），而函数表达式是等到解析器执行到它所在的代码行，才会真正被解释执行。<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">20</span>,<span class="number">20</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 +num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析器通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中，就是sum函数已经提前声明，所以可以在前面调用</p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>函数内部有3个特殊的对象：arguments、this和caller。<br>arguments是一个类数组对象，包含着传入函数中的所有参数，除此之外arguments还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数；<br>如下递归阶乘函数所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num*<span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this引用的是函数执行的环境对象，在全局作用域中，this对象引用的是window。比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();    <span class="comment">//"red"</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor();  <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>

<p>第一次调用sayColor()是在全局作用域中定义的，this引用的对象是window，所以输出为”red”, 第二次this引用的对象是0，所以this.color= o.color, 返回为”blue”<br>caller属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，会为null。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee.caller);   <span class="comment">//Function: outer</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>

<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>由于ECMAScript中的函数是对象，所以函数也有属性和方法，每个函数有两个属性：length和prototype<br>length表示函数希望接收的命名参数的个数，prototype指的函数的原型方法，toString()、valueOf()等都属于prototype内。<br>每个函数也会包含两个非继承而来的方法：apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。<br>apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组，其中，第二个参数可以是Array的实例，也可以是arguments对象。<br>如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>,[num1,num2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(callSum1(<span class="number">10</span>,<span class="number">10</span>))   <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(callSum2(<span class="number">10</span>,<span class="number">10</span>))   <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>call()与apply()的作用没有什么不同，只是call()必须将传递给函数的参数逐个列举出来，如下面例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum.call(<span class="keyword">this</span>,num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(callSum(<span class="number">10</span>,<span class="number">10</span>))   <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>传递参数并非apply()和call()的真正用武之地，它们真正强大的地方是能扩充函数赖以运行的作用域，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor.call(<span class="keyword">this</span>);     <span class="comment">//"red"</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);   <span class="comment">//"red"</span></span><br><span class="line">sayColor.call(o);        <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript5还定义了一个方法：bind(),这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">color</span>: <span class="string">"blue"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor();    <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>

<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="字符方法"><a href="#字符方法" class="headerlink" title="字符方法"></a>字符方法</h3><p>charAt()与charCodeAt()方法，这两个方法都接收一个参数，即基于0的字符位置，charAt()方法以单字符串的形式返回给定位置的那个字符，charCodeAt()返回的是给定位置的字符编码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>；</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.charAt(<span class="number">1</span>));      <span class="comment">//"e"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.charCodeAt(<span class="number">1</span>));  <span class="comment">//"101"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h3><p>concat()：用于将一或多个字符串拼接起来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello "</span>;</span><br><span class="line"><span class="keyword">var</span> result = stringValue.concat(<span class="string">"world"</span>, <span class="string">"!"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);         <span class="comment">//"hello world!"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue)     <span class="comment">//"hello "</span></span><br></pre></td></tr></table></figure>

<p>创建新字符串的三种方法：都接受一到两个参数<br>slice()：第一个参数用于指定字符串的开始位置，第二个参数表示字符串到哪里结束<br>substring()：第一个参数用于指定字符串的开始位置，第二个参数表示字符串到哪里结束<br>substr()：第一个参数用于指定字符串的开始位置，第二个参数表示返回的字符个数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>));           <span class="comment">//"lo world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>));       <span class="comment">//"lo world"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>));          <span class="comment">//"lo world"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.slice(<span class="number">3</span>,<span class="number">7</span>));           <span class="comment">//"lo w"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substring(<span class="number">3</span>,<span class="number">7</span>));       <span class="comment">//"lo w"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.substr(<span class="number">3</span>,<span class="number">7</span>));          <span class="comment">//"lo worl"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串位置方法"><a href="#字符串位置方法" class="headerlink" title="字符串位置方法"></a>字符串位置方法</h3><p>有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()，这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该字符串，则返回-1），indexOf()方法是从字符串的开头向后搜索子字符串，而和lastIndexOf()方法是从字符串的末尾向前搜索子字符串。同时这两个方法都可以接收第二个参数，表示从字符串的哪个位置开始搜索。因此可以通过循环调用indexOf()和lastIndexOf()来找到所有匹配的子字符串。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"hello world,helo,dsjfkgsdlfkglfd"</span>;</span><br><span class="line"><span class="keyword">var</span> positions = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> pos = stringValue.indexOf(<span class="string">"e"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(pos&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">    positions.push(pos);</span><br><span class="line">    pos = stringValue.indexOf(<span class="string">"e"</span>, pos+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(positions);   <span class="comment">// [ 1, 13 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h3><p>trim()方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"  hello world   "</span>;</span><br><span class="line"><span class="keyword">var</span> trimstringValue = stringValue.trim();</span><br><span class="line"><span class="built_in">console</span>.log(trimstringValue);  <span class="comment">// "hello world"</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串大小写转换方法"><a href="#字符串大小写转换方法" class="headerlink" title="字符串大小写转换方法"></a>字符串大小写转换方法</h3><p>字符串大小写转换方法有toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()。<br>toLowerCase()与toUpperCase()是通用方法，toLocaleLowerCase()与toLocaleUpperCase()是针对特定地区的实现，一般来说不知道自己的代码将在哪种语言运行环境下运行的时候，还是使用针对地区的方法更稳妥一些，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"Hello World"</span></span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLowerCase());</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleLowerCase());</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toUpperCase());</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.toLocaleUpperCase());</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">HELLO WORLD</span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h3 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h3><p>match(): 在字符串上调用这个方法，本质上与调用RegExp的exec()方法相同，match()只接收一个参数，要么是一个正则表达式，要么是一个RegExp对象。<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> matches = text.match(pattern);</span><br><span class="line"><span class="built_in">console</span>.log(matches.index);   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(matches[<span class="number">0</span>]);    <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex);   <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>search()：这个方法返回字符串中的第一个匹配项的索引，如果没有找到匹配项，则返回-1，这个方法的唯一参数与match()方法相同。<br>如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"hello,bat,sat,fat"</span></span><br><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">var</span> pos = text.search(pattern);</span><br><span class="line"><span class="built_in">console</span>.log(pos);   <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>replace()方法：这个方法接受两个参数，第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的方法就是提供一个正则表达式，而且要指定全局（g）标志。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"cat,bat,sat,fat"</span></span><br><span class="line"><span class="keyword">var</span> result = text.replace(<span class="regexp">/at/g</span>,<span class="string">"12"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">c12,b12,s12,f12</span><br></pre></td></tr></table></figure>

<p>replace()方法的第二个参数也可以是一个函数，在只有一个匹配项的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match,pos,originalText</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(match) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&lt;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;lt;"</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&gt;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;gt;"</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"&amp;"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;amp;"</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"\""</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"&amp;quot"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(htmlEscape("&lt;p class=\"greeting\"&gt;Hello World!&lt;/p&gt;"));  #&amp;lt;p class=&amp;quotgreeting&amp;quot&amp;gt;Hello World!&amp;lt;/p&amp;gt;</span><br></pre></td></tr></table></figure>

<p>split()方法：这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式），split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colorText = <span class="string">"red,blue,green,yellow"</span>;</span><br><span class="line"><span class="keyword">var</span> color = colorText.split(<span class="string">","</span>);</span><br><span class="line"><span class="built_in">console</span>.log(color);                <span class="comment">//["red","blue","green","yellow"]</span></span><br></pre></td></tr></table></figure>

<h3 id="localeCompare-方法"><a href="#localeCompare-方法" class="headerlink" title="localeCompare()方法"></a>localeCompare()方法</h3><p>与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：<br>1、如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况是-1）；<br>2、如果字符串等于字符串参数，则返回0；<br>3、如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1）。<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stringValue = <span class="string">"yellow"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(stringValue.localeCompare(<span class="string">"black"</span>)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h3 id="fromCharCode-方法"><a href="#fromCharCode-方法" class="headerlink" title="fromCharCode()方法"></a>fromCharCode()方法</h3><p>接收一或多个字符编码，将它们转换为字符串。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.fromCharCode(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>));   <span class="comment">//"hello"</span></span><br></pre></td></tr></table></figure>

<h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><p>所有在全局作用域中定义的属性和方法都是Global对象的属性。除了isNaN()、isFinite()、parseInt()、parseFloat()等方法之外，Global对象还包含其他一些方法<br>这里主要介绍常用的eval()方法，eval()方法就像一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或JavaScript)字符串，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">"var msg = 'hello world'"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(msg);    <span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><h3 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.E</td>
<td>自然对数的底数，即常量e的值</td>
</tr>
<tr>
<td>Math.LN2</td>
<td>2的自然对数</td>
</tr>
<tr>
<td>Math.LN10</td>
<td>10的自然对数</td>
</tr>
<tr>
<td>Math.LOG2E</td>
<td>以2为底的e对数</td>
</tr>
<tr>
<td>Math.LOG10E</td>
<td>以10为底的e对数</td>
</tr>
<tr>
<td>Math.PI</td>
<td>Π的值</td>
</tr>
<tr>
<td>Math.SQRT1_2</td>
<td>1/2的平方根</td>
</tr>
<tr>
<td>Math.SQRt2</td>
<td>2的平方根</td>
</tr>
</tbody></table>
<h3 id="Math对象的方法"><a href="#Math对象的方法" class="headerlink" title="Math对象的方法"></a>Math对象的方法</h3><p>min()、max()方法用于确定一组数值中的最小最大值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">74</span>,<span class="number">51</span>,<span class="number">65</span>,<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max);     <span class="comment">//89</span></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">74</span>,<span class="number">51</span>,<span class="number">65</span>,<span class="number">12</span>);</span><br><span class="line"><span class="built_in">console</span>.log(min);    <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>舍入方法：Math.ceil()、Math.floor()、Math.round()<br>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；<br>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；<br>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数。</p>
<h3 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h3><p>Math.random()方法返回介于0到1之间的一个随机数，不包括0和1</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.abs(num)</td>
<td>返回num的绝对值</td>
<td>Math.asin(x)</td>
<td>返回x的反正弦值</td>
</tr>
<tr>
<td>Math.exp(num)</td>
<td>返回Math.E的num次幂</td>
<td>Math.atan(x)</td>
<td>返回x的反正切值</td>
</tr>
<tr>
<td>Math.log(num)</td>
<td>返回num的自然对数</td>
<td>Math.atan2(y,x)</td>
<td>返回y/x的反正切值</td>
</tr>
<tr>
<td>Math.pow(num,power)</td>
<td>返回num的power次幂</td>
<td>Math.cos(x)</td>
<td>返回x的余弦值</td>
</tr>
<tr>
<td>Math.sqrt(num)</td>
<td>返回num的平方根</td>
<td>Math.sin(x)</td>
<td>返回x的正弦值</td>
</tr>
<tr>
<td>Math.acos(x)</td>
<td>返回x的反余弦值</td>
<td>Math.tan(x)</td>
<td>返回x的正切值</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>高级特性</title>
    <url>/blog/2020/04/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取一个list或tuple的部分元素是非常常见的操作，例如，一个lst如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br></pre></td></tr></table></figure>

<p>用切片可以选择任意位置取元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[<span class="number">0</span>:<span class="number">3</span>]  <span class="comment">#取前三个元素</span></span><br><span class="line">L[:]   <span class="comment">#全部复制</span></span><br><span class="line">L[<span class="number">-2</span>:] <span class="comment">#从倒数第二个向后取</span></span><br></pre></td></tr></table></figure>

<p>输出结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line">[<span class="string">'Bob'</span>, <span class="string">'Jack'</span>]]</span><br></pre></td></tr></table></figure>

<p>同理字符串也可以这样操作</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以用在其他可迭代对象上。<br>举例：dict迭代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    print(key)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p><strong>因为dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。</strong><br><strong>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，<br>可以用for k, v in d.items()。</strong><br>当我们使用for循环时，只要作用于一个可迭代对象，for循环就可以正常运行，而我们不太关心该对象究竟是list还是其他数据类型。<br>那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collection <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>,Iterable)  <span class="comment">#是否可迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>若对list实现类似Java那样的下标循环，可以使用Python内置的enumerate函数可以把一个list变成索引-元素对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(i, value)</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure>

<p>请使用迭代查找一个list中最小和最大值，并返回一个tuple：<br>自己写的示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinAndMax</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="keyword">if</span> L==[]:</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">None</span>,<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        min=max=L[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> L:</span><br><span class="line">            <span class="keyword">if</span> i&lt;min:</span><br><span class="line">                min=i</span><br><span class="line">            <span class="keyword">if</span> i&gt;max:</span><br><span class="line">                max=i</span><br><span class="line">        <span class="keyword">return</span>(min,max)</span><br></pre></td></tr></table></figure>

<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。<br>举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用list(range(1, 11))：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>   L.append(x * x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<p>还可以使用两层循环，可以生成全排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">[<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br></pre></td></tr></table></figure>

<p>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value,列表生成式也可以使用两个变量来生成list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; d = &#123;<span class="string">'x'</span>: <span class="string">'A'</span>, <span class="string">'y'</span>: <span class="string">'B'</span>, <span class="string">'z'</span>: <span class="string">'C'</span> &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[k + <span class="string">'='</span> + v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items()]</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'y=B'</span>, <span class="string">'x=A'</span>, <span class="string">'z=C'</span>]</span><br></pre></td></tr></table></figure>

<p>练习题： L1为 [‘Hello’, ‘World’, 18, ‘Apple’, None]，输出 L2为 [‘hello’, ‘world’, ‘apple’]<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L2 = [i.lower() <span class="keyword">for</span> i <span class="keyword">in</span> L1 <span class="keyword">if</span> isinstance(i, str)==<span class="literal">True</span>]</span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。<br>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。<br>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt; L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br></pre></td></tr></table></figure>

<p>创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(g)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误<br>不想一个一个打印也可以用for循环进行打印</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line"></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>

<p>第二种创建generator的办法是使用yield关键字<br>generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，<br>在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。<br>练习题：杨辉三角</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">                <span class="number">1</span></span><br><span class="line">            <span class="number">1</span>       <span class="number">1</span></span><br><span class="line">        <span class="number">1</span>       <span class="number">2</span>       <span class="number">1</span></span><br><span class="line">    <span class="number">1</span>       <span class="number">3</span>       <span class="number">3</span>       <span class="number">1</span></span><br><span class="line"><span class="number">1</span>       <span class="number">4</span>       <span class="number">6</span>       <span class="number">4</span>       <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>把每一行看做一个list，试写一个generator，不断输出下一行的list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangles</span><span class="params">()</span>:</span></span><br><span class="line">    a=[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a=[sum(i) <span class="keyword">for</span> i <span class="keyword">in</span> zip([<span class="number">0</span>]+a,a+[<span class="number">0</span>])]</span><br><span class="line">n=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> triangles():</span><br><span class="line">    print(t)</span><br><span class="line">    n=n+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>凡是可作用于for循环的对象都是Iterable类型；<br>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；<br>集合等数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。<br>Python的for循环本质上就是通过不断调用next()函数实现的，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>实际上完全等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先获得Iterator对象:</span></span><br><span class="line">it = iter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 循环:</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获得下一个值:</span></span><br><span class="line">        x = next(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># 遇到StopIteration就退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用函数</title>
    <url>/blog/2020/05/10/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval()函数"></a>eval()函数</h2><ul>
<li>1.定义：eval() 函数用来执行一个字符串表达式，并返回表达式的值</li>
<li>2.语法<div class="note info">
            <p>eval(expression[, globals[, locals]])</p><ul><li>expression – 表达式。</li><li>globals – 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。</li><li>locals – 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</li></ul>
          </div>

</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;x = <span class="number">7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval( <span class="string">'3 * x'</span> )</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'pow(2,2)'</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'2 + 2'</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n=<span class="number">81</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">"n + 4"</span>)</span><br><span class="line"><span class="number">85</span></span><br></pre></td></tr></table></figure>

<h2 id="python内置进制转换方法"><a href="#python内置进制转换方法" class="headerlink" title="python内置进制转换方法"></a>python内置进制转换方法</h2><p>使用Python内置函数：bin()、oct()、int()、hex()可实现进制转换。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输入一个十进制的数值字符串。输出该数值的十六进制字符串。</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = hex(int(input(),<span class="number">10</span>))  <span class="comment">#输入10</span></span><br><span class="line">        print(a)      <span class="comment">#输出oxa</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>递归函数</title>
    <url>/blog/2020/04/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>在函数内部，可以调用其他函数，如果一个函数在内部调用自身本身，这个函数就是递归函数<br>举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：<br>fact(n) = n! = 1 x 2 x 3 x … x (n-1) x n = (n-1)! x n = fact(n-1) x n<br>所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。<br>于是，fact(n)用递归的方式写出来就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">100</span>)</span><br><span class="line"><span class="number">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>递归函数的优点是定义简单，逻辑清晰，使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出</p>
<h2 id="尾优化"><a href="#尾优化" class="headerlink" title="尾优化"></a>尾优化</h2><p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以把循环看成一种特殊的尾递归函数也是可以的<br>尾递归是指，在函数返回的时候，调用自身本身，并且return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。<br>上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span><span class="params">(num, product)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>

<p>可以看到，return fact_iter(num - 1, num * product) 仅返回递归函数本身，num - 1和 num * product在函数调用前就会被计算，不影响函数调用。<br>fact(5)对应的fact_iter(5, 1)的调用如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">===&gt; fact_iter(5, 1)</span><br><span class="line">===&gt; fact_iter(4, 5)</span><br><span class="line">===&gt; fact_iter(3, 20)</span><br><span class="line">===&gt; fact_iter(2, 60)</span><br><span class="line">===&gt; fact_iter(1, 120)</span><br><span class="line">===&gt; 120</span><br></pre></td></tr></table></figure>

<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。<br>遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。</p>
]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 基础</title>
    <url>/blog/2020/04/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型分为整数、浮点数、字符串、布尔值和空值</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量可以是数字与任意数据类型</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>字符编码使用UTF-8标准</p>
<h3 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h3><p>Python的字符串支持多语言，对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符<br>由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。<br>Python对bytes类型的数据用带b前缀的单引号或双引号表示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="string">b'ABC'</span></span><br></pre></td></tr></table></figure>

<p>注意：区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节</p>
<p>以Unicode表示的str通过encode()方法可以编码为指定的bytes<br>英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。在bytes中，无法显示为ASCII字符的字节，用\x##显示。反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法<br>len()函数计算的是str的字符数，如果换成bytes，len()函数计算字节数</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><div class="note info">
            <p>\n: 换行符<br>\t: 空格符<br>\0：空字符<br>原始字符串： 取消转义<br>a = r”D:\学习资料\python-工作\01、python基础”</p>
          </div>

<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。<br>常见的占位符有：%d（整数） %f（浮点数） %s（字符串） %x（十六进制整数）<br>还有一种方式是format()方法<br>使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'</span>.format(<span class="string">'小明'</span>, <span class="number">17.125</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="数学运算符"><a href="#数学运算符" class="headerlink" title="数学运算符"></a>数学运算符</h3><div class="note info">
            <p>+: 用于拼接两个容器<br>+=：用原容器与右侧容器拼接，并重新绑定变量<br>*：重复生成容器元素（容器与数字相乘，生成重复元素）<br>*=：用原容器生成重复元素，并重新绑定变量<br>&lt; &lt;= &gt;= &gt; == !=: 依次比较两个容器中元素，一但不同则返回结果（比较的是编码值，从第一个开始，依次往后）</p>
          </div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_01 = <span class="string">"悟空"</span></span><br><span class="line">str_02 = <span class="string">"八戒"</span></span><br><span class="line">print(str_01 + str_02) <span class="comment">#悟空八戒</span></span><br><span class="line">str_01 *= <span class="number">2</span>  </span><br><span class="line">print(str_01)   <span class="comment">#悟空悟空</span></span><br><span class="line">print(<span class="string">"Abc"</span> &gt; <span class="string">"adc"</span>) <span class="comment">#False</span></span><br></pre></td></tr></table></figure>

<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><p>语法： 数据 in 序列<br>       数据 not in 序列<br>作用： 如果在指定的序列中找到值，返回bool类型</p>
<h3 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h3><p>作用：访问容器元素<br>语法：容器[整数]<br>说明：正向索引从0开始，第二个为1，最后一个为length-1<br>      反向索引从-1开始，倒数第二个为-2，倒数最后一个为-length<br><strong>注意：索引不能越界。</strong></p>
<h3 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片slice</h3><p>作用：从容器中取出相应的元素重新组成一个容器<br>语法：容器[(开始索引):(结束索引)(:(步长))]<br>        小括号括起的部分代表可省略<br>说明：结束索引不包含该位置元素<br>      步长是切片每次获取完当前元素后移动的偏移量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_04 = <span class="string">"abcde"</span></span><br><span class="line">print(str_04[<span class="number">0</span>]) <span class="comment">#a</span></span><br><span class="line">print(str_04[len(str_04)<span class="number">-1</span>]) <span class="comment">#e</span></span><br><span class="line">print(str_04[<span class="number">-1</span>]) <span class="comment">#e</span></span><br><span class="line">print(str_04[<span class="number">0</span>:<span class="number">3</span>:<span class="number">1</span>]) <span class="comment">#abc</span></span><br><span class="line">print(str_04[::]) <span class="comment">#abcde</span></span><br><span class="line">print(str_04[::<span class="number">-1</span>]) <span class="comment">#edcba</span></span><br></pre></td></tr></table></figure>

<h3 id="拼接与拆分函数"><a href="#拼接与拆分函数" class="headerlink" title="拼接与拆分函数"></a>拼接与拆分函数</h3><ul>
<li><ol>
<li>将多个字符串拼接为一个字符串<br>result = “连接符”.join(列表)</li>
</ol>
</li>
<li><ol start="2">
<li>将一个字符串拆分为多个<br>列表 = “a-b-c-d”.split(“分隔符”)</li>
</ol>
</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list操作"><a href="#list操作" class="headerlink" title="list操作"></a>list操作</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure>
<p>创建list有两种办法，一种是[元素1，元素2,…],另一种是list(可迭代对象)<br>变量classmates就是一个list，list的索引是从0开始的，最后一个元素的索引是len(classmates)-1<br>除此之外，还可以用-1做索引,以此类推-2、-3等等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;classmates[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'Tracy'</span></span><br></pre></td></tr></table></figure>

<p><strong>list中的经常使用的方法：</strong></p>
<ul>
<li>1append()<br>list是一个可变的有序表，所以，可以往list中追加元素到末尾</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.append(<span class="string">'Adm'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adm'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>2insert()<br>list可以把元素插入到指定的位置，比如索引号为1的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.insert(<span class="number">1</span>, <span class="string">'Jack'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>, <span class="string">'Adm'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>3pop()<br>删除list末尾的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Jack'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure>

<p>pop(i)是删除指定位置的元素</p>
<ul>
<li>4删除指定的元素remove(要删除的元素)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">classmates = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line">classmates.remove(<span class="string">'Bob'</span>) <span class="comment"># ['Michael','Tracy']</span></span><br></pre></td></tr></table></figure></li>
<li>4把某个元素替换成别的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates[<span class="number">1</span>] = <span class="string">'Sarah'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates</span><br><span class="line">[<span class="string">'Michael'</span>, <span class="string">'Sarah'</span>, <span class="string">'Tracy'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>5list元素也可以是另一个list，比如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [<span class="string">'python'</span>, <span class="string">'java'</span>,[<span class="string">'asp'</span>, <span class="string">'php'</span>], <span class="string">'scheme'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>6list获取元素（索引，切片）<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_01 = list(<span class="string">'abcde'</span>)</span><br><span class="line"><span class="comment"># 获取前三个元素</span></span><br><span class="line">print(list_01[:<span class="number">3</span>]) <span class="comment">#['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="list的深拷贝与浅拷贝"><a href="#list的深拷贝与浅拷贝" class="headerlink" title="list的深拷贝与浅拷贝"></a>list的深拷贝与浅拷贝</h3><pre><code>浅拷贝：是在复制过程中只拷贝一层变量，不会复制深层变量绑定的对象的复制过程。
深拷贝：复制整个依赖的变量。</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 浅拷贝，只拷贝一层变量</span></span><br><span class="line">list_01 = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">list_o2 = list01.copy()</span><br><span class="line">list_01[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">200</span></span><br><span class="line">print(list_02[<span class="number">1</span>][<span class="number">0</span>]) <span class="comment"># 200</span></span><br><span class="line"><span class="comment"># 深拷贝，复制整个依赖的变量</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">list_01 = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">list_02 = copy.deepcopy(list_01)</span><br><span class="line">list_01[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">200</span></span><br><span class="line">print(list_02[<span class="number">1</span>][<span class="number">0</span>]) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple是另一种有序列表即元祖，与list非常类似，但是tuple一旦初始化后就不能修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>classmates(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure>

<p>现在这个classmates不能修改了，没有append，insert，pop等方法，只能正常使用classmates[0],classmates[-1],但是不能赋值成其他元素。<br>使得代码更安全<br>定义只有一个元素的tuple时必须加逗号，避免歧义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这是因为Python规定，这种情况下，按小括号进行计算，计算结果自然是1。<br>tuple里也可以定义可变的list</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'A'</span>, <span class="string">'B'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">'X'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">'Y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'X'</span>, <span class="string">'Y'</span>])</span><br></pre></td></tr></table></figure>

<h3 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"> </span><br><span class="line">tup1 = (<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> )</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> <span class="string">"tup1[0]: "</span>, tup1[<span class="number">0</span>]    <span class="comment">#tup1[0]:  physics</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"tup2[1:5]: "</span>, tup2[<span class="number">1</span>:<span class="number">5</span>] <span class="comment"># tup2[1:5]:  (2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure>

<h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>元组中的元素值是不允许删除的，但我们可以使用del来删除整个元组，如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>)</span><br><span class="line"><span class="keyword">print</span> tup</span><br><span class="line"><span class="keyword">del</span> tup</span><br><span class="line"><span class="keyword">print</span> <span class="string">"After deleting tup : "</span></span><br><span class="line"><span class="keyword">print</span> tup  <span class="comment">#NameError: name 'tup' is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h3><table>
<thead>
<tr>
<th>Python表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>len((1,2,3))</td>
<td>3</td>
<td>计算元素个数</td>
</tr>
<tr>
<td>(1,2,3) + (4,5,6)</td>
<td>(1,2,3,4,5,6)</td>
<td>连接</td>
</tr>
<tr>
<td>(‘Hi!’,)*4</td>
<td>(‘Hi!’,’Hi!’,’Hi!’,’Hi!’)</td>
<td>复制</td>
</tr>
<tr>
<td>3 in (1,2,3)</td>
<td>True</td>
<td>元素是否存在</td>
</tr>
<tr>
<td>for x in (1,2,3):print x</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody></table>
<p><strong>元组索引、截取与列表相同。</strong></p>
<h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><ul>
<li><ol>
<li>cmp(tuple1,tuple2):比较两个元组元素<br>如果比较的元素是同类型的,则比较其值,返回结果。<br>如果两个元素不是同一种类型,则检查它们是否是数字。<br>如果是数字,执行必要的数字强制类型转换,然后比较。<br>如果有一方的元素是数字,则另一方的元素”大”(数字是”最小的”)<br>否则,通过类型名字的字母顺序进行比较。<br>如果有一个列表首先到达末尾,则另一个长一点的列表”大”。<br>示例如下：</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1, tuple2 = (<span class="number">123</span>, <span class="string">'xyz'</span>), (<span class="number">456</span>, <span class="string">'abc'</span>)</span><br><span class="line"><span class="keyword">print</span> cmp(tuple1, tuple2);    <span class="comment"># -1</span></span><br><span class="line"><span class="keyword">print</span> cmp(tuple2, tuple1);    <span class="comment"># 1</span></span><br><span class="line">tuple3 = tuple2 + (<span class="number">786</span>,);</span><br><span class="line"><span class="keyword">print</span> cmp(tuple2, tuple3)     <span class="comment"># -1</span></span><br><span class="line">tuple4 = (<span class="number">123</span>, <span class="string">'xyz'</span>)</span><br><span class="line"><span class="keyword">print</span> cmp(tuple1, tuple4)     <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="2">
<li>len(tuple) 计算元组元素个数<br>示例如下：</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple01 = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(tuple01) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="3">
<li>max(tuple) 返回元组中元素最大值</li>
</ol>
</li>
<li><ol start="4">
<li>min(tuple) 返回元组中元素最小值</li>
</ol>
</li>
<li><ol start="5">
<li>tuple(list) 将列表转换为元组</li>
</ol>
</li>
</ul>
<p>如果我们用尽了两个列表的元素而且所 有元素都是相等的,那么结果就是个平局,就是说返回一个 0。</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>if、 if else、 if elif else</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'your age is'</span>, age)</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'your age is'</span>, age)</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'your age is'</span>, age)</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if elif else语句"></a>if elif else语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'adult'</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    print(<span class="string">'teenager'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'kid'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>Python 的循环有两种，一种是for…in循环，另一种是while循环。</p>
<h3 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h3><p>作用是依次把list或者tuple中的每个元素迭代出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Michael</span><br><span class="line">Bob</span><br><span class="line">Tracy</span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">um = <span class="number">0</span></span><br><span class="line">n = <span class="number">99</span></span><br><span class="line"><span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">    sum = sum + n</span><br><span class="line">    n = n - <span class="number">2</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p>在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break语句可以提前结束退出循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span></span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span></span><br><span class="line">    print(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="number">10</span>:</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>: <span class="comment"># 如果n是偶数，执行continue语句</span></span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># continue语句会直接继续下一轮循环，后续的print()语句不会执行</span></span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure>


<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'Michael'</span>]</span><br><span class="line"><span class="number">95</span></span><br></pre></td></tr></table></figure>
<p>dict.items(),dict.key(),dict.values()三种方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key,item <span class="keyword">in</span> d.items():</span><br><span class="line">    <span class="keyword">print</span> (key,item)  <span class="comment"># key value</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d.keys():</span><br><span class="line">    <span class="keyword">print</span> (key)  <span class="comment"># key</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">    print(value)  <span class="comment"># value</span></span><br></pre></td></tr></table></figure>

<p>注意事项：<br>1.一个key对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉<br>2.key不存在，dict就会报错<br>避免方式：一是通过in判断key是否存在<br>         二是通过dict的get()方法，如果key不存在，可以返回None，或者自己指定的value<br>         <strong>注意：返回None时在python的交互环境中不显示。</strong><br>3.删除key，用pop(key)方法，对应的value也会从dict中删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建空字典</span></span><br><span class="line">d01 = &#123;&#125;</span><br><span class="line">d02 = dict()</span><br><span class="line"><span class="comment"># 创建有值的字典</span></span><br><span class="line">d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="comment"># 查找</span></span><br><span class="line">print(d.[<span class="string">'Michel'</span>])  <span class="comment"># 95</span></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">d[<span class="string">'Jack'</span>] = <span class="number">90</span></span><br><span class="line">print(d)   <span class="comment">#&#123;'Michael': 95, 'Bob': 75, 'Tracy': 85, 'Jack': 90&#125;</span></span><br><span class="line"><span class="comment">#判断key是否存在</span></span><br><span class="line">print(<span class="string">'Thomas'</span> <span class="keyword">in</span> d)   <span class="comment">#False</span></span><br><span class="line">print(d.get(<span class="string">'Thomas'</span>), <span class="number">-1</span>)  <span class="comment"># -1(不存在返回指定的-1)</span></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">d.pop(<span class="string">'Michel'</span>)</span><br><span class="line">print(d)   <span class="comment">#&#123;'Bob': 75, 'Tracy': 85, 'Jack': 90&#125;</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">'Bob'</span>]</span><br><span class="line">print(d) <span class="comment"># &#123;'Tracy': 85, 'Jack': 90&#125;</span></span><br></pre></td></tr></table></figure>

<p>###简单实际问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    判断一个字符串中每个字符出现的次数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">str_input = <span class="string">'abcdbcd'</span></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> str_input:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">        result[item] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result[item] += <span class="number">1</span></span><br><span class="line">print(result) <span class="comment">#&#123;'a': 1, 'b': 2, 'c': 2, 'd': 2&#125;</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>和list相比，dict有以下几个特点：</p><ul><li><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li></ol></li><li><ol start="2"><li>需要占用大量的内存，内存浪费多。<br>而list相反：</li></ol></li><li><ol><li>查找和插入的时间随着元素的增加而增加；</li></ol></li><li><ol start="2"><li>占用内小，浪费内存很少。<br>所以，dict是用空间来换取时间的一种方式。<strong>注意：dict的key必须是不可变元素。</strong></li></ol></li></ul>
          </div>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，<strong>在set中，没有重复的key。</strong><br>要创建一个set，需要提供一个list作为输入集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。<br>重复元素在set中自动被过滤：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>set的增删方法：</strong></p>
<p>add(key): 添加元素到set中，可重复添加，但是不会有效果<br>remove(key): 删除元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(s)  <span class="comment"># &#123;1,2,3&#125;</span></span><br><span class="line">s.add(<span class="number">4</span>)</span><br><span class="line">print(s) <span class="comment"># &#123;1,2,3,4&#125;</span></span><br><span class="line">s.remove(<span class="number">1</span>)</span><br><span class="line">print(s) <span class="comment"># &#123;2,3,4&#125;</span></span><br></pre></td></tr></table></figure>

<p>set可以看成数学意义上的无序和无重复元素的集合。因此，两个set可以做数学意义上的交集、并集操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">s2 = set([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(s1 &amp; s2)  <span class="comment"># &#123;2,3&#125;</span></span><br><span class="line">print(s1 | s2)  <span class="comment"># &#123;1,2,3,4&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：<code>set</code> 与 <code>dict</code> 内部进行哈希运算，所以即使是排序好的list或tuple放进去也会乱序，需要重新排序，示例如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a, res = int(input()), list()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(a): res.append(int(input()))</span><br><span class="line">        res.sort()</span><br><span class="line">        print(res)   <span class="comment">#[5, 12, 23]</span></span><br><span class="line">        <span class="comment">#d = set(res)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> set(res): print(i)  <span class="comment">#  12  5   23(乱序)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> sorted(set(res)): print(i)  <span class="comment"># 5  12   23</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h2><p>str是不变对象，list是可变对象。<br>对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">'c'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>]</span><br><span class="line"><span class="comment"># 排序函数</span></span><br><span class="line">a.sort()</span><br><span class="line">print(a)  <span class="comment"># ['a'.'b','c']</span></span><br><span class="line"><span class="comment"># 反转函数</span></span><br><span class="line">a.reverse()  <span class="comment">#['c', 'b', 'a']</span></span><br></pre></td></tr></table></figure>

<p>而对于不可变对象，如str，操作如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">'abc'</span></span><br><span class="line">print(a.replace(<span class="string">'a'</span>,<span class="string">'A'</span>))  <span class="comment"># 'Abc'</span></span><br><span class="line">print(a)   <span class="comment"># 'abc'</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/blog/2020/04/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>python是面向对象编程的程序语言<br>函数就是面向过程的程序设计的基本单元。<br>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，<br>因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。<br>而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出。</p>
<h2 id="函数传参几种基本方式"><a href="#函数传参几种基本方式" class="headerlink" title="函数传参几种基本方式"></a>函数传参几种基本方式</h2><h3 id="实参传递方式"><a href="#实参传递方式" class="headerlink" title="实参传递方式"></a>实参传递方式</h3><ul>
<li><ol>
<li>位置传参：实参与形参的位置对应</li>
</ol>
</li>
<li><ol start="2">
<li>序列传参： 用*将序列拆分后与形参的位置依次对应</li>
</ol>
</li>
<li><ol start="3">
<li>关键字传参：实参根据形参的名称进行对应</li>
</ol>
</li>
<li><ol start="4">
<li>字典传参： 用**将字典拆分后与形参的名称进行对应</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func01(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  <span class="comment">#位置传参</span></span><br><span class="line">func02(*[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="comment">#序列传参</span></span><br><span class="line">func03(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment">#关键字传参</span></span><br><span class="line">func04(**&#123;<span class="string">"a"</span>:<span class="number">1</span>,<span class="string">"b"</span>:<span class="number">2</span>,<span class="string">"c"</span>:<span class="number">3</span>&#125;) <span class="comment">#字典传参</span></span><br></pre></td></tr></table></figure>

<h3 id="形参传递方式"><a href="#形参传递方式" class="headerlink" title="形参传递方式"></a>形参传递方式</h3><ul>
<li><ol>
<li>默认传参：不写参数的情况下，根据位置使用默认值</li>
</ol>
</li>
<li><ol start="2">
<li>星号元组形参：用于收集多余的位置形参，一般命名为arg，形参列表中最多只有一个。<br>def 函数名(a,b,*arg):<br>   函数体</li>
</ol>
</li>
<li>3.命名关键字形参：传递的时候强制使用关键字<br>  def 函数名(*a,b): 函数体</li>
<li>4.双星号字典形参：<br>  def 函数名(**kwargs): 函数体</li>
<li>*参数顺序：位置形参–&gt;星号元组形参–&gt;命名关键字形参–&gt;双星号字典形参</li>
</ul>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><p>既可以将函数赋值结果给变量，也可以将函数本身赋值给变量，即变量可以指向函数<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = abs(<span class="number">-10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f=abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;built-<span class="keyword">in</span> function abs&gt;</span><br></pre></td></tr></table></figure>

<p>变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = abs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">-10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br>一个最简单的高阶函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure>

<p><strong>编写高阶函数，就是让函数的参数能够接收别的函数。</strong></p>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><p>Python内建了map()和reduce()函数。<br>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple(r)</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>)</span><br></pre></td></tr></table></figure>

<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数或者tuple()函数让它把整个序列都计算出来并返回一个list<br>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>

<p>练习1: 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="keyword">return</span> name.capitalize()</span><br><span class="line">&gt;&gt;&gt;<span class="comment"># 测试:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L1 = [<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L2 = list(map(normalize, L1))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(L2)</span><br><span class="line">[<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>]</span><br></pre></td></tr></table></figure>

<p>练习2: Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">prod</span><span class="params">(L)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * y, L)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'3 * 5 * 7 * 9 ='</span>, prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> prod([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]) == <span class="number">945</span>:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>  print(<span class="string">'测试成功!'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   print(<span class="string">'测试失败!'</span>)</span><br><span class="line"><span class="number">3</span> * <span class="number">5</span> * <span class="number">7</span> * <span class="number">9</span> = <span class="number">945</span></span><br><span class="line">测试成功!</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>Python内建的filter()函数用于过滤序列,用filter()这个高阶函数，关键在于正确实现一个“筛选”函数。<br>filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list.<br>示例如下：<br>用filter求素数<br>计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：<br>首先，列出从2开始的所有自然数，构造一个序列：<br>2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …<br>取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：<br>3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …<br>取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：<br>5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …<br>取新序列的第一个数5，然后用5把序列的5的倍数筛掉：<br>7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, …<br>不断筛下去，就可以得到所有的素数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用Python来实现这个算法，可以先构造一个从3开始的奇数序列：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_odd_iter</span><span class="params">()</span>:</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"><span class="comment"># 然后定义一个筛选函数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_not_divisible</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></span><br><span class="line"><span class="comment"># 最后，定义一个生成器，不断返回下一个素数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = _odd_iter() <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br><span class="line"><span class="comment">#由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件：</span></span><br><span class="line"><span class="comment"># 打印1000以内的素数:</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>练习3: 回数是指从左向右读和从右向左读都是一样的数，例如 12321 ， 909 。请利用 filter() 滤掉非回数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方案一:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(n)</span>:</span></span><br><span class="line">    nn = str(n) <span class="comment">#转成字符串</span></span><br><span class="line">    <span class="keyword">return</span> nn == nn[::<span class="number">-1</span>]   <span class="comment">#反转字符串并对比原字符串返回true/false</span></span><br><span class="line"><span class="keyword">print</span> list(filter(is_palindrome,range(<span class="number">1</span>,<span class="number">1000</span>)))</span><br><span class="line"></span><br><span class="line">方案二:</span><br><span class="line"><span class="keyword">print</span> list(filter(<span class="keyword">lambda</span> n : str(n)==str(n)[::<span class="number">-1</span>],range(<span class="number">1</span>,<span class="number">1000</span>))) <span class="comment">#str(n)同上</span></span><br></pre></td></tr></table></figure>

<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted()也是一个高阶函数，用sorted()排序的关键在于实现一个映射函数<br>练习4：假设我们用一组tuple表示学生名字和成绩：L = [(‘Bob’, 75), (‘Adam’, 92), (‘Bart’, 66), (‘Lisa’, 88)]<br>请用sorted()对上述列表分别按名字排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_name</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">0</span>].lower()</span><br><span class="line">L2 = sorted(L, key=by_name)</span><br><span class="line">print(L2)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br></pre></td></tr></table></figure>

<p>再按成绩从高到低排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_score</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> t[<span class="number">1</span>]</span><br><span class="line">L2 = sorted(L, key=by_score)</span><br><span class="line">print(L2)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span><span class="params">(*args)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>       ax = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>       <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>           ax = ax + n</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>       <span class="keyword">return</span> ax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="keyword">return</span> sum</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)  <span class="comment">#当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at <span class="number">0x101c6ed90</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()                 <span class="comment">#调用函数f时，才真正计算求和的结果</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1==f2              <span class="comment">#f1()和f2()的调用结果互不影响。</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>注意到返回的函数在其定义内部引用了局部变量args，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。<br>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">()</span>:</span></span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。<br>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2()</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f3()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。<br><strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong><br>练习5：利用闭包返回一个计数器函数，每次调用它返回递增整数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createCounter</span><span class="params">()</span>:</span></span><br><span class="line">    s = [<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></span><br><span class="line">        s[<span class="number">0</span>] = s[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line">counterA = createCounter()</span><br><span class="line">print(counterA(), counterA(), counterA(), counterA(), counterA()) <span class="comment"># 1 2 3 4 5</span></span><br><span class="line">counterB = createCounter()</span><br><span class="line"><span class="keyword">if</span> [counterB(), counterB(), counterB(), counterB()] == [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]:</span><br><span class="line">    print(<span class="string">'测试通过!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'测试失败!'</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">测试通过!</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。<br>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。<br>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x101c6ef28</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">5</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure>

<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'2015-3-25'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = now        <span class="comment">#由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line"><span class="number">2015</span><span class="number">-3</span><span class="number">-25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__   <span class="comment">#函数对象有一个__name__属性，可以拿到函数的名字</span></span><br><span class="line"><span class="string">'now'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">'now'</span></span><br></pre></td></tr></table></figure>

<p>假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。<br>简单例子如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            print(<span class="string">'%s %s():'</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<p>具体见廖雪峰学习网站，这里不具体介绍装饰器</p>
]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构1</title>
    <url>/blog/2020/05/11/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/</url>
    <content><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><ul>
<li><ol>
<li>数据<br>数据即信息的载体，是能够输入到计算机中并且能被计算机识别、存储和处理的符号总称。</li>
</ol>
</li>
<li><ol start="2">
<li>数据元素<br>数据元素是数据的基本单位，又称为记录(Recaord)。一般，数据元素由若干个基本项(或称字段、域、属性)组成。</li>
</ol>
</li>
<li><ol start="3">
<li>数据结构<br>数据结构指的是数据元素及数据元素之间的相互关系，或组织数据的形式。</li>
</ol>
</li>
</ul>
<h2 id="数据之间的结构关系"><a href="#数据之间的结构关系" class="headerlink" title="数据之间的结构关系"></a>数据之间的结构关系</h2><ul>
<li><ol>
<li>逻辑结构<br>表示数据之间的抽象关系（如邻接关系、从属关系等），按每个元素可能具有的直接前驱和直接后继数将逻辑结构分为“线性结构”和“非线性结构”两大类。</li>
</ol>
</li>
<li><ol start="2">
<li>存储结构<br>逻辑结构在计算机中的具体实现方法分为顺序存储方法、链接存储方法、索引存储方法、散列存储方法。</li>
</ol>
</li>
</ul>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是描述其逻辑结构，而通常会在线性表中进行查找、插入、删除等操作。线性表作为一种基本的数据结构，在计算机中的存储映像有两种，顺序存储结构和链式存储结构。</p>
<h3 id="线性表的顺序存储"><a href="#线性表的顺序存储" class="headerlink" title="线性表的顺序存储"></a>线性表的顺序存储</h3><ol>
<li>定义<br>若将线性表L=(a0,a1,…,an-1)中的各元素依次存储于计算机一片连续的存储空间，这种机制表示为线性表的顺序存储结构。</li>
<li>特点<div class="note info">
            <ul><li>逻辑上相邻的元素ai,ai+1,其存储位置也是相邻的；</li><li>存储密度高，方便对数据进行遍历查找；</li><li>对表的插入和删除等运算的效率较差。</li></ul>
          </div>

</li>
</ol>
<p>3.程序实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">L.append(<span class="number">10</span>)  <span class="comment">#尾部增加元素</span></span><br><span class="line">print(L)     <span class="comment">#[1, 2, 3, 4, 10]</span></span><br><span class="line">L.insert(<span class="number">1</span>,<span class="number">20</span>) <span class="comment">#插入元素</span></span><br><span class="line">print(L)  <span class="comment">#[1, 20, 2, 3, 4, 10]</span></span><br><span class="line">L.remove(<span class="number">1</span>) <span class="comment">#删除元素</span></span><br><span class="line">print(L)  <span class="comment">#[20, 2, 3, 4, 10]</span></span><br><span class="line">L[<span class="number">4</span>] = <span class="number">30</span> <span class="comment">#修改元素</span></span><br><span class="line">print(L) <span class="comment">#[20, 2, 3, 4, 30]</span></span><br><span class="line">print(L.index(<span class="number">2</span>)) <span class="comment">#3(查找)</span></span><br></pre></td></tr></table></figure>

<h3 id="线性表的链式存储"><a href="#线性表的链式存储" class="headerlink" title="线性表的链式存储"></a>线性表的链式存储</h3><ul>
<li><ol>
<li>定义<br>将线性表L=(a0,a1,…,an-1)中的各元素分布在存储器的不同存储块，称为结点，每个结点(尾结点除外)中都有一个指向下一个结点的引用，这样所得到的存储结构为链式结构。</li>
</ol>
</li>
<li><ol start="2">
<li>特点<div class="note info">
            <ul><li>逻辑上相邻的元素ai,ai+1,其存储位置不一定是相邻的；</li><li>存储稀疏，不必开辟存储空间；</li><li>对表的插入和删除等运算的效率较高；</li><li>逻辑结构复杂，不利于遍历。</li></ul>
          </div>
</li>
</ol>
</li>
<li><ol start="3">
<li>程序实现</li>
</ol>
</li>
</ul>
<div class="note info">
            <p>链式线性表思路:</p><ol><li>结点如何表示？<br> 自定义对象：对象即数据，对象属性即数据元素<br> 数据元素：有用数据，记录下一个对象地址的数据</li><li>如何建立关联？<br> a = Node(1)  a.val = 1  a.next = b<br> b = Node(2)  b.val = 2  b.next = None</li><li>实现什么样的链表操作？</li></ol>
          </div>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    单链表学习程序</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 创建结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,next=None)</span>:</span></span><br><span class="line">        self.val = val  <span class="comment"># 有用数据</span></span><br><span class="line">        self.next = next</span><br><span class="line"><span class="comment"># 链表的操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head = Node(<span class="literal">None</span>) <span class="comment">#链表的开头</span></span><br><span class="line">    <span class="comment"># 链表初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_list</span><span class="params">(self,data)</span>:</span></span><br><span class="line">        p = self.head   <span class="comment">#可移动变量p</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            p.next = Node(i)</span><br><span class="line">            p = p.next</span><br><span class="line"></span><br><span class="line">    <span class="comment">#遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        p = self.head.next</span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            print(p.val,end=<span class="string">' '</span>)</span><br><span class="line">            p = p.next</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在链表尾部插入新结点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self,node)</span>:</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">        p.next = Node(node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="comment">#判断链表是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.length() == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:<span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment">#清空链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.head.next = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 获取索引值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_item</span><span class="params">(self,index)</span>:</span></span><br><span class="line">        p = self.head.next</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; index <span class="keyword">and</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p = p.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"list index out of range"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> p.val</span><br><span class="line"></span><br><span class="line">    <span class="comment">#插入函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self,index,value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt; self.length():</span><br><span class="line">            <span class="keyword">raise</span> IndexError(<span class="string">"list index out of range"</span>)</span><br><span class="line">        p = self.head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; index:</span><br><span class="line">            p = p.next</span><br><span class="line">            i +=<span class="number">1</span></span><br><span class="line">        node = Node(value)</span><br><span class="line">        node.next = p.next</span><br><span class="line">        p.next = node</span><br><span class="line">    <span class="comment">#删除函数（按照值删除，多个的话删除第一个）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        p = self.head</span><br><span class="line">        <span class="keyword">while</span> p.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> p.next.val == item:</span><br><span class="line">                p.next = p.next.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p = p.next</span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">raise</span> ValueError(<span class="string">"x not in list"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 创建链表对象</span></span><br><span class="line">    link = LinkList()</span><br><span class="line">    <span class="comment"># 初始数据</span></span><br><span class="line">    l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">    link.init_list(l)   <span class="comment">#将数据插入链表</span></span><br><span class="line">    link.show()</span><br><span class="line">    link.append(<span class="number">8</span>)   <span class="comment">#在链表尾部插入一个新节点</span></span><br><span class="line">    link.show()</span><br><span class="line">    print(link.length())  <span class="comment">#获取链表长度</span></span><br><span class="line">    print(link.is_empty()) <span class="comment">#判断链表是否为空</span></span><br><span class="line">    <span class="comment"># link.clear()  #清空链表</span></span><br><span class="line">    <span class="comment"># print(link.is_empty()) #判断链表是否为空</span></span><br><span class="line">    print(link.get_item(<span class="number">3</span>)) <span class="comment">#获取到index等于3的位置的value</span></span><br><span class="line">    link.insert(<span class="number">0</span>,<span class="number">16</span>)  <span class="comment">#插入</span></span><br><span class="line">    link.show()</span><br><span class="line">    link.delete(<span class="number">3</span>) <span class="comment">#删除</span></span><br><span class="line">    link.show()</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li><p>1.定义：栈是限制在一端进行插入操作和删除操作的线性表（俗称堆栈），允许进行操作的一端称为“栈顶”，另一固定端称为“栈底”，当栈中没有元素时称为“空栈”。</p>
</li>
<li><ol start="2">
<li>特点：<ul>
<li>栈只能在一端进行数据操作</li>
<li>栈模型具有后进先出或者叫做先进后出的规律</li>
</ul>
</li>
</ol>
</li>
<li><ol start="3">
<li>栈的代码操作<br>栈的操作有入栈（压栈），出栈（弹栈），判断栈的空满等操作。<br>栈的功能：初始化、入栈、出栈和判断栈是否为空</li>
</ol>
</li>
</ul>
<h3 id="栈的顺序存储"><a href="#栈的顺序存储" class="headerlink" title="栈的顺序存储"></a>栈的顺序存储</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    栈的顺序存储结构</span></span><br><span class="line"><span class="string">    重点代码</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 自定义栈操作异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于列表实现顺序栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#约定列表的最后一个元素为栈顶</span></span><br><span class="line">        self._elems = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._elems:</span><br><span class="line">            <span class="keyword">raise</span> StackError(<span class="string">"stack is empty"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._elems[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,elem)</span>:</span></span><br><span class="line">        self._elems.append(elem)</span><br><span class="line">    <span class="comment">#出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._elems:</span><br><span class="line">            <span class="keyword">raise</span> StackError(<span class="string">"stack is empty"</span>)</span><br><span class="line">        <span class="keyword">return</span> self._elems.pop()</span><br><span class="line">    <span class="comment">#判断栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._elems == []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    st = SStack() <span class="comment">#初始化栈</span></span><br><span class="line">    <span class="comment"># print(st.top())</span></span><br><span class="line">    st.push(<span class="number">10</span>)</span><br><span class="line">    st.push(<span class="number">20</span>)</span><br><span class="line">    st.push(<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> st.is_empty():</span><br><span class="line">        print(st.pop()) <span class="comment"># 30  20  10</span></span><br></pre></td></tr></table></figure>

<p><strong>练习：监测一段文字中的括号是否为成对出现，如果不是，则报出括号匹配的错误问题</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> python_shujujiegou.sstack <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">text= <span class="string">'''Arithmetic (operations) between subclasses of datetime.date or datetime.datetime and datetime.timedelta objects now [return an instance] of the subclass, rather than the base class. (This also &#123;affects the (return) type of operations&#125; whose implementation (directly or indirectly) uses datetime.timedelta arithmetic, such as astimezone()). (Contributed by Paul Ganssle in bpo-32417.)'''</span></span><br><span class="line"></span><br><span class="line">parens = <span class="string">"()[]&#123;&#125;"</span> <span class="comment">#验证的括号</span></span><br><span class="line">left_parens = <span class="string">"([&#123;"</span></span><br><span class="line">opposite = &#123;<span class="string">')'</span>:<span class="string">'('</span>,<span class="string">']'</span>:<span class="string">'['</span>,<span class="string">'&#125;'</span>:<span class="string">'&#123;'</span>&#125; <span class="comment">#对应关系</span></span><br><span class="line"><span class="comment">#生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="comment"># i记录字符串索引</span></span><br><span class="line">    i,text_len = <span class="number">0</span>,len(text)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment">#逐个遍历字符串，如果没到结尾且不是括号就向后遍历</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; text_len <span class="keyword">and</span> text[i] <span class="keyword">not</span> <span class="keyword">in</span> parens:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= text_len:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">yield</span> text[i],i  <span class="comment">#生成括号字符和对应位置</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">st = SStack()  <span class="comment">#初始化栈</span></span><br><span class="line"><span class="keyword">for</span> pr,i <span class="keyword">in</span> generate(text):</span><br><span class="line">    <span class="keyword">if</span> pr <span class="keyword">in</span> left_parens:</span><br><span class="line">        st.push((pr,i)) <span class="comment">#将左括号及其位置入栈</span></span><br><span class="line">    <span class="keyword">elif</span> st.is_empty() <span class="keyword">or</span> st.pop()[<span class="number">0</span>] != opposite[pr]:</span><br><span class="line">        print(<span class="string">"Unmatching is found at %d for %s"</span> % (i,pr))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环正常结束，判断栈是否为空</span></span><br><span class="line">    <span class="keyword">if</span> st.is_empty():</span><br><span class="line">        print(<span class="string">"All parentheses are matched"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 有左括号没有匹配</span></span><br><span class="line">        e = st.pop()</span><br><span class="line">        print(<span class="string">"Unmatching is found at %d for %s"</span> % (e[<span class="number">1</span>],e[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>

<h3 id="栈的链式存储"><a href="#栈的链式存储" class="headerlink" title="栈的链式存储"></a>栈的链式存储</h3><p>链式存储栈的形式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">self._top  -&gt;   node  -&gt; node</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">    栈的链式存储(重点代码)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># 自定义栈操作异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment">#结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,next=None)</span>:</span></span><br><span class="line">        self.val = val  <span class="comment"># 有用数据</span></span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#标记栈顶位置</span></span><br><span class="line">        self._top = <span class="literal">None</span></span><br><span class="line">    <span class="comment">#判断栈为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._top == <span class="literal">None</span></span><br><span class="line">    <span class="comment">#入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        node = Node(item,self._top)</span><br><span class="line">        self._top = node</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty() == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> StackError(<span class="string">"stack is empty"</span>)</span><br><span class="line">        p = self._top</span><br><span class="line">        self._top = p.next</span><br><span class="line">        <span class="keyword">return</span> p.val</span><br><span class="line">    <span class="comment">#获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> self._top.val</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    st = LStack() <span class="comment">#初始化栈</span></span><br><span class="line">    print(st.is_empty())</span><br><span class="line">    st.push(<span class="number">10</span>)</span><br><span class="line">    st.push(<span class="number">20</span>)</span><br><span class="line">    st.push(<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> st.is_empty():</span><br><span class="line">        print(st.peek())</span><br><span class="line">        print(st.pop())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 面向对象的程序设计</title>
    <url>/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或者函数。</p>
<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>创建自定义对象的最简单方式就是创建一个object的实例，然后再为它添加属性和方法，创建对象有两种方式，最常用的是对象字面量语法形式，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>ECMAScript中有两种属性：数据属性和访问器属性。<br>数据属性：包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有4个描述其行为的特性，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[[Configurable]]: 表示能否通过<span class="keyword">delete</span>删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Enumerable]]: 表示能否通过<span class="keyword">for</span>-<span class="keyword">in</span>循环返回属性，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Writable]]: 表示能否修改属性的值，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Value]]: 包含这个属性的数据值，读取属性值的时候，从这个位置读，写入属性值的时候，把新值保存在这个位置，特性默认值为<span class="literal">undefined</span>。</span><br></pre></td></tr></table></figure>

<p>要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法，这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象，其中描述符对象的属性必须是：configurable、enumerable、writable和value，设置其中的一个或多个值，可以修改对应的特性值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">//"Nicholas"</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>访问器属性：访问器属性不包括数据值，它们包含一对儿getter和setter函数（不过，这两个函数都不是必须的），在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据，访问器属性有如下4个特性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[[Configurable]]: 表示能否通过<span class="keyword">delete</span>删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Enumerable]]: 表示能否通过<span class="keyword">for</span>-<span class="keyword">in</span>循环返回属性，特性默认值为<span class="literal">true</span>；</span><br><span class="line">[[Get]]: 在读取属性时调用的函数，默认值为<span class="literal">undefined</span>；</span><br><span class="line">[[<span class="built_in">Set</span>]]: 在写入属性时调用的函数，默认值为<span class="literal">undefined</span>。</span><br></pre></td></tr></table></figure>

<p>访问器属性同样不能直接定义，需要使用Object.defineProperty()来定义，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year: <span class="number">2004</span>,</span><br><span class="line">    edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2015</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition);    <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(book._year);      <span class="comment">//2015</span></span><br></pre></td></tr></table></figure>

<p>以上代码创建了一个book对象，并给它定义两个默认的属性：_year和edition。_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性，而访问器属性year则包含一个getter函数和一个setter函数，设置一个属性的值导致其他属性发生变化是使用访问器属性的常用方式。区别于python的访问限制。</p>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>Object.defineProperties() 方法可以通过描述符一次定义多个属性，这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应，实例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function() &#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以上代码在book对外上定义了两个数据属性（_year和edition)和一个访问器属性（year）。最终的对象与上面例子中的定义的对象相同。<br>唯一的区别是这里的属性都是在同一时间创建的。</p>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符，这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get、和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book,&#123;</span><br><span class="line">    _year: &#123;</span><br><span class="line">        value: <span class="number">2004</span></span><br><span class="line">    &#125;,</span><br><span class="line">    edition: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    year: &#123;</span><br><span class="line">        <span class="keyword">get</span>: function() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>: function() &#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>._year = newValue;</span><br><span class="line">                <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.value);      <span class="comment">//2004</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.configurable);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式抽象了创建具体对象的过程，考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1);</span><br><span class="line"><span class="built_in">console</span>.log(person2)</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="string">'Nicholas'</span>, <span class="attr">age</span>: <span class="number">29</span>, <span class="attr">job</span>: <span class="string">'Software Engineer'</span>, <span class="attr">sayName</span>: [<span class="built_in">Function</span>] &#125;</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">'Greg'</span>, <span class="attr">age</span>: <span class="number">27</span>, <span class="attr">job</span>: <span class="string">'Doctor'</span>, <span class="attr">sayName</span>: [<span class="built_in">Function</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象，可以无数次地调用这个函数，而且每次它都能返回一个包含三个属性一个方法的对象，解决了创建多个相似对象的问题，但是仍没有解决对象识别的为题（即怎样知道一个对象的类型）。</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>ECMAScript中的构造函数可用来创建特定类型的对象，像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法，将前面工厂模式的例子重写成构造函数如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1);</span><br><span class="line"><span class="built_in">console</span>.log(person2)</span><br></pre></td></tr></table></figure>

<p>输出结果与上面相同，Person()与createPerson()函数存在以下几点不同：</p>
<ul>
<li>没有显示地创建对象；</li>
<li>直接将属性和方法赋给了this对象；</li>
<li>没有return语句</li>
</ul>
<p><strong>注意：构造函数的函数名按照惯例以大写字母开头，创建构造函数的新实例必须使用new操作符</strong>。<br>构造函数胜过工厂函数的地方就是创建自定义的构造函数可以将它的实例标识为一种特定的类型，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person);   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person)    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>将构造函数当作函数：</strong>构造函数与其他函数的唯一区别在于调用它们的方式不同，任何函数，只要通过new操作符来调用，就可以作为构造函数；如果不通过new操作符来调用，就是普通函数。如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当作构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">person.sayName();  <span class="comment">// "Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);   <span class="comment">//添加到window</span></span><br><span class="line"><span class="built_in">window</span>.sayName();   <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Keisten"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName();   <span class="comment">//"Keisten"</span></span><br></pre></td></tr></table></figure>

<p><strong>构造函数仍然存在的一些问题：</strong>使用构造函数的主要问题是每个方法都要在每个实例上重新创建一遍，比如person1与person2都有一个名为sayName()方法，但不是同一个Function()的实例，也可以将方法转移到构造函数之外，定义在全局作用域上，但是这样就没有封装性可言了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName)   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性和方法，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法，就是不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>新对象的这些属性和方法是由所有实例共享的，即person1和person2访问的都是同一组属性和同一个sayName()函数，因此要理解原型模式的工作原理，必须先理解ECMAScript中原型对象的性质。</p>
<p><strong>理解原型对象:</strong></p>
<p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象，在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。<br>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性，其他方法都是从Object继承而来的，当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。这个指针叫[[Prototype]]。<br>以前面使用Person构造函数和Person.prototype创建实例的代码为例，下图展示了各个对象之间的关系。</p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%8E%9F%E5%9E%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AE%9E%E4%BE%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="attr"></p>
<p>上图中展示了Person构造函数、Person的原型属性以及Person现有的两个实例之间的关系，由于所有实现中都无法访问到[[Prototype]]，因此可以通过isPrototypeOf()确定对象对象间是否存在这种关系，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person1));   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.isPrototypeOf(person2));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>Object.getPrototypeOf()方法返回[[Prototype]]的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype);   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person1).name)        <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果在实例中添加了一个属性，而该属性与原型中的一个属性同名，则在实例中创建该属性，该属性会屏蔽掉原型中的那个属性。</strong></p>
<p><strong>原型与in操作符:</strong></p>
<p>有两种方式使用in操作符：单独使用和在for-in循环中使用，在单独使用时，in操作符会在对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。<br>hasOwnProperty()只在属性存在于实例中才返回true，当同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中还是存在于原型中，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.name = <span class="string">"Greg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person1);          <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person2.hasOwnProperty(<span class="string">"name"</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> person2);           <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括于存在于实例中的属性，也包括存在于原型中的属性，屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记的属性）的实例属性也会在for-in循环中返回。<br>使用ECMAScript5的<strong>Object.keys()方法</strong>能取得对象上所有可枚举的实例属性，这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys);   <span class="comment">//[ 'name', 'age', 'job', 'sayName' ]</span></span><br></pre></td></tr></table></figure>

<p>如果要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);   <span class="comment">//[ 'constructor', 'name', 'age', 'job', 'sayName' ]</span></span><br></pre></td></tr></table></figure>

<p><strong>更简单的原型语法:</strong></p>
<p>前面例子中每一个属性和方法就要敲一遍Person.prototype。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，因此用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend <span class="keyword">instanceof</span> Person);      <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == Person);  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.constructor == <span class="built_in">Object</span>);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>原型的动态性:</strong></p>
<p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象的所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。如下面的例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi();     <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>

<p>即使Person实例friend是在添加新方法之前创建的，但它仍然可以访问这个新方法，其原因可以归结于实例与原型之间的松散连接关系，当我们调用person.sayHi()时，首先会在实例中搜索名为sayHi的属性，在没找到的情况下，会继续搜索原型，因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi属性并返回保存在那里的函数。<br>尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，情况就会不同，调用构造函数时回味实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系，<strong>实例中的指针仅指向原型，而不指向构造函数。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    consttructor: Person,</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    age: <span class="number">29</span>,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi();     <span class="comment">//error:friend.sayHi is not a function</span></span><br></pre></td></tr></table></figure>

<p><strong>原生对象的原型:</strong></p>
<p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的，所有原生引用类型（Object、Array、String等等）都在其构造函数上定义了方法，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype.sort);  <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(typeOf <span class="built_in">String</span>.prototype.substring);  <span class="comment">//function</span></span><br></pre></td></tr></table></figure>

<p>通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法，可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。比如下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(text)  == <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>原型对象的问题:</strong></p>
<p>1.原型对象省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值<br>2.原型中所有属性是被很多实例共享的，这种共享对于函数非常合适，但是对于包含引用类型值的属性来说，问题就突出了，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    name: "Nicholas",</span><br><span class="line">    age: 29,</span><br><span class="line">    job: "Software Engineer",</span><br><span class="line">    friends: ["Shelby", "Court"],</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);      <span class="comment">//[ 'Shelby', 'Court', 'Van' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);      <span class="comment">//[ 'Shelby', 'Court', 'Van' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friend == person2.friend);  <span class="comment">////true</span></span><br></pre></td></tr></table></figure>

<p>上面的问题是很少有人单独使用原型模式的原因所在。</p>
<h3 id="组合使用构造函数模式与原型模式"><a href="#组合使用构造函数模式与原型模式" class="headerlink" title="组合使用构造函数模式与原型模式"></a>组合使用构造函数模式与原型模式</h3><p>创造自定义函数的最常见方式，就是组合使用构造函数和原型模式。构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性。结果，每个实例都有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存；另外，这种混成模式还支持向构造函数传递参数，可谓是集两种模式之长。如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shely"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: Person,</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">25</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1.friends);             <span class="comment">//[ 'Shely', 'Court', 'Van' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.friends);             <span class="comment">//[ 'Shely', 'Court' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.friends === person2.friends); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName === person2.sayName);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的，修改person1.friend（向其中传入一个新字符串），并不会影响到person2.friends，因为它们分别引用了不同的数组。<br><strong>这种构造函数与原型模式混合的模式，是目前在ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法，可以说，这是用来定义引用类型的一种默认模式。</strong></p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>动态原型模式是针对独立的构造函数和原型产生的，动态原型模式将所有信息都封装在构造函数中，通过在构造函数中初始化原型（仅在必要的条件下），又保持了同时使用构造函数和原型的优点，换句话说，可以通过检查某个应该存在的方法是否有效来决定是否需要初始化原型。如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();  <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>若是前面几种模式都不适用，可以选择使用寄生构造函数模式，这种模式的基本思想是创建一个函数，该函数的作用是封装对象的代码，然后再返回新创建的对象，但是从表面来看，这个函数又很像是典型的构造函数，但是除了使用new操作符并把使用的函数叫做构造函数之外，这个模式其实和工厂模式是一模一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();       <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>**这个模式可以在特殊的情况下用来为对象创建构造函数，假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以使用这个模式。<br>如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建数组</span></span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="comment">// 添加值</span></span><br><span class="line">    values.push.apply(values,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 添加方法</span></span><br><span class="line">    values.toPipeString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回数组</span></span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors.toPipeString());     <span class="comment">//"red|blue|green"</span></span><br></pre></td></tr></table></figure>

<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象，稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建的对象的实例方法不引用this，二是不使用new操作符调用构造函数，按照稳妥构造函数的要求，可以将前面的Person构造函数重写如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();     <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，实现继承则继承实际的方法，由于ECMAScript函数没有签名，因此无法实现接口继承。ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链是实现继承的主要方法，基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法，实现原型链有一种基本模式，其代码大致如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());    <span class="comment">//"true"</span></span><br></pre></td></tr></table></figure>

<p>以上代码定义了两个类型：SuperType和SubType，每个类型分别有一个属性和一个方法，它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的，实现的本质是重写原型对象，代之以一个新类型的实例。<br>调用原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。就上面的例子来说，调用instance.getSuperValue()会经历三个搜索步骤：1）搜索实例；2）搜索SubType.prototype；3）搜索SuperType.getSuperValue，最后一步找到该方法，在找不到属性或者方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
<p><strong>别忘记默认的属性：</strong>所有的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype，这也是所有自定义类型都会继承toString()、valueof()等默认方法的根本原因，即上面的例子展示的原型链还应该包括另外一个继承层次。</p>
<p><strong>确定原型与实例的关系：</strong>可以通过两种方式来确定原型和实例之间的关系，第一种方式是使用instanceof操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回true。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);     <span class="comment">//"true"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SuperType);  <span class="comment">//"true"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance <span class="keyword">instanceof</span> SubType);   <span class="comment">//"true"</span></span><br></pre></td></tr></table></figure>

<p>第二种方法是使用isPrototypeOf()方法，同样只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此isPrototypeOf()方法也会返回true，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));       <span class="comment">//"true"</span></span><br><span class="line"><span class="built_in">console</span>.log(SuperType.prototype.isPrototypeOf(instance));    <span class="comment">//"true"</span></span><br><span class="line"><span class="built_in">console</span>.log(SubType.prototype.isPrototypeOf(instance));      <span class="comment">//"true"</span></span><br></pre></td></tr></table></figure>

<p><strong>谨慎地定义方法：</strong></p>
<ul>
<li>子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法，但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。</li>
<li>在通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做就会重写原型链。</li>
</ul>
<p><strong>原型链的问题：</strong><br>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题，其中，最重要的问题来自包含引用类型值的原型。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supertype</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> Supertype();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);     <span class="comment">//[ 'red', 'blue', 'green', 'black' ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)      <span class="comment">//[ 'red', 'blue', 'green', 'black' ]</span></span><br></pre></td></tr></table></figure>

<p>当SubType通过原型链继承了Supertype之后，SubType.prototype就变成了Supertype的一个实例，因此它也拥有了一个它自己的colors属性，就跟专门创建了一个SubType.prototype.colors属性一样，结果是<strong>SubType的所有实例都会共享这一个colors属性。</strong><br>原型链的第二个问题是在创建子类型的实例时，不能向超类型的构造函数中传递参数。<br><strong>基于以上两个问题，实践中很少单独使用原型链。</strong></p>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>在解决原型中包含引用类型值所带来问题的过程中，开发人员开始使用一种叫做<strong>借用构造函数</strong>的技术（有时也叫做伪造函数或经典继承）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数。**而且函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在新创建的对象上执行构造函数，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supertype</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 继承了Supertype</span></span><br><span class="line">    Supertype.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)</span><br></pre></td></tr></table></figure>

<p>代码中Supertype.call(this)“借调”了超类型的构造函数，通过使用call()方法（或apply()方法），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了Supertype构造函数，这样在新SubType对象上执行SubType()函数中定义的所有对象初始化代码，结果SubType的每个实例就会有自己的colors属性的副本了。</p>
<p><strong>传递参数：</strong>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Supertype</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Supertype.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.name);     <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.age);      <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<p><strong>借用构造函数的问题：</strong>如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题————方法都在构造函数中定义，因此函数复用就无从谈起了，而且在超类型的原型中定义的方法对于类型而言也是不可见的，结果所有类型都只能使用构造函数模式，考虑到这些，<strong>借用构造函数的技术也是很少单独使用的。</strong></p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式，主要思想<strong>是使用原型链是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承</strong>，这样既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。</p>
]]></content>
      <categories>
        <category>JavaScript高级程序设计</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构2</title>
    <url>/blog/2020/05/20/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/</url>
    <content><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>队列是限制在两端进行插入操作和删除操作的线性表，允许进行存入操作的一端称为“队尾”，允许进行删除操作的一端称为“队头”。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><ol>
<li>队列只能在队头和队尾进行数据操作。</li>
</ol>
</li>
<li><ol start="2">
<li>具有先进先出或者叫做后进后出的规律。</li>
</ol>
</li>
</ul>
<h3 id="基础程序"><a href="#基础程序" class="headerlink" title="基础程序"></a>基础程序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">链式队列</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列异常</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,val,next=None)</span>:</span></span><br><span class="line">        self.val = val  <span class="comment"># 有用数据</span></span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LQueue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.front = self.rear = Node(<span class="literal">None</span>)</span><br><span class="line">    <span class="comment">#判断为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.front <span class="keyword">is</span> self.rear</span><br><span class="line">    <span class="comment">#入队</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        self.rear.next = Node(item)</span><br><span class="line">        self.rear = self.rear.next</span><br><span class="line">    <span class="comment">#出队</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.front == self.rear:</span><br><span class="line">            <span class="keyword">raise</span> QueueError(<span class="string">"Queue is empty"</span>)</span><br><span class="line">        self.front = self.front.next</span><br><span class="line">        <span class="keyword">return</span> self.front.val</span><br><span class="line">    <span class="comment">#清空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.front = self.rear</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lq = LQueue()</span><br><span class="line">    print(lq.is_empty())</span><br><span class="line">    lq.enqueue(<span class="number">10</span>)</span><br><span class="line">    lq.enqueue(<span class="number">20</span>)</span><br><span class="line">    lq.enqueue(<span class="number">30</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> lq.is_empty():</span><br><span class="line">        print(lq.dequeue())</span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><ol>
<li>定义：树(Tree)是n(n&gt;=0)个节点的有限集合T，它满足两个条件：有且仅有一个特定的称为根(Root)的节点，其余的节点可以分为m(m&gt;=0)个互不相交的有限集合T1、T2、……、Tm，其中每一个集合又是一个树，并称其为根的子树(Subtree)。</li>
</ol>
</li>
<li><ol start="2">
<li>基本概念</li>
</ol>
<ul>
<li>一个节点的子树的个数称为该节点的度数，一棵树的度数是指该树中节点的最大度数。</li>
<li>度数为零的节点称为树叶或终端节点，度数不为零的节点称为分支节点，除根节点外的分支节点称为内部节点。</li>
<li>一个节点系列k1,k2,……,ki,ki+1,……,kj,并满足ki是ki+1的父节点，就称为一条从k1到kj的路径，路径的长度为j-1，即路径中的边数。路径中前面的节点是后面节点的祖先，后面节点是前面节点的子孙。</li>
<li>节点的层数等于父节点的层数加一，根节点的层数定义为一。树中节点层数的最大值称为该树的高度或深度。</li>
</ul>
</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="定义与特征"><a href="#定义与特征" class="headerlink" title="定义与特征"></a>定义与特征</h3><ul>
<li><p>1.二叉树的定义：<br>二叉树是n(n&gt;=0)个节点的有限集合，它或者是空集(n=0),或者是由一个根节点以及两颗互不相交的、分别称为左子树和右子树的二叉树组成。二叉树与普通有序树不同，二叉树严格区分左孩子和右孩子，即使只有一个子节点也要区分左右。</p>
<ul>
<li>特殊的树形结构</li>
<li>度数最多为2</li>
<li>严格区分左子树和右子树</li>
</ul>
</li>
<li><ol start="2">
<li>二叉树的特征：<ul>
<li>二叉树第i(i&gt;=1)层上的节点最多为<code>2^(i-1)</code>个</li>
<li>深度为k(k&gt;=1)的二叉树最多有<code>2^k-1</code>个节点</li>
<li>在任意一颗二叉树中，树叶的数目比度数为2的节点的数目多一</li>
<li>满二叉树：深度为k(k&gt;=1)时有<code>2^k-1</code>个节点的二叉树</li>
<li>完全二叉树： 只有最下面两层有度数小于2的节点，且最下面一层的叶节点在最左边的若干位置上。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>遍历：沿某条搜索路径周游二叉树，对树中的每一个节点访问一次且仅访问一次。<br>先序遍历：先访问树根，再访问左子树，最后访问右子树；<br>中序遍历：先访问左子树，再访问树根，最后访问右子树；<br>后序遍历：先访问左子树，再访问右子树，最后访问树根；<br>层次遍历：从根节点开始，逐层从左向右进行遍历。<br><strong>下图是一个完全二叉树</strong><br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="attr"></p>
<p><strong>先序遍历（根 左 右）：1 2 8 9 10 11 3 6 12 7</strong><br><strong>中序遍历（左 根 右）：8 4 9 2 10 5 11 1 12 6 3 7</strong><br><strong>后序遍历（左 右 根）：8 9 4 10 11 5 2 12 6 7 3 1</strong><br><strong>层次遍历（从上到下，从左到右）：1 2 3 4 5 6 7 8 9 10 11 12</strong></p>
]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP常用状态码</title>
    <url>/blog/2020/07/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<div class="note info">
            <p>下面是常见的HTTP状态码：</p><ul><li>200 - 请求成功</li><li>301 - 资源（网页等）被永久转移到其它URL</li><li>404 - 请求的资源（网页等）不存在</li><li>500 - 内部服务器错误</li></ul>
          </div>

<p><strong>具体见下面博客</strong>：<a href="https://www.cnblogs.com/xflonga/p/9368993.html" target="_blank" rel="noopener">https://www.cnblogs.com/xflonga/p/9368993.html</a></p>
]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面经</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/blog/2020/08/09/leetcode%E5%88%B7%E9%A2%98%E7%BB%8F%E5%85%B8/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/</a><br>在未排序的数组中找到第k个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第k个不同的元素。</p>
]]></content>
      <categories>
        <category>leetcode刷题经典</category>
      </categories>
      <tags>
        <tag>leetcode刷题经典</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/blog/2020/08/09/leetcode%E5%88%B7%E9%A2%98%E7%BB%8F%E5%85%B8/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dp = [];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="强盗抢劫"><a href="#强盗抢劫" class="headerlink" title="强盗抢劫"></a>强盗抢劫</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。<br>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dp = [];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="built_in">Math</span>.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="强盗在环形街区抢劫"><a href="#强盗在环形街区抢劫" class="headerlink" title="强盗在环形街区抢劫"></a>强盗在环形街区抢劫</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> nums1 = nums.slice(<span class="number">1</span>,nums.length);</span><br><span class="line">    <span class="keyword">let</span> nums2 = nums.slice(<span class="number">0</span>,nums.length<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">let</span> p1 = getDp(nums1);</span><br><span class="line">    <span class="keyword">let</span> p2 = getDp(nums2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(p1,p2);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDp</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="built_in">Math</span>.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">2</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信件错排-母牛生产"><a href="#信件错排-母牛生产" class="headerlink" title="信件错排 母牛生产"></a>信件错排 母牛生产</h3><p>参考：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#5-%E6%AF%8D%E7%89%9B%E7%94%9F%E4%BA%A7" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#5-%E6%AF%8D%E7%89%9B%E7%94%9F%E4%BA%A7</a></p>
<h2 id="矩阵路径"><a href="#矩阵路径" class="headerlink" title="矩阵路径"></a>矩阵路径</h2><h3 id="矩阵的最小路径和"><a href="#矩阵的最小路径和" class="headerlink" title="矩阵的最小路径和"></a>矩阵的最小路径和</h3><p>给定一个包含非负整数的 <code>m x n</code> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br><strong>说明</strong>：每次只能向下或者向右移动一步。</p>
]]></content>
      <categories>
        <category>leetcode刷题经典</category>
      </categories>
      <tags>
        <tag>leetcode刷题经典</tag>
      </tags>
  </entry>
  <entry>
    <title>树题</title>
    <url>/blog/2020/08/07/leetcode%E5%88%B7%E9%A2%98%E7%BB%8F%E5%85%B8/%E6%A0%91/</url>
    <content><![CDATA[<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种递归结构，很多树的问题可以使用递归来处理。</p>
<h3 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h3><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>题目地址：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            <span class="keyword">let</span> left = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">let</span> right = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right)+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。<br>题目地址：<a href="https://leetcode-cn.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balanced-binary-tree/description/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;TreeNode&#125; root</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isBalanced = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//递归是要保证每个节点的左右两个子树的高度差的绝对值不超过1</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Math</span>.abs(height(root.left)-height(root.right))&lt;=<span class="number">1</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//计算高度差</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">height</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> left = height(node.left);</span><br><span class="line">        <span class="keyword">let</span> right = height(node.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两节点的最长路径"><a href="#两节点的最长路径" class="headerlink" title="两节点的最长路径"></a>两节点的最长路径</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。<br>题目地址：<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diameter-of-binary-tree/submissions/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> diameterOfBinaryTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp = height(root.left) + height(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(temp,diameterOfBinaryTree(root.left),diameterOfBinaryTree(root.right));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">height</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> left = height(node.left);</span><br><span class="line">        <span class="keyword">let</span> right = height(node.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode刷题经典</category>
      </categories>
      <tags>
        <tag>leetcode刷题经典</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象高级编程</title>
    <url>/blog/2020/04/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能，我们会讨论多重继承、定制类、元类等概念。</p>
<h2 id="使用slots"><a href="#使用slots" class="headerlink" title="使用slots"></a>使用<strong>slots</strong></h2><p><strong>slots</strong>是用来限制class实例能添加的属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'name'</span>, <span class="string">'age'</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure>

<p>测试结果L:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 绑定属性'name'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性'age'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性'score'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'score'</span></span><br></pre></td></tr></table></figure>

<p><strong>由于’score’没有被放到<strong>slots</strong>中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。使用<strong>slots</strong>要注意，<strong>slots</strong>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</strong></p>
<h2 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h2><p>在绑定属性时，如果我们直接向下面这样把属性暴露出去，虽然写起来简单，但是，没办法检查参数，导致成绩可以随便改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">9999</span></span><br></pre></td></tr></table></figure>

<p>这显然不合逻辑。为了限制score的范围，可以通过一个set_score()方法来设置成绩，再通过一个get_score()来获取成绩，这样，在set_score()方法里，就可以检查参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>

<p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">60</span>) <span class="comment"># ok!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.get_score()</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">9999</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure>

<p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。<br>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！<br>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure>

<p>@property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure>

<p>注意到这个神奇的@property，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。<br>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br></pre></td></tr></table></figure>

<p>上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。<br><strong>@property广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。</strong></p>
<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能，例如Animal类层的设计，假设我们要实现以下4种动物：</p>
<ul>
<li>Dog - 狗狗；</li>
<li>Bat - 蝙蝠；</li>
<li>Parrot - 鹦鹉；</li>
<li>Ostrich - 鸵鸟。<br>如果按照哺乳动物与鸟类归类，可以将Dog与Bat归为一类，Parrot与Ostrich归为一类，但是如果我们再按照能跑与能飞来分类，将非常麻烦，所以python设计多重继承</li>
</ul>
<p>我们要给动物加上Runable与Flyable的功能，只需要定义好Runnable与Flyable的类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Running...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyable</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Flying...'</span>)</span><br></pre></td></tr></table></figure>

<p>对于需要Runnable功能的动物，就多继承一个Runnable，例如Dog：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, Runnable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>对于需要Flyable功能的动物，就多继承一个Flyable，例如Bat：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bat</span><span class="params">(Mammal, Flyable)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>
<h3 id="MixIn"><a href="#MixIn" class="headerlink" title="MixIn"></a>MixIn</h3><p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。<br>为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn。类似的，你还可以定义出肉食动物CarnivorousMixIn和植食动物HerbivoresMixIn，让某个动物同时拥有好几个MixIn：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Mammal, RunnableMixIn, CarnivorousMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<p>Python自带的很多库也使用了MixIn。举个例子，Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixIn和ThreadingMixIn提供。通过组合，我们就可以创造出合适的服务来。<br>比如，编写一个多进程模式的TCP服务，定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTCPServer</span><span class="params">(TCPServer, ForkingMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>编写一个多线程模式的UDP服务，定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUDPServer</span><span class="params">(UDPServer, ThreadingMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>如果你打算搞一个更先进的协程模型，可以编写一个CoroutineMixIn：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTCPServer</span><span class="params">(TCPServer, CoroutineMixIn)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。<br><strong>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。只允许单一继承的语言（如Java）不能使用MixIn的设计。</strong></p>
<h2 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h2><p><strong>str</strong><br>我们先定义一个Student类，打印一个实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x109afb190</span>&gt;</span><br></pre></td></tr></table></figure>

<p>打印出一堆&lt;<strong>main</strong>.Student object at 0x109afb190&gt;，不好看。<br>怎么才能打印得好看呢？只需要定义好<strong>str</strong>()方法，返回一个好看的字符串就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">'Student object (name: %s)'</span> % self.name</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student(<span class="string">'Michael'</span>))</span><br><span class="line">Student object (name: Michael)</span><br></pre></td></tr></table></figure>

<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br>但是细心的朋友会发现直接敲变量不用print，打印出来的实例还是不好看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x109afb310</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这是因为直接显示变量调用的不是<strong>str</strong>()，而是<strong>repr</strong>()，两者的区别是<strong>str</strong>()返回用户看到的字符串，而<strong>repr</strong>()返回程序开发者看到的字符串，也就是说，<strong>repr</strong>()是为调试服务的。</p>
<p>解决办法是再定义一个<strong>repr</strong>()。但是通常<strong>str</strong>()和<strong>repr</strong>()代码都是一样的，所以，有个偷懒的写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Student object (name=%s)'</span> % self.name</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>

<h3 id="iter"><a href="#iter" class="headerlink" title="iter"></a><strong>iter</strong></h3><p>如果一个类想被用于for … in循环，类似list或tuple那样，就必须实现一个<strong>iter</strong>()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<strong>next</strong>()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br></pre></td></tr></table></figure>

<p>现在，试试把Fib实例作用于for循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> Fib():</span><br><span class="line"><span class="meta">... </span>    print(n)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">...</span><br><span class="line"><span class="number">46368</span></span><br><span class="line"><span class="number">75025</span></span><br></pre></td></tr></table></figure>

<h3 id="getitem"><a href="#getitem" class="headerlink" title="getitem"></a><strong>getitem</strong></h3><p>Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，比如，取第5个元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Fib()[<span class="number">5</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'Fib'</span> object does <span class="keyword">not</span> support indexing</span><br></pre></td></tr></table></figure>

<p>要表现得像list那样按照下标取出元素，需要实现<strong>getitem</strong>()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>现在，就可以按下标访问数列的任意一项了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = Fib()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">1</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">2</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">10</span>]</span><br><span class="line"><span class="number">89</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f[<span class="number">100</span>]</span><br><span class="line"><span class="number">573147844013817084101</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象编程</title>
    <url>/blog/2020/04/17/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>面向对象最重要的概念就是类（Class）和实例（Instance），类是抽象的模板，实例是根据类创建出来的一个个具体的“对象”。<br>以Student类为例，定义Student类，定义类的关键字是class</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。<br>定义好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart</span><br><span class="line">&lt;__main__.Student object at <span class="number">0x10a67a590</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">Student</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，变量bart指向的就是一个Student的实例，后面的0x10a67a590是内存地址，每个object的地址都不一样，而Student本身则是一个类。<br>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<strong>init</strong>方法，在创建实例的时候，就把name，score等属性绑上去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure>

<p>注意到<strong>init</strong>方法的第一个参数永远是self，表示创建的实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。<br>有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</span><br><span class="line"><span class="string">'Bart Simpson'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score</span><br><span class="line"><span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h3><p>数据封装即是类的方法，类的方法包括类方法和实例方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lass Student(object):</span><br><span class="line">   </span><br><span class="line">    <span class="comment">#类变量</span></span><br><span class="line">    score = <span class="number">0</span>      </span><br><span class="line">    <span class="comment"># 类方法（简单介绍一下）</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_total_score</span><span class="params">(cls,score)</span>:</span></span><br><span class="line">        cls.score += score</span><br><span class="line">    <span class="comment"># 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: %s'</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure>

<p>在Student这个类中定义了print_score方法；和普通函数一样，要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.print_score()</span><br><span class="line">Bart Simpson: <span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>练习1:在Student类里定义get_grade方法，成绩在90分以上返回这个人的名字和A，60到90之间为B，60以下为C</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.score &gt;= <span class="number">90</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> self.score &gt;= <span class="number">60</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line">lisa = Student(<span class="string">'Lisa'</span>, <span class="number">99</span>)</span><br><span class="line">bart = Student(<span class="string">'Bart'</span>, <span class="number">59</span>)</span><br><span class="line">print(lisa.name, lisa.get_grade())</span><br><span class="line">print(bart.name, bart.get_grade())</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Lisa A</span><br><span class="line">Bart C</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响；<br>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据；<br>通过在实例上调用方法，我们就直接操作了对象内部的数据，但无需知道方法内部的实现细节。<br>和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同</p>
<h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。<br>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的name、score属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score</span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score = <span class="number">99</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score</span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure>

<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线 __ ，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改,但是如果外部代码要获取name和score怎么办？可以给Student类增加get_name和get_score这样的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, score)</span>:</span></span><br><span class="line">        self.__name = name         </span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span><span class="params">(self)</span>:</span>      <span class="comment">#通过get_name获取内部名字等</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_score</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span><span class="params">(self, score)</span>:</span>   <span class="comment">#通过set_score修改内部变量，用这种办法，可以对参数进行检查，避免传入无效的参数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:</span><br><span class="line">            self.__score = score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'bad score'</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在Python中，变量名类似<strong>xxx</strong>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<strong>name</strong>、<strong>score</strong>这样的变量名。<br>有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。<br>双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<strong>name是因为Python解释器对外把</strong>name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart._Student__name</span><br><span class="line"><span class="string">'Bart Simpson'</span></span><br></pre></td></tr></table></figure>

<p>但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名。<br>总的来说就是，Python本身没有任何机制阻止你干坏事，一切全靠自觉。<br>练习2：请把下面的Student对象的gender字段对外隐藏起来，用get_gender()和set_gender()代替，并检查参数有效性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, gender)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__gender = gender</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_gender</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__gender</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_gender</span><span class="params">(self,gender)</span>:</span></span><br><span class="line">        self.__gender = gender</span><br><span class="line"><span class="comment"># 测试:</span></span><br><span class="line">bart = Student(<span class="string">'Bart'</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="keyword">if</span> bart.get_gender() != <span class="string">'male'</span>:</span><br><span class="line">    print(<span class="string">'测试失败!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    bart.set_gender(<span class="string">'female'</span>)</span><br><span class="line">    <span class="keyword">if</span> bart.get_gender() != <span class="string">'female'</span>:</span><br><span class="line">        print(<span class="string">'测试失败!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'测试成功!'</span>)</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">测试成功!</span><br></pre></td></tr></table></figure>

<h2 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印，当我们需要编写Dog和Cat类时，就可以直接从Animal类继承</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Animal is running...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。<br>继承就是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog = Dog()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog.run()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cat = Cat()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cat.run()</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br></pre></td></tr></table></figure>

<p>不仅可以实现继承，同时子类可以对代码进行改进与修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>       print(<span class="string">'Dog is running...'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>       print(<span class="string">'Cat is running...'</span>)</span><br><span class="line">Dog <span class="keyword">is</span> running...</span><br><span class="line">Cat <span class="keyword">is</span> running...</span><br></pre></td></tr></table></figure>

<p><strong>子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run(),即继承的另一个好处：多态。</strong></p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">run_twice</span><span class="params">(animal)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   animal.run()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   animal.run()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Animal())</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Dog())</span><br><span class="line">Dog <span class="keyword">is</span> running...</span><br><span class="line">Dog <span class="keyword">is</span> running...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Cat())</span><br><span class="line">Cat <span class="keyword">is</span> running...</span><br><span class="line">Cat <span class="keyword">is</span> running...</span><br></pre></td></tr></table></figure>

<p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、还是Cat对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：<br>对扩展开放：允许新增Animal子类；<br>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。<br>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树</p>
<h2 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h2><h3 id="使用type"><a href="#使用type" class="headerlink" title="使用type()"></a>使用type()</h3><ul>
<li>1 基本类型可以用type()判断</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="number">123</span>)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(<span class="string">'str'</span>)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(None)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">type</span><span class="params">(None)</span> '<span class="title">NoneType</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2 如果一个变量指向函数或者类，也可以用type()判断</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">builtin_function_or_method</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">type</span><span class="params">(a)</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">Animal</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3 判断一个对象是否是函数可以使用types模块中定义的常量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(fn)==types.FunctionType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(abs)==types.BuiltinFunctionType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(<span class="keyword">lambda</span> x: x)==types.LambdaType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)))==types.GeneratorType</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="使用isinstance"><a href="#使用isinstance" class="headerlink" title="使用isinstance()"></a>使用isinstance()</h3><p>对于class的继承关系来说，使用types()就很不方便，为了判断class的类型，可以使用isinstance()函数:</p>
<ul>
<li>1 对于如下继承关系的函数</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">object -&gt; Animal -&gt; Dog -&gt; Husky</span><br></pre></td></tr></table></figure>

<p>可以创建3种类型的对象，然后判断，isinstance()判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = Animal()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h = Husky()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(h, Husky)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(h, Dog)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(d, Dog) <span class="keyword">and</span> isinstance(d, Animal)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(d, Husky)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2 可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是list或者tuple:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (list, tuple))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="使用dir"><a href="#使用dir" class="headerlink" title="使用dir()"></a>使用dir()</h3><p>dir()函数可以获得一个对象的所有属性和方法，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(<span class="string">'ABC'</span>)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>,..., <span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>,..., <span class="string">'zfill'</span>]</span><br></pre></td></tr></table></figure>

<p>类似<strong>xxx</strong>的属性和方法在Python中都是有特殊用途的，比如<strong>len</strong>方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的<strong>len</strong>()方法，所以，下面的代码是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.__len__()</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>我们自己写的类，如果也想用len(myObj)的话，就自己写一个<strong>len</strong>()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyDog</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dog = MyDog()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dog)</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.x = <span class="number">9</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> self.x * self.x</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = MyObject()</span><br><span class="line">&gt;&gt; hasattr(obj, <span class="string">'x'</span>) <span class="comment"># 有属性'x'吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.x</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>setattr(obj, <span class="string">'y'</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性'y'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'y'</span>) <span class="comment"># 有属性'y'吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'y'</span>) <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.y <span class="comment"># 获取属性'y'</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'z'</span>) <span class="comment"># 获取属性'z',试图获取不存在的属性，会抛出AttributeError的错误</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'MyObject'</span> object has no attribute <span class="string">'z'</span></span><br></pre></td></tr></table></figure>

<p>可以传入一个default参数，如果属性不存在，就返回默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'z'</span>, <span class="number">404</span>) <span class="comment"># 获取属性'z'，如果不存在，返回默认值404</span></span><br><span class="line"><span class="number">404</span></span><br></pre></td></tr></table></figure>

<p>也可以获得对象的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj, <span class="string">'power'</span>) <span class="comment"># 有属性'power'吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = getattr(obj, <span class="string">'power'</span>) <span class="comment"># 获取属性'power'并赋值到变量fn</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject object at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line"><span class="number">81</span></span><br></pre></td></tr></table></figure>

<h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">'Bob'</span>)</span><br><span class="line">s.score = <span class="number">90</span></span><br></pre></td></tr></table></figure>

<p>但是，如果Student类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归Student类所有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    name = <span class="string">'Student'</span></span><br></pre></td></tr></table></figure>

<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    name = <span class="string">'Student'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建实例s</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 打印类的name属性</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">'Michael'</span> <span class="comment"># 给实例绑定name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span></span><br><span class="line">Michael</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(Student.name) <span class="comment"># 但是类属性并未消失，用Student.name仍然可以访问</span></span><br><span class="line">Student</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> s.name <span class="comment"># 如果删除实例的name属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(s.name) <span class="comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span></span><br><span class="line">Student</span><br></pre></td></tr></table></figure>

<p>练习:为了统计学生人数，可以给Student类增加一个类属性，每创建一个实例，该属性自动增加：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Student.count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 测试:</span></span><br><span class="line"><span class="keyword">if</span> Student.count != <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">'测试失败!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    bart = Student(<span class="string">'Bart'</span>)</span><br><span class="line">    <span class="keyword">if</span> Student.count != <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'测试失败!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lisa = Student(<span class="string">'Bart'</span>)</span><br><span class="line">        <span class="keyword">if</span> Student.count != <span class="number">2</span>:</span><br><span class="line">            print(<span class="string">'测试失败!'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Students:'</span>, Student.count)</span><br><span class="line">            print(<span class="string">'测试通过!'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Students: <span class="number">2</span></span><br><span class="line">测试通过!</span><br></pre></td></tr></table></figure>

<p><strong>实例属性属于各个实例所有，互不干扰；类属性属于类所有，所有实例共享一个属性；不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</strong></p>
]]></content>
      <categories>
        <category>Python 知识汇总</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>查找</title>
    <url>/blog/2020/08/09/leetcode%E5%88%B7%E9%A2%98%E7%BB%8F%E5%85%B8/%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="求开方"><a href="#求开方" class="headerlink" title="求开方"></a>求开方</h2><p>实现 <code>int sqrt(int x)</code> 函数。计算并返回 <code>x</code> 的平方根，其中 <code>x</code> 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br>题目地址：<a href="https://leetcode-cn.com/problems/sqrtx/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sqrtx/submissions/</a><br>采用二分逼近方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; x</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> high = x;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(low + (high-low)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> qr = mid * mid;</span><br><span class="line">        <span class="keyword">if</span>(qr == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(qr &lt; x &amp;&amp; (mid+<span class="number">1</span>)*(mid+<span class="number">1</span>)&gt;x) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(qr &gt; x) &#123;</span><br><span class="line">                high = mid <span class="number">-1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="寻找比目标字母大的最小字母"><a href="#寻找比目标字母大的最小字母" class="headerlink" title="寻找比目标字母大的最小字母"></a>寻找比目标字母大的最小字母</h2><p>给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。<br>在比较时，字母是<code>依序循环出现</code>的。举个例子：<br>如果目标字母 target = ‘z’ 并且字符列表为 letters = [‘a’, ‘b’]，则答案返回 ‘a’</p>
<p>题目地址：<a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个题本人没有用二分查找，直接比较即可。网上有二分查找方法，读者可自行查找。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;character[]&#125; letters</span></span><br><span class="line"><span class="comment"> * @param &#123;character&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;character&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> nextGreatestLetter = <span class="function"><span class="keyword">function</span>(<span class="params">letters, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> letters) &#123;</span><br><span class="line">        <span class="keyword">if</span>(item &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> letters[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="有序数组的-Single-Element"><a href="#有序数组的-Single-Element" class="headerlink" title="有序数组的 Single Element"></a>有序数组的 Single Element</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-element-in-a-sorted-array/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNonDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> newNums = nums.sort()</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; newNums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(newNums[i] == newNums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            i = i+<span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> newNums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="第一个错误的版本"><a href="#第一个错误的版本" class="headerlink" title="第一个错误的版本"></a>第一个错误的版本</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/first-bad-version/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-bad-version/submissions/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for isBadVersion()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;integer&#125;</span> </span>version number</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>whether the version is bad</span></span><br><span class="line"><span class="comment"> * isBadVersion = function(version) &#123;</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>isBadVersion()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solution = <span class="function"><span class="keyword">function</span>(<span class="params">isBadVersion</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;integer&#125;</span> </span>n Total versions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return <span class="type">&#123;integer&#125;</span> </span>The first bad version</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> end = n;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(start+(end-start<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)) &#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="查找区间"><a href="#查找区间" class="headerlink" title="查找区间"></a>查找区间</h2><p>题目地址：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> start = nums.indexOf(target);</span><br><span class="line">    arr.push(start);</span><br><span class="line">    <span class="keyword">let</span> end = nums.lastIndexOf(target);</span><br><span class="line">    arr.push(end);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode刷题经典</category>
      </categories>
      <tags>
        <tag>leetcode刷题经典</tag>
      </tags>
  </entry>
  <entry>
    <title>vue面经</title>
    <url>/blog/2020/08/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/VUE%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>参考：<a href="https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html" target="_blank" rel="noopener">https://www.cnblogs.com/fundebug/p/vue-virtual-dom.html</a><br>Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。简单来说，可以把Virtual DOM 理解为一个简单的JS对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。不同的框架对这三个属性的命名会有点差别。对于虚拟DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的<code>阐述了模板 → 渲染函数 → 虚拟DOM树 → 真实DOM</code>的一个过程<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0/%E8%99%9A%E6%8B%9FDOM.png" alt="虚拟DOM"></p>
<h3 id="虚拟DOM的作用是什么？"><a href="#虚拟DOM的作用是什么？" class="headerlink" title="虚拟DOM的作用是什么？"></a>虚拟DOM的作用是什么？</h3><div class="note info">
            <p><strong>虚拟DOM的最终目标是将虚拟节点渲染到视图上。</strong>但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的DOM操作。例如，一个ul标签下很多个li标签，其中只有一个li有变化，这种情况下如果使用新的ul去替代旧的ul,因为这些不必要的DOM操作而造成了性能上的浪费。为了避免不必要的DOM操作，虚拟DOM在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行DOM操作，从而避免操作其他无需改动的DOM。</p><p>其实虚拟DOM在Vue.js主要做了两件事：</p><ul><li>提供与真实DOM节点所对应的虚拟节点vnode</li><li>将虚拟节点vnode和旧虚拟节点oldVnode进行对比，然后更新视图</li></ul>
          </div>

<h3 id="为何需要Virtual-DOM？"><a href="#为何需要Virtual-DOM？" class="headerlink" title="为何需要Virtual DOM？"></a>为何需要Virtual DOM？</h3><div class="note info">
            <ul><li><p><strong>具备跨平台的优势。</strong> 由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p></li><li><p><strong>操作 DOM 慢，js运行效率高。我们可以将DOM对比操作放在JS层，提高效率。</strong>因为DOM操作的执行速度远不如Javascript的运算速度快，因此，把大量的DOM操作搬运到Javascript中，运用patching算法来计算出真正需要更新的节点，最大限度地减少DOM操作，从而显著提高性能。 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）</p></li><li><p><strong>提升渲染性能</strong>。Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。</p></li></ul>
          </div>

<h2 id="vue双向绑定原理"><a href="#vue双向绑定原理" class="headerlink" title="vue双向绑定原理"></a>vue双向绑定原理</h2><p>参考：<a href="https://www.cnblogs.com/wangjiachen666/p/9883916.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangjiachen666/p/9883916.html</a></p>
<p>Vue内部通过<code>Object.defineProperty</code>方法属性拦截的方式，把<code>data</code>对象里每个数据的读写转化成<code>getter</code>/<code>setter</code>，当数据变化时通知视图更新。</p>
<p>所谓MVVM数据双向绑定，即主要是：数据变化更新视图，视图变化更新数据。如下图：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0/MVVM%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.jpg" alt="MVVM双向数据绑定原理"></p>
<div class="note info">
            <p>也就是说：</p><ul><li>输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化。</li><li>data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化。</li></ul>
          </div>

<p>实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器<code>Observer</code>，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者<code>Watcher</code>看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器<code>Dep</code>来专门收集这些订阅者，然后在监听器<code>Observer</code>和订阅者<code>Watcher</code>之间进行统一管理的。<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0/%E8%AE%A2%E9%98%85%E8%80%85-%E5%8F%91%E5%B8%83%E8%80%85.png" alt="订阅者-发布者"></p>
<h2 id="说说Vuex的作用以及应用场景"><a href="#说说Vuex的作用以及应用场景" class="headerlink" title="说说Vuex的作用以及应用场景"></a>说说Vuex的作用以及应用场景</h2><p>项目数据状态的集中管理，复杂组件(如兄弟组件、远房亲戚组件)的数据通信问题。</p>
<h2 id="说说Vue组件的数据通信方式"><a href="#说说Vue组件的数据通信方式" class="headerlink" title="说说Vue组件的数据通信方式"></a>说说Vue组件的数据通信方式</h2><p>父传子—-》props  子传父—-》$emit</p>
]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面经</tag>
      </tags>
  </entry>
  <entry>
    <title>链表题</title>
    <url>/blog/2020/08/04/leetcode%E5%88%B7%E9%A2%98%E7%BB%8F%E5%85%B8/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>试题链接：<br><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md</a></p>
<h2 id="找出两个链表的交点"><a href="#找出两个链表的交点" class="headerlink" title="找出两个链表的交点"></a>找出两个链表的交点</h2><p>编写一个程序，找到两个单链表相交的起始节点。<br>题目： <a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a><br>解法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力解法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(headA) &#123;</span><br><span class="line">        headA.flag = <span class="literal">true</span>;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(headB) &#123;</span><br><span class="line">        <span class="keyword">if</span>(headB.flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//同步遍历</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pA = headA,</span><br><span class="line">        pB = headB;</span><br><span class="line">    <span class="keyword">while</span>(pA || pB) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pA === pB) &#123;</span><br><span class="line">            <span class="keyword">return</span> pA</span><br><span class="line">        &#125;</span><br><span class="line">        pA = pA === <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB === <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h2><p>反转一个单链表。<br>题目：<a href="https://leetcode-cn.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/description/</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>,</span><br><span class="line">    curr = head;</span><br><span class="line">  <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = curr.next;</span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="归并两个有序的链表"><a href="#归并两个有序的链表" class="headerlink" title="归并两个有序的链表"></a>归并两个有序的链表</h2><p>将两个升序链表合并为一个新的 <code>升序</code> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> l3 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">var</span> c3 = l3;</span><br><span class="line">    <span class="keyword">while</span>(!(l1 === <span class="literal">null</span>) &amp;&amp; !(l2 === <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &lt;= l2.val) &#123;</span><br><span class="line">            c3.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c3.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        c3 = c3.next</span><br><span class="line">    &#125;</span><br><span class="line">    c3.next = (l1===<span class="literal">null</span>) ? l2 : l1;</span><br><span class="line">    <span class="keyword">return</span> l3.next  <span class="comment">//去除-1头部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="从有序链表中删除重复节点"><a href="#从有序链表中删除重复节点" class="headerlink" title="从有序链表中删除重复节点"></a>从有序链表中删除重复节点</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> curr = head;</span><br><span class="line">    <span class="keyword">while</span>((curr != <span class="literal">null</span>) &amp;&amp; !(curr.next === <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.val === curr.next.val) &#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="删除链表的倒数第-n-个节点"><a href="#删除链表的倒数第-n-个节点" class="headerlink" title="删除链表的倒数第 n 个节点"></a>删除链表的倒数第 n 个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeNthFromEnd = <span class="function"><span class="keyword">function</span>(<span class="params">head, n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//快慢指针</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    node.next = head;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span> || !head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> fast = node;</span><br><span class="line">    <span class="comment">//快指针先走n部</span></span><br><span class="line">    <span class="keyword">while</span>(count &lt; n) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//慢指针开始走</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> slow = node;</span><br><span class="line">    <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        prev = slow;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    prev.next = slow.next;</span><br><span class="line">    <span class="keyword">return</span> node.next</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>leetcode刷题经典</category>
      </categories>
      <tags>
        <tag>leetcode刷题经典</tag>
      </tags>
  </entry>
  <entry>
    <title>左右各200px宽度，中间自适应的布局</title>
    <url>/blog/2020/08/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/%E5%B7%A6%E5%8F%B3%E5%90%84200px%E5%AE%BD%E5%BA%A6%EF%BC%8C%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>布局：高度已知，布局一个三栏布局，左栏和右栏各为200px，中间自适应，如下图所示：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%B7%A6%E5%8F%B3%E5%90%84200px%E5%AE%BD%E5%BA%A6%EF%BC%8C%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E5%B8%83%E5%B1%80.png" alt="左右各200px宽度，中间自适应的布局"></p>
<h2 id="方法一：float浮动布局"><a href="#方法一：float浮动布局" class="headerlink" title="方法一：float浮动布局"></a>方法一：float浮动布局</h2><p>浮动布局详解参考：<a href="https://www.cnblogs.com/LO-ME/p/7375343.html" target="_blank" rel="noopener">https://www.cnblogs.com/LO-ME/p/7375343.html</a></p>
<div class="note info">
            <p>原理是：<strong>定义三个区块，需要注意的是中间的区块放在右边区块的下面</strong>，统一设置高度为200px，然后设置左边栏宽度为200px并且<code>float:left</code>，设置右边栏宽度为200px并且<code>float:right</code>。</p><p>优点：兼容性好。<br>缺点：float会脱离文档流，需要处理float周边的元素，比如清除浮动。<br><strong>适用于高度确定的情况</strong></p>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    /* html *&#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">    &#125; */</span><br><span class="line"><span class="css">    <span class="selector-class">.layout</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">        min-height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        float: left;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        float: right;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">        background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout float"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>浮动解决方案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果如下所示：拉动浏览器窗口的时候，中间宽度自动变化，左右边栏不会变化<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80%E6%95%88%E6%9E%9C.png" alt="浮动布局效果"></p>
<h2 id="方法二：绝对定位布局"><a href="#方法二：绝对定位布局" class="headerlink" title="方法二：绝对定位布局"></a>方法二：绝对定位布局</h2><div class="note info">
            <p>实现原理：设置三个区块分别为左中右，并且统一设置高度为200px和绝对定位，左边脸<code>left:0</code> ，右边栏<code>right:0</code> ，最重要的是中间的区块，不设置宽度，并且设置<code>left:200px,right:200px</code>，这个定位的数值也就是左边栏和右边栏的宽度大小。</p><p>优点：快捷，不容易出问题。<br>缺点：定位会脱离文档流，那么后面的元素也都是要脱离文档流的，这个方式的可用性比较差。</p>
          </div>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    html *&#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.layout</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">        min-height: 200px;</span><br><span class="line">        position: absolute;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        left: 0;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">        right: 0;</span><br><span class="line">        width: 200px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">        background-color: green;</span><br><span class="line">        left: 200px;</span><br><span class="line">        right: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout absolute"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-right-center"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>绝对定位解决方案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="方法三：flexbox布局方式"><a href="#方法三：flexbox布局方式" class="headerlink" title="方法三：flexbox布局方式"></a>方法三：flexbox布局方式</h2><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes</a></p>
<p>实现原理：首先定义三个区块，分别在左中右，并且统一设置高度为200px，然后在这三个区块的父元素中设置<code>display:flex</code>，设置左边栏和右边栏宽度为200px，中间区块设置<code>flex:1</code>。<br>优点：比较完美的一种方式，在移动端基本都是使用这个布局方式，这是css3中的新的布局方式，当设置最小高度后，中间区块内容溢出时高度会自动撑开，左右两边的高度也可以跟着撑开。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    html *&#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-tag">article</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">        min-height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.left-right-center</span>&#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">        background-color: green;</span><br><span class="line">        flex: 1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"layout flexbox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-right-center"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span>flexbox解决方案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有表格布局方式、网格布局两种方式。参考：<a href="https://www.cnblogs.com/LO-ME/p/7374350.html" target="_blank" rel="noopener">https://www.cnblogs.com/LO-ME/p/7374350.html</a></p>
]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面经</tag>
      </tags>
  </entry>
  <entry>
    <title>查找与排序</title>
    <url>/blog/2020/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95python/%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="列表查找"><a href="#列表查找" class="headerlink" title="列表查找"></a>列表查找</h2><p>列表查找：从列表中查找指定元素</p>
<ul>
<li><ol>
<li>输入：列表、待查找元素</li>
</ol>
</li>
<li><ol start="2">
<li>输出：元素下标或未查找到元素<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3></li>
</ol>
</li>
<li><ol>
<li>从列表第一个元素开始，顺序进行搜索，直到找到为止<br>时间复杂度为O(n)<br><strong>顺序查找就是for循环</strong><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3></li>
</ol>
</li>
<li><ol>
<li>从有序列表的<strong>候选区data[0:n]</strong>开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。<br>时间复杂度为O(logn)，二分查找较快</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">li = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(li,val)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(li)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = (low + high) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> li[mid] &lt; val:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">print(bin_search(li,<span class="number">5</span>))   <span class="comment">#2</span></span><br></pre></td></tr></table></figure>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思路：列表每两个相邻的数，如果前边的比后边的大，那么交换这两个数……<br>冒泡排序稳定<br>时间复杂度O(n^2)   最好情况（已经有序）时间复杂度O(n)  最坏情况和平均情况时间复杂度O(n^2)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>):    <span class="comment">#i表示第n趟，一共n趟或n-1趟</span></span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)-i<span class="number">-1</span>): <span class="comment">#第i趟  无序区[0,n-i-1] j表示箭头 0~n-i-2</span></span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j],li[j+<span class="number">1</span>] = li[j+<span class="number">1</span>],li[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line"></span><br><span class="line">print(bubble_sort([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">52</span>,<span class="number">4</span>,<span class="number">34</span>]))    <span class="comment">#[1, 3, 4, 4, 34, 52]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1591701599%281%29.png" alt="attr"></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思路：一趟遍历记录最小的数，放到第一个位置；再一趟遍历记录剩余列表中最小的数，继续放置，以此类推<br>选择排序不稳定<br>时间复杂度O(n^2)（比冒牌排序块）<br>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>):   <span class="comment">#n或者n-1趟</span></span><br><span class="line">        <span class="comment"># 第i趟无序区范围i~最后</span></span><br><span class="line">        min_pos = i    <span class="comment"># min_pos更新为无序区最小值的位置</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(li)):</span><br><span class="line">            <span class="keyword">if</span> li[j] &lt; li[min_pos]:</span><br><span class="line">                min_pos = j</span><br><span class="line">        li[min_pos],li[i] = li[i],li[min_pos]</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line">li = [<span class="number">2</span>,<span class="number">435</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">2</span>,<span class="number">35</span>]</span><br><span class="line">print(select_sort(li))</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思路：列表被分为有序区和无序区两个部分。最初有序区只有一个元素。每次从无序区选择一个元素，插入到有序区的位置，直到无序区变空。<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1591755246%281%29.png" alt="attr"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(li)):  <span class="comment"># i表示摸到牌的下标</span></span><br><span class="line">        tmp = li[i]   <span class="comment"># 摸到的牌存起来</span></span><br><span class="line">        j = i<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> j&gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; tmp:   <span class="comment">#只要往后挪就循环</span></span><br><span class="line">            <span class="comment"># 如果j等于-1或者 li[j]小了 停止挪</span></span><br><span class="line">            li[j+<span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># j位置在循环结束的时候要么是-1要么是一个比tmp小的值</span></span><br><span class="line">        li[j+<span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> li</span><br><span class="line">print(insert_sort([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">34</span>,<span class="number">6</span>,<span class="number">34</span>,<span class="number">54</span>]))   <span class="comment">#[1, 2, 5, 6, 34, 34, 54]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法python</category>
      </categories>
      <tags>
        <tag>数据结构与算法python</tag>
      </tags>
  </entry>
  <entry>
    <title>原生Ajax与Promise的结合使用</title>
    <url>/blog/2020/07/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/%E5%8E%9F%E7%94%9FAjax%E4%B8%8EPromise%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在面试京东提前批一面的时候，面试官让手写一个原生js写Ajax请求与Promise相结合的使用，保证执行顺序，在第一个请求正确返回后再发送第二个请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生js写Ajax请求对象ajaxPromise(使用Promise的ajax请求)</span></span><br><span class="line"><span class="keyword">const</span> ajaxPromise = <span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//在这里不考虑IE7以下的浏览器兼容问题</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(param.type || <span class="string">"get"</span>, param.url, <span class="literal">true</span>);</span><br><span class="line">    xhr.send(param.data || <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> DONE = <span class="number">4</span>;   <span class="comment">//readyState 4 代表已经向服务器发送请求，并接收到全部数据</span></span><br><span class="line">      <span class="keyword">var</span> OK = <span class="number">200</span>;   <span class="comment">// status 200 代表服务器返回成功</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === DONE) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status === OK) &#123;</span><br><span class="line">          resolve(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(<span class="built_in">JSON</span>.parse(xhr.responseText));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个请求</span></span><br><span class="line"><span class="keyword">let</span> step1 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ajaxPromise(&#123;</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">""</span>,</span><br><span class="line">  &#125;).then( <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一个请求正确返回==&gt;"</span> + res);</span><br><span class="line">    step2(res)</span><br><span class="line">  &#125;).catch( <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第一个请求失败"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个请求</span></span><br><span class="line"><span class="keyword">let</span> step2 = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  ajaxPromise(&#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"get"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"data"</span>: &#123;<span class="string">"name"</span>: res&#125;</span><br><span class="line">  &#125;).then( <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第二个请求正确返回==&gt;"</span> + res);</span><br><span class="line">  &#125;).catch( <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"第二个请求失败"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面经</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础</title>
    <url>/blog/2020/06/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95python/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h2><p>算法：一个计算过程，解决问题的方法</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>用来评估算法运行效率的一个式子（单位）。<br>一般来说，时间复杂度高的算法比复杂度低的算法慢。<br>常见的时间复杂度（按效率排序）<br>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^2logn)&lt;O(n^3)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>用来评估算法内存占用大小的一个式子。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归的两个特点 调用自身和结束条件<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">0</span>):</span><br><span class="line">        print(x)        <span class="comment">#输出为3 2 1</span></span><br><span class="line">        func3(x<span class="number">-1</span>)     </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">0</span>):</span><br><span class="line">        func3(x<span class="number">-1</span>)      </span><br><span class="line">        print(x)       <span class="comment">#输出为1 2 3</span></span><br></pre></td></tr></table></figure>
<h3 id="斐波那契数列-1-1-2-3-5-8-…"><a href="#斐波那契数列-1-1-2-3-5-8-…" class="headerlink" title="斐波那契数列 1 1 2 3 5 8 …"></a>斐波那契数列 1 1 2 3 5 8 …</h3><p>F(n) = F(n-1) + F(n-2)   F(0)=1   F(1)=1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibnacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fibnacci(n<span class="number">-1</span>) + fibnacci(n<span class="number">-2</span>)</span><br><span class="line">print(fibnacci(<span class="number">10</span>))    <span class="comment">#89   时间复杂度时2^n</span></span><br></pre></td></tr></table></figure>

<p>面试题：一段有n个台阶组成的楼梯，小明从楼梯的最底层向最高处前进，他可以选择一次迈一级台阶或者一次迈两级台阶。问：他有多少种不同的走法？(画图可看出与斐波那契数列相似)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F(n) = F(n<span class="number">-1</span>) + F(n<span class="number">-2</span>)   F(<span class="number">1</span>)=<span class="number">1</span>   F(<span class="number">2</span>)=<span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibnacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n==<span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fibnacci(n<span class="number">-1</span>) + fibnacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="递归实例：汉诺塔问题"><a href="#递归实例：汉诺塔问题" class="headerlink" title="递归实例：汉诺塔问题"></a>递归实例：汉诺塔问题</h2><p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1591586789%281%29.png" alt="attr"></p>
<p>解决办法如下：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1591592615%281%29.png" alt="attr"><br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1591592737%281%29.png" alt="attr"></p>
<p>代码程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span><span class="params">(n,A,B,C)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        hanoi(n<span class="number">-1</span>,A,C,B)</span><br><span class="line">        print(<span class="string">'%s-&gt;%s'</span> % (A,C))</span><br><span class="line">        hanoi(n - <span class="number">1</span>, B, A, C)</span><br><span class="line"></span><br><span class="line"><span class="comment">#步数计算</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * h(n<span class="number">-1</span>) + <span class="number">1</span></span><br><span class="line">hanoi(<span class="number">3</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>)</span><br><span class="line">print(h(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A-&gt;C</span><br><span class="line">A-&gt;B</span><br><span class="line">C-&gt;B</span><br><span class="line">A-&gt;C</span><br><span class="line">B-&gt;A</span><br><span class="line">B-&gt;C</span><br><span class="line">A-&gt;C</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法python</category>
      </categories>
      <tags>
        <tag>数据结构与算法python</tag>
      </tags>
  </entry>
  <entry>
    <title>html5 新增元素以及css3新特性</title>
    <url>/blog/2020/07/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/html5%20%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0%E4%BB%A5%E5%8F%8Acss3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="HTML5-新元素"><a href="#HTML5-新元素" class="headerlink" title="HTML5 新元素"></a>HTML5 新元素</h3><p>HTML5提供了新的元素来创建更好的页面结构：</p>
<table>
<thead>
<tr>
<th>HTML5元素</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;article&gt;</code></td>
<td>定义页面独立的内容区域</td>
</tr>
<tr>
<td><code>&lt;aside&gt;</code></td>
<td>定义页面的侧边栏内容</td>
</tr>
<tr>
<td><code>&lt;bdi&gt;</code></td>
<td>允许您设置一段文本，使其脱离父元素的文本方向设置（目前只有 Firefox 和 Chrome 浏览器支持 bdi 标签）</td>
</tr>
<tr>
<td><code>&lt;command&gt;</code></td>
<td>定义命令按钮，比如单选按钮、复选框或按钮</td>
</tr>
<tr>
<td><code>&lt;details&gt;</code></td>
<td>用于描述文档或文档某个部分的细节</td>
</tr>
<tr>
<td><code>&lt;dialog&gt;</code></td>
<td>定义对话框，比如提示框</td>
</tr>
<tr>
<td><code>&lt;summary&gt;</code></td>
<td>标签包含 <code>&lt;details&gt;</code> 元素的标题</td>
</tr>
<tr>
<td><code>&lt;figure&gt;</code></td>
<td>规定独立的流内容（图像、图表、照片、代码等等）</td>
</tr>
<tr>
<td><code>&lt;figcaption&gt;</code></td>
<td>定义 <code>&lt;figure&gt;</code> 元素的标题</td>
</tr>
<tr>
<td><code>&lt;footer&gt;</code></td>
<td>定义 section 或 document 的页脚</td>
</tr>
<tr>
<td><code>&lt;header&gt;</code></td>
<td>定义了文档的头部区域</td>
</tr>
<tr>
<td><code>&lt;mark&gt;</code></td>
<td>定义带有记号的文本。</td>
</tr>
<tr>
<td><code>&lt;meter&gt;</code></td>
<td>定义度量衡。仅用于已知最大和最小值的度量</td>
</tr>
<tr>
<td><code>&lt;nav&gt;</code></td>
<td>定义导航链接的部分</td>
</tr>
<tr>
<td><code>&lt;progress&gt;</code></td>
<td>定义任何类型的任务的进度</td>
</tr>
<tr>
<td><code>&lt;ruby&gt;</code></td>
<td>定义 <code>ruby</code> 注释（中文注音或字符）</td>
</tr>
<tr>
<td><code>&lt;rt&gt;</code></td>
<td>定义字符（中文注音或字符）的解释或发音</td>
</tr>
<tr>
<td><code>&lt;rp&gt;</code></td>
<td>在 <code>ruby</code> 注释中使用，定义不支持 <code>ruby</code> 元素的浏览器所显示的内容</td>
</tr>
<tr>
<td><code>&lt;section&gt;</code></td>
<td>定义文档中的节（section、区段）</td>
</tr>
<tr>
<td><code>&lt;time&gt;</code></td>
<td>定义日期或时间</td>
</tr>
<tr>
<td><code>&lt;wbr&gt;</code></td>
<td>规定在文本中的何处适合添加换行符</td>
</tr>
</tbody></table>
<h3 id="HTML5-Canvas"><a href="#HTML5-Canvas" class="headerlink" title="HTML5 Canvas"></a>HTML5 Canvas</h3><div class="note info">
            <p>HTML5 <code>&lt;canvas&gt;</code> 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成.</p><ul><li><code>&lt;canvas&gt;</code>标签只是图形容器，您必须使用脚本来绘制图形。</li><li>使用 <code>JavaScript</code> 来绘制图像, <code>canvas</code> 元素本身是没有绘图能力的。所有的绘制工作必须在 <code>JavaScript</code> 内部完成</li></ul>
          </div>
<p><code>&lt;canvas&gt;</code>简单实例如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span><span class="attr">width</span>=<span class="string">"200"</span><span class="attr">height</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> ctx=c.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="actionscript">  ctx.fillStyle=<span class="string">"#FF0000"</span>;</span></span><br><span class="line">  ctx.fillRect(0,0,150,75);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML5-拖放"><a href="#HTML5-拖放" class="headerlink" title="HTML5 拖放"></a>HTML5 拖放</h3><p><strong>拖放（<code>Drag</code> 和 <code>drop</code>）是 <code>HTML5</code> 标准的组成部分。</strong></p>
<p>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。在 <code>HTML5</code> 中，拖放是标准的一部分，任何元素都能够拖放。</p>
<h4 id="HTML5-拖放实例"><a href="#HTML5-拖放实例" class="headerlink" title="HTML5 拖放实例"></a>HTML5 拖放实例</h4><p>下面的例子是一个简单的拖放实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span><span class="params">(ev)</span></span></span></span><br><span class="line">      &#123;</span><br><span class="line">        ev.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">drag</span><span class="params">(ev)</span></span></span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="actionscript">        ev.dataTransfer.setData(<span class="string">"Text"</span>,ev.target.id);</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">drop</span><span class="params">(ev)</span></span></span></span><br><span class="line">      &#123;</span><br><span class="line">        ev.preventDefault();</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> data=ev.dataTransfer.getData(<span class="string">"Text"</span>);</span></span><br><span class="line"><span class="javascript">        ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span> <span class="attr">ondrop</span>=<span class="string">"drop(event)"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ondragover</span>=<span class="string">"allowDrop(event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"drag1"</span> <span class="attr">src</span>=<span class="string">"img_logo.gif"</span> <span class="attr">draggable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">ondragstart</span>=<span class="string">"drag(event)"</span> <span class="attr">width</span>=<span class="string">"336"</span> <span class="attr">height</span>=<span class="string">"69"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="设置元素为可拖放"><a href="#设置元素为可拖放" class="headerlink" title="设置元素为可拖放"></a>设置元素为可拖放</h4><p>首先，为了使元素可拖动，把 draggable 属性设置为 true </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="拖动什么-ondragstart-和-setData"><a href="#拖动什么-ondragstart-和-setData" class="headerlink" title="拖动什么 - ondragstart 和 setData()"></a>拖动什么 - ondragstart 和 setData()</h4><p>然后，规定当元素被拖动时，会发生什么。</p>
<p>在上面的例子中，<code>ondragstart</code> 属性调用了一个函数，<code>drag(event)</code>，它规定了被拖动的数据。</p>
<p><code>dataTransfer.setData()</code> 方法设置被拖数据的数据类型和值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  ev.dataTransfer.setData(<span class="string">"Text"</span>,ev.target.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，数据类型是 <code>&quot;Text&quot;</code>，值是可拖动元素的 <code>id (&quot;drag1&quot;)</code>。</p>
<h4 id="放到何处-ondragover"><a href="#放到何处-ondragover" class="headerlink" title="放到何处 - ondragover"></a>放到何处 - ondragover</h4><p><code>ondragover</code> 事件规定在何处放置被拖动的数据。</p>
<p><strong>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</strong></p>
<p>这要通过调用 <code>ondragover</code> 事件的 <code>event.preventDefault()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.preventDefault()</span><br></pre></td></tr></table></figure>

<h4 id="进行放置-ondrop"><a href="#进行放置-ondrop" class="headerlink" title="进行放置 - ondrop"></a>进行放置 - ondrop</h4><p>当放置被拖数据时，会发生 <code>drop</code> 事件。</p>
<p>在上面的例子中，ondrop 属性调用了一个函数，<code>drop(event)</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">  ev.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> data = ev.dataTransfer.getData(<span class="string">"Text"</span>);</span><br><span class="line">  ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>代码解释：</p><ul><li>调用 <code>preventDefault()</code> 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）;</li><li>通过 <code>dataTransfer.getData(&quot;Text&quot;)</code> 方法获得被拖的数据。该方法将返回在 <code>setData()</code> 方法中设置为相同类型的任何数据;</li><li>被拖数据是被拖元素的 <code>id (&quot;drag1&quot;)</code>;</li><li>把被拖元素追加到放置元素（目标元素）中。</li></ul>
          </div>

<h4 id="HTML-5-Canvas（画布）"><a href="#HTML-5-Canvas（画布）" class="headerlink" title="HTML 5 Canvas（画布）"></a>HTML 5 Canvas（画布）</h4><p><code>canvas</code> 元素用于在网页上绘制图形。</p>
<h4 id="什么是-Canvas？"><a href="#什么是-Canvas？" class="headerlink" title="什么是 Canvas？"></a>什么是 Canvas？</h4><div class="note info">
            <ul><li>HTML5 的 <code>canvas</code> 元素使用 JavaScript 在网页上绘制图像。</li><li>画布是一个矩形区域，您可以控制其每一像素。</li><li><code>canvas</code> 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li></ul>
          </div>

<h4 id="创建-Canvas-元素"><a href="#创建-Canvas-元素" class="headerlink" title="创建 Canvas 元素"></a>创建 Canvas 元素</h4><p>向 HTML5 页面添加 <code>canvas</code> 元素。规定元素的 id、宽度和高度：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过-JavaScript-来绘制"><a href="#通过-JavaScript-来绘制" class="headerlink" title="通过 JavaScript 来绘制"></a>通过 JavaScript 来绘制</h4><p><strong>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">//JavaScript 使用 id 来寻找 canvas 元素：</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">//创建 context 对象,getContext("2d") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> cxt = c.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="comment">//下面的两行代码绘制一个红色的矩形,fillStyle 方法将其染成红色，fillRect 方法规定了形状、位置和尺寸</span></span></span><br><span class="line"><span class="actionscript">  cxt.fillStyle = <span class="string">"#FF0000"</span>;</span></span><br><span class="line">  cxt.fillRect(0,0,150,75);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的 <code>fillRect</code> 方法拥有参数 <code>(0,0,150,75)</code>。意思是：在画布上绘制 <code>150x75</code> 的矩形，从左上角开始 <code>(0,0)</code>。如下图所示，画布的 X 和 Y 坐标用于在画布上对绘画进行定位。</p>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/HTML5/canvas%E7%BB%98%E5%9B%BE%E7%9A%84fillRect.gif" alt="attr"></p>
<h3 id="HTML5-内联-SVG"><a href="#HTML5-内联-SVG" class="headerlink" title="HTML5 内联 SVG"></a>HTML5 内联 SVG</h3><p><strong>HTML5 支持内联 SVG。</strong></p>
<div class="note info">
            <p>什么是SVG？</p><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li>SVG 用于定义用于网络的基于矢量的图形</li><li>SVG 使用 XML 格式定义图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li><li>SVG 是万维网联盟的标准</li></ul>
          </div>
<div class="note info">
            <p>SVG 的优势</p><ul><li>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</li><li>SVG 图像可通过文本编辑器来创建和修改</li><li>SVG 图像可被搜索、索引、脚本化或压缩</li><li>SVG 是可伸缩的</li><li>SVG 图像可在任何的分辨率下被高质量地打印</li><li>SVG 可在图像质量不下降的情况下被放大</li></ul>
          </div>

<h4 id="把-SVG-直接嵌入-HTML-页面"><a href="#把-SVG-直接嵌入-HTML-页面" class="headerlink" title="把 SVG 直接嵌入 HTML 页面"></a>把 SVG 直接嵌入 HTML 页面</h4><p>在 HTML5 中，您能够将 SVG 元素直接嵌入 HTML 页面中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">height</span>=<span class="string">"190"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">"100,10 40,180 190,60 10,60 160,180"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/HTML5/HTML5%20SVG%E5%86%85%E8%81%94.png" alt="attr"></p>
<h3 id="Canvas-与-SVG-的比较"><a href="#Canvas-与-SVG-的比较" class="headerlink" title="Canvas 与 SVG 的比较"></a>Canvas 与 SVG 的比较</h3><div class="note info">
            <p>Canvas</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>SVG</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul>
          </div>

<h3 id="HTML5-地理定位"><a href="#HTML5-地理定位" class="headerlink" title="HTML5 地理定位"></a>HTML5 地理定位</h3><p><strong>HTML5 Geolocation（地理定位）用于定位用户的位置。</strong></p>
<h4 id="定位用户的位置"><a href="#定位用户的位置" class="headerlink" title="定位用户的位置"></a>定位用户的位置</h4><p>HTML5 Geolocation API 用于获得用户的地理位置。<br>鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p>
<h4 id="HTML5-使用地理定位"><a href="#HTML5-使用地理定位" class="headerlink" title="HTML5 - 使用地理定位"></a>HTML5 - 使用地理定位</h4><p>请使用 <code>getCurrentPosition()</code> 方法来获得用户的位置。下例是一个简单的地理定位实例，可返回用户位置的经度和纬度。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>);</span></span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">getLocation</span><span class="params">()</span></span></span></span><br><span class="line">    &#123;</span><br><span class="line">    if (navigator.geolocation)</span><br><span class="line">      &#123;</span><br><span class="line">      navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">else</span>&#123;x.innerHTML=<span class="string">"Geolocation is not supported by this browser."</span>;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">  <span class="function"><span class="keyword">function</span> <span class="title">showPosition</span><span class="params">(position)</span></span></span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="actionscript">    x.innerHTML=<span class="string">"Latitude: "</span> + position.coords.latitude +</span></span><br><span class="line"><span class="actionscript">    <span class="string">"&lt;br /&gt;Longitude: "</span> + position.coords.longitude;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note info">
            <p>例子解释：</p><ul><li>检测是否支持地理定位</li><li>如果支持，则运行 getCurrentPosition() 方法。如果不支持，则向用户显示一段消息。</li><li>如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象</li><li>showPosition() 函数获得并显示经度和纬度</li></ul>
          </div>

<h4 id="处理错误和拒绝"><a href="#处理错误和拒绝" class="headerlink" title="处理错误和拒绝"></a>处理错误和拒绝</h4><p><code>getCurrentPosition()</code> 方法的第二个参数用于处理错误。它规定当获取用户位置失败时运行的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showError</span>(<span class="params">error</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(error.code)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> error.PERMISSION_DENIED:</span><br><span class="line">      x.innerHTML=<span class="string">"User denied the request for Geolocation."</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> error.POSITION_UNAVAILABLE:</span><br><span class="line">      x.innerHTML=<span class="string">"Location information is unavailable."</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> error.TIMEOUT:</span><br><span class="line">      x.innerHTML=<span class="string">"The request to get user location timed out."</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> error.UNKNOWN_ERROR:</span><br><span class="line">      x.innerHTML=<span class="string">"An unknown error occurred."</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>错误代码：</p><ul><li>Permission denied - 用户不允许地理定位</li><li>Position unavailable - 无法获取当前位置</li><li>Timeout - 操作超时</li></ul>
          </div>

<h4 id="在地图中显示结果"><a href="#在地图中显示结果" class="headerlink" title="在地图中显示结果"></a>在地图中显示结果</h4><p>如需在地图中显示结果，您需要访问可使用经纬度的地图服务，比如谷歌地图或百度地图：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> latlon=position.coords.latitude+<span class="string">","</span>+position.coords.longitude;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> img_url=<span class="string">"http://maps.googleapis.com/maps/api/staticmap?center="</span></span><br><span class="line">              +latlon+<span class="string">"&amp;zoom=14&amp;size=400x300&amp;sensor=false"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"mapholder"</span>).innerHTML=<span class="string">"&lt;img src='"</span>+img_url+<span class="string">"' /&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getCurrentPosition-方法-返回数据"><a href="#getCurrentPosition-方法-返回数据" class="headerlink" title="getCurrentPosition() 方法 - 返回数据"></a>getCurrentPosition() 方法 - 返回数据</h4><p>若成功，则 <code>getCurrentPosition()</code> 方法返回对象。始终会返回 <code>latitude</code>、<code>longitude</code> 以及 <code>accuracy</code> 属性。如果可用，则会返回其他下面的属性。<br>属性             |    描述<br>—————–|—————————–<br>coords.latitude  | 十进制数的纬度<br>coords.longitude | 十进制数的经度<br>coords.accuracy  |     位置精度<br>coords.altitude  | 海拔，海平面以上以米计<br>coords.altitudeAccuracy | 位置的海拔精度<br>coords.heading   | 方向，从正北开始以度计<br>coords.speed     | 速度，以米/每秒计<br>timestamp        | 响应的日期/时间</p>
<h4 id="Geolocation-对象-其他有趣的方法"><a href="#Geolocation-对象-其他有趣的方法" class="headerlink" title="Geolocation 对象 - 其他有趣的方法"></a>Geolocation 对象 - 其他有趣的方法</h4><p><code>watchPosition()</code> - 返回用户的当前位置，并继续返回用户移动时的更新位置（就像汽车上的 GPS）。<br><code>clearWatch()</code> - 停止 <code>watchPosition()</code> 方法<br>下面的例子展示 <code>watchPosition()</code> 方法。您需要一台精确的 <code>GPS</code> 设备来测试该例（比如 iPhone）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>);</span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">getLocation</span><span class="params">()</span></span></span></span><br><span class="line">  &#123;</span><br><span class="line">  if (navigator.geolocation)</span><br><span class="line">    &#123;</span><br><span class="line">    navigator.geolocation.watchPosition(showPosition);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">  <span class="keyword">else</span>&#123;x.innerHTML=<span class="string">"Geolocation is not supported by this browser."</span>;&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span><span class="params">(position)</span></span></span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="actionscript">  x.innerHTML=<span class="string">"Latitude: "</span> + position.coords.latitude +</span></span><br><span class="line"><span class="actionscript">  <span class="string">"&lt;br /&gt;Longitude: "</span> + position.coords.longitude;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="HTML5-Audio-音频-、Video-视频"><a href="#HTML5-Audio-音频-、Video-视频" class="headerlink" title="HTML5  Audio(音频)、Video(视频)"></a>HTML5  Audio(音频)、Video(视频)</h3><p>HTML5 规定了一种通过 <code>video</code> 元素来包含视频的标准方法。</p>
<h4 id="lt-video-gt-标签的属性如下："><a href="#lt-video-gt-标签的属性如下：" class="headerlink" title="&lt;video&gt; 标签的属性如下："></a><code>&lt;video&gt;</code> 标签的属性如下：</h4><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则视频在就绪后马上播放</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮</td>
</tr>
<tr>
<td>height</td>
<td>pixels</td>
<td>设置视频播放器的高度</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则当媒介文件完成播放后再次开始播放</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>如果出现该属性，则视频在页面加载时进行加载，并预备播放,如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>要播放的视频的 URL</td>
</tr>
<tr>
<td>width</td>
<td>pixels</td>
<td>设置视频播放器的宽度</td>
</tr>
</tbody></table>
<p>例子如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"320"</span> <span class="attr">height</span>=<span class="string">"240"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line">Your browser does not support the video tag.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="HTML5-lt-video-gt-方法、属性以及事件"><a href="#HTML5-lt-video-gt-方法、属性以及事件" class="headerlink" title="HTML5 &lt;video&gt; - 方法、属性以及事件"></a>HTML5 <code>&lt;video&gt;</code> - 方法、属性以及事件</h4><p>下面列出了大多数浏览器支持的视频方法、属性和事件：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>属性</th>
<th>事件</th>
</tr>
</thead>
<tbody><tr>
<td>play()</td>
<td>currentSrc</td>
<td>play</td>
</tr>
<tr>
<td>pause()</td>
<td>currentTime</td>
<td>pause</td>
</tr>
<tr>
<td>load()</td>
<td>videoWidth</td>
<td>progress</td>
</tr>
<tr>
<td>canPlayType</td>
<td>videoHeight</td>
<td>error</td>
</tr>
<tr>
<td></td>
<td>duration</td>
<td>timeupdate</td>
</tr>
<tr>
<td></td>
<td>ended</td>
<td>ended</td>
</tr>
<tr>
<td></td>
<td>error</td>
<td>abort</td>
</tr>
<tr>
<td></td>
<td>paused</td>
<td>empty</td>
</tr>
<tr>
<td></td>
<td>muted</td>
<td>emptied</td>
</tr>
<tr>
<td></td>
<td>seeking</td>
<td>waiting</td>
</tr>
<tr>
<td></td>
<td>volume</td>
<td>loadedmetadata</td>
</tr>
<tr>
<td></td>
<td>height</td>
<td></td>
</tr>
<tr>
<td></td>
<td>width</td>
<td></td>
</tr>
</tbody></table>
<h3 id="HTML5-音频"><a href="#HTML5-音频" class="headerlink" title="HTML5 音频"></a>HTML5 音频</h3><p>HTML5 规定了在网页上嵌入音频元素的标准，即使用 <code>&lt;audio&gt;</code> 元素</p>
<h4 id="lt-audio-gt-标签的属性"><a href="#lt-audio-gt-标签的属性" class="headerlink" title="&lt;audio&gt; 标签的属性"></a><code>&lt;audio&gt;</code> 标签的属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>autoplay</td>
<td>如果出现该属性，则音频在就绪后马上播放</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则当媒介文件完成播放后再次开始播放</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>如果出现该属性，则音频在页面加载时进行加载，并预备播放,如果使用 “autoplay”，则忽略该属性。</td>
</tr>
<tr>
<td>src</td>
<td>url</td>
<td>要播放的音频的 URL</td>
</tr>
</tbody></table>
<h3 id="HTML-5-Web-存储"><a href="#HTML-5-Web-存储" class="headerlink" title="HTML 5 Web 存储"></a>HTML 5 Web 存储</h3><h4 id="在客户端存储数据"><a href="#在客户端存储数据" class="headerlink" title="在客户端存储数据"></a>在客户端存储数据</h4><div class="note info">
            <p>HTML5 提供了两种在客户端存储数据的新方法：</p><ul><li>localStorage: 没有时间限制的数据存储</li><li>sessionStorage: 针对一个session的数据存储</li></ul>
          </div>
<p><strong>HTML5 使用 JavaScript 来存储和访问数据。</strong><br>之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。</p>
<p>在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。</p>
<h4 id="localStorage-方法"><a href="#localStorage-方法" class="headerlink" title="localStorage 方法"></a>localStorage 方法</h4><p><code>localStorage</code> 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。<br>如何创建和访问 localStorage：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// Check browser support</span></span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (<span class="keyword">typeof</span>(Storage) !== <span class="string">"undefined"</span>) &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// Store</span></span></span><br><span class="line"><span class="actionscript">    localStorage.setItem(<span class="string">"lastname"</span>, <span class="string">"Gates"</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// Retrieve</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML = localStorage.getItem(<span class="string">"lastname"</span>);</span></span><br><span class="line"><span class="actionscript">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML = <span class="string">"抱歉！您的浏览器不支持 Web Storage ..."</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面的例子对用户访问页面的次数进行计数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">if (localStorage.pagecount) &#123;</span><br><span class="line"><span class="javascript">  localStorage.pagecount=<span class="built_in">Number</span>(localStorage.pagecount) +<span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">  localStorage.pagecount=1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"Visits "</span>+ localStorage.pagecount + <span class="string">" time(s)."</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="sessionStorage-方法"><a href="#sessionStorage-方法" class="headerlink" title="sessionStorage 方法"></a>sessionStorage 方法</h4><p><code>sessionStorage</code> 方法针对一个 <code>session</code> 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。<br>如何创建并访问一个 sessionStorage：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  sessionStorage.lastname=<span class="string">"Smith"</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.write(sessionStorage.lastname);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面的例子对用户在当前 session 中访问页面的次数进行计数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">if (sessionStorage.pagecount) &#123;</span><br><span class="line"><span class="javascript">  sessionStorage.pagecount=<span class="built_in">Number</span>(sessionStorage.pagecount) +<span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">  sessionStorage.pagecount=1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">"Visits "</span>+sessionStorage.pagecount+<span class="string">" time(s) this session."</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML-5-应用程序缓存"><a href="#HTML-5-应用程序缓存" class="headerlink" title="HTML 5 应用程序缓存"></a>HTML 5 应用程序缓存</h3><p><strong>使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本</strong></p>
<div class="note info">
            <p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。应用程序缓存为应用带来三个优势：</p><ul><li>离线浏览 - 用户可在应用离线时使用它们</li><li>速度 - 已缓存资源加载得更快</li><li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li></ul>
          </div>

<p>下面的例子展示了带有 cache manifest 的 HTML 文档（供离线浏览）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"demo.appcache"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    The content of the document......</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Cache-Manifest-基础"><a href="#Cache-Manifest-基础" class="headerlink" title="Cache Manifest 基础"></a>Cache Manifest 基础</h4><p>如需启用应用程序缓存，请在文档的 <code>&lt;html&gt;</code> 标签中包含 <code>manifest</code> 属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"demo.appcache"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。</p>
<p>manifest 文件的建议的文件扩展名是：<code>&quot;.appcache&quot;</code>。</p>
<p><strong>请注意，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”。必须在 web 服务器上进行配置。</strong></p>
<h4 id="Manifest-文件"><a href="#Manifest-文件" class="headerlink" title="Manifest 文件"></a>Manifest 文件</h4><p>manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p>
<div class="note info">
            <p>manifest 文件可分为三个部分：</p><ul><li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li><li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li><li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul>
          </div>
<h5 id="CACHE-MANIFEST"><a href="#CACHE-MANIFEST" class="headerlink" title="CACHE MANIFEST"></a>CACHE MANIFEST</h5><p><strong>第一行，CACHE MANIFEST，是必需的：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br></pre></td></tr></table></figure>
<h5 id="NETWORK"><a href="#NETWORK" class="headerlink" title="NETWORK"></a>NETWORK</h5><p><strong>下面的 NETWORK 小节规定文件 “login.asp” 永远不会被缓存，且离线时是不可用的：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br></pre></td></tr></table></figure>

<p><strong>可以使用星号来指示所有其他资源/文件都需要因特网连接：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">NETWORK:</span><br><span class="line">*</span><br></pre></td></tr></table></figure>
<h5 id="FALLBACK"><a href="#FALLBACK" class="headerlink" title="FALLBACK"></a>FALLBACK</h5><p><strong>下面的 FALLBACK 小节规定如果无法建立因特网连接，则用 “offline.html” 替代 /html5/ 目录中的所有文件：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">FALLBACK:</span><br><span class="line">/html5/ <span class="regexp">/404.html</span></span><br></pre></td></tr></table></figure>

<h4 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h4><div class="note info">
            <p>一旦应用被缓存，它就会保持缓存直到发生下列情况：</p><ul><li>用户清空浏览器缓存</li><li>manifest 文件被修改（参阅下面的提示）</li><li>由程序来更新应用缓存</li></ul>
          </div>

<h4 id="实例-完整的-Manifest-文件"><a href="#实例-完整的-Manifest-文件" class="headerlink" title="实例 - 完整的 Manifest 文件"></a>实例 - 完整的 Manifest 文件</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 2012-02-21 v1.0.0</span><br><span class="line">/theme.css</span><br><span class="line">/logo.gif</span><br><span class="line">/main.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">/html5/ <span class="regexp">/404.html</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML-5-Web-Workers"><a href="#HTML-5-Web-Workers" class="headerlink" title="HTML 5 Web Workers"></a>HTML 5 Web Workers</h3><p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
<h4 id="HTML5-Web-Workers-实例"><a href="#HTML5-Web-Workers-实例" class="headerlink" title="HTML5 Web Workers 实例"></a>HTML5 Web Workers 实例</h4><p>下面的例子创建了一个简单的 web worker，在后台计数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>计数: <span class="tag">&lt;<span class="name">output</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"startWorker()"</span>&gt;</span>开始 Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"stopWorker()"</span>&gt;</span>停止 Worker<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> w;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">startWorker</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!==<span class="string">"undefined"</span>) &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(w)==<span class="string">"undefined"</span>) &#123;</span></span><br><span class="line"><span class="actionscript">      w=<span class="keyword">new</span> Worker(<span class="string">"/example/html5/demo_workers.js"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    w.onmessage = <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=event.data;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=<span class="string">"Sorry, your browser does not support Web Workers..."</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">stopWorker</span><span class="params">()</span> </span>&#123; </span></span><br><span class="line">  w.terminate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="检测-Web-Worker-支持"><a href="#检测-Web-Worker-支持" class="headerlink" title="检测 Web Worker 支持"></a>检测 Web Worker 支持</h4><p>在创建 web worker 之前，请检测用户的浏览器是否支持它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(Worker)!==<span class="string">"undefined"</span>) &#123;</span><br><span class="line">  <span class="comment">// Yes! Web worker support!</span></span><br><span class="line">  <span class="comment">// Some code.....</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Sorry! No Web Worker support..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-web-worker-文件"><a href="#创建-web-worker-文件" class="headerlink" title="创建 web worker 文件"></a>创建 web worker 文件</h4><p>现在，让我们在一个外部 JavaScript 中创建我们的 web worker。在这里，我们创建了计数脚本。该脚本存储于 “demo_workers.js” 文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timedCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">i=i+<span class="number">1</span>;</span><br><span class="line">postMessage(i);</span><br><span class="line">setTimeout(<span class="string">"timedCount()"</span>,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timedCount();</span><br></pre></td></tr></table></figure>
<p><strong>以上代码中重要的部分是 postMessage() 方法 - 它用于向 HTML 页面传回一段消息。</strong></p>
<p><strong>注释：web worker 通常不用于如此简单的脚本，而是用于更耗费 CPU 资源的任务。</strong></p>
<h4 id="创建-Web-Worker-对象"><a href="#创建-Web-Worker-对象" class="headerlink" title="创建 Web Worker 对象"></a>创建 Web Worker 对象</h4><p>我们已经有了 web worker 文件，现在我们需要从 HTML 页面调用它。</p>
<p>下面的代码检测是否存在 worker，如果不存在，- 它会创建一个新的 web worker 对象，然后运行 “demo_workers.js” 中的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(w)==<span class="string">"undefined"</span>) &#123;</span><br><span class="line">  w=<span class="keyword">new</span> Worker(<span class="string">"demo_workers.js"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以从 web worker 发生和接收消息了。</p>
<p>向 web worker 添加一个 “onmessage” 事件监听器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 web worker 传递消息时，会执行事件监听器中的代码。event.data 中存有来自 event.data 的数据。</p>
<h4 id="终止-Web-Worker"><a href="#终止-Web-Worker" class="headerlink" title="终止 Web Worker"></a>终止 Web Worker</h4><p>当我们创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。</p>
<p>如需终止 web worker，并释放浏览器/计算机资源，请使用 <code>terminate()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">w.terminate();</span><br></pre></td></tr></table></figure>
<h4 id="Web-Workers-和-DOM"><a href="#Web-Workers-和-DOM" class="headerlink" title="Web Workers 和 DOM"></a>Web Workers 和 DOM</h4><div class="note info">
            <p>由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象：</p><ul><li>window 对象</li><li>document 对象</li><li>parent 对象</li></ul>
          </div>

<h3 id="HTML-5-服务器发送事件"><a href="#HTML-5-服务器发送事件" class="headerlink" title="HTML 5 服务器发送事件"></a>HTML 5 服务器发送事件</h3><p><strong>HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。</strong></p>
<h3 id="Server-Sent-事件-单向消息传递"><a href="#Server-Sent-事件-单向消息传递" class="headerlink" title="Server-Sent 事件 - 单向消息传递"></a>Server-Sent 事件 - 单向消息传递</h3><p>Server-Sent事件指的是网页自动获取来自服务器的更新。</p>
<h3 id="接收-Server-Sent-事件通知"><a href="#接收-Server-Sent-事件通知" class="headerlink" title="接收 Server-Sent 事件通知"></a>接收 Server-Sent 事件通知</h3><p>EventSource 对象用于接收服务器发送事件通知：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source=<span class="keyword">new</span> EventSource(<span class="string">"demo_sse.php"</span>);</span><br><span class="line">source.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML+=event.data + <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>例子解释：</p><ul><li>创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 “demo_sse.php”）</li><li>每接收到一次更新，就会发生 onmessage 事件</li><li>当 onmessage 事件发生时，把已接收的数据推入 id 为 “result” 的元素中</li></ul>
          </div>

<h3 id="HTML5表单"><a href="#HTML5表单" class="headerlink" title="HTML5表单"></a>HTML5表单</h3><p><a href="https://www.w3school.com.cn/html5/html_5_form_input_types.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/html5/html_5_form_input_types.asp</a></p>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><p><a href="https://www.w3school.com.cn/css3/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css3/index.asp</a></p>
]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面经</tag>
      </tags>
  </entry>
  <entry>
    <title>大疆前端笔试汇总（笔试前准备版）</title>
    <url>/blog/2020/08/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/%E5%A4%A7%E7%96%86%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95/</url>
    <content><![CDATA[<h2 id="JavaScript之防篡改对象（高级技巧）"><a href="#JavaScript之防篡改对象（高级技巧）" class="headerlink" title="JavaScript之防篡改对象（高级技巧）"></a>JavaScript之防篡改对象（高级技巧）</h2><p>在实际开发中，有时会无意地修改了别人的代码，或者用不兼容的功能重写原生对象，这样会给整个开发带来困扰。使用防篡改方式可以防止别人篡改对象代码。</p>
<p><strong>注：一旦对象定义为防篡改，就无法撤销了。也就是说无法改回来了。</strong></p>
<h3 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h3><p>在默认情况下，所有对象都是可以扩展的，也就是说，无论什么时候都可以向对象中添加属性和方法。例如以下，先定义一个对象，再向其添加一个新属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Tom"</span></span><br><span class="line">&#125;</span><br><span class="line">obj.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age)  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p><strong>即使先定义好一个对象，后面也可以向其新添加属性和方法。</strong></p>
<h4 id="Object-preventExtensions-方法"><a href="#Object-preventExtensions-方法" class="headerlink" title="Object.preventExtensions()方法"></a>Object.preventExtensions()方法</h4><p>现在使用<code>Object.preventExtensions()</code>方法可以改变这个行为，这样就不能向对象中新添加属性和方法了。<strong>不可扩展量一级保护措施。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Tom"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line">obj.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);  <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改原有的属性</span></span><br><span class="line">obj.name = <span class="string">"Bob"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">//Bob</span></span><br></pre></td></tr></table></figure>
<p><strong>可以发现，使用了Object.preventExtensions()方法，就不能向对象中新添加属性和方法了，但是可以修改对象原有的属性和方法。</strong></p>
<h4 id="Object-isExtensible-方法"><a href="#Object-isExtensible-方法" class="headerlink" title="Object.isExtensible()方法"></a>Object.isExtensible()方法</h4><p>使用这个方法可以确定对象是否为可篡改，如果可篡改，则返回<code>true</code>，相反返回<code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Tom"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj));  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="密封的对象"><a href="#密封的对象" class="headerlink" title="密封的对象"></a>密封的对象</h3><p>对象的第二个保护级别就是密封对象，密封对象不可扩展，且其对象的属性特性<code>[[Configurable]]</code>被设置为<code>false</code>，意味着对象的属性和方法不能通过<code>delete</code>操作符删除。<br>该方法用于密封对象。</p>
<h4 id="Object-seal-方法"><a href="#Object-seal-方法" class="headerlink" title="Object.seal()方法"></a>Object.seal()方法</h4><p>该方法用于密封对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//密封对象</span></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"> </span><br><span class="line">obj.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">//undefined 不能新添加属性</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">//Tom 不能删除对象的属性</span></span><br></pre></td></tr></table></figure>
<p>密封的对象不能新添加属性、不能删除属性。拥有了不可扩展对象的特性。</p>
<h4 id="Object-isSealed-方法"><a href="#Object-isSealed-方法" class="headerlink" title="Object.isSealed()方法"></a>Object.isSealed()方法</h4><p>该方法用于确定对象是否是密封对象，如果是密封对象返回true，相反返回false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Ojbect.isSealed(obj)); <span class="comment">//false</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(obj)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(Ojbect.isSealed(obj)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a>冻结对象</h3><p>保护对象的最高级防篡改就是冻结对象。冻结的对象，即是不可扩展的，也是密封的，而且其属性的特性<code>[[Writable]]</code>被设置为<code>false</code>，也就是说<strong>属性值也不能修改</strong>。</p>
<h4 id="Object-freeze-方法"><a href="#Object-freeze-方法" class="headerlink" title="Object.freeze()方法"></a>Object.freeze()方法</h4><p>该方法用于设置对象为冻结对象。冻结对象同时拥有了不可扩展对象、密封对象的特性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Tom"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.freeze(obj); <span class="comment">//冻结对象</span></span><br><span class="line">obj.age = <span class="number">21</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);  <span class="comment">//undefined 不可扩展</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);  <span class="comment">//Tom 不可删除</span></span><br><span class="line">obj.name = <span class="string">"Bob"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)   <span class="comment">//Tom 不可修改</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-isFrozen-方法"><a href="#Object-isFrozen-方法" class="headerlink" title="Object.isFrozen()方法"></a>Object.isFrozen()方法</h4><p>该方法用于确定对象是否是冻结对象。如果是返回true，相反返回false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//未冻结之前</span></span><br><span class="line"><span class="built_in">console</span>.log(Oject.isExtensible(obj)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Oject.isSealed(obj)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(Oject.isFrozen(obj)); <span class="comment">//false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//冻结对象之后</span></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj); <span class="comment">//冻结对象</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(Oject.isExtensible(obj)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(Oject.isSealed(obj)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(Oject.isFrozen(obj)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>总结： 不可扩展对象、密封对象均可修改属性。不可扩展对象、密封对象、冻结对象均不可扩展。密封对象、冻结对象均不可删除属性。</strong></p>
<h2 id="CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？"><a href="#CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？" class="headerlink" title="CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？"></a>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？</h2><h3 id="CSS-选择符有哪些？"><a href="#CSS-选择符有哪些？" class="headerlink" title="CSS 选择符有哪些？"></a>CSS 选择符有哪些？</h3><div class="note info">
            <p>1.id选择器（#id）<br>2.类选择器（.class）<br>3.标签选择器（div，h1，p）<br>4.相邻选择器（h1 + p）<br>5.子选择器（ul &gt; li）<br>6.后代选择器（li a）<br>7.通配符选择器（ * ）<br>8.属性选择器（a[title]）<br>9.伪类选择器（a:hover，li:nth-child）</p>
          </div>

<h3 id="可继承的样式"><a href="#可继承的样式" class="headerlink" title="可继承的样式"></a>可继承的样式</h3><div class="note info">
            <p>1.字体系列属性 font，font-family，font-weight，font-size，font-style，font-variant，font-stretch，font-size-adjust<br>2.文本系列属性 text-indent，text-align，line-height，word-spacing，letter-spacing，text-transform，direction，color<br>3.元素可见性 visibility<br>4.表格布局属性 caption-side，border-collapse，border-spacing，empty-cells，table-layout<br>5.列表布局属性 list-style-type，list-style-image，list-style-position，list-style<br>6.生成内容属性 quotes<br>7.光标属性 cursor<br>8.页面样式属性 page，page-break-inside，windows，orphans<br>9.声音样式属性 speak，speak-punctuation，speak-numeral，speak-header，speech-rate，volume，voice-family，pitch，pitch-range，stress，richness，azimuth，elevation</p>
          </div>

<h3 id="优先级算法如何计算？"><a href="#优先级算法如何计算？" class="headerlink" title="优先级算法如何计算？"></a>优先级算法如何计算？</h3><div class="note info">
            <p>1.优先级就近原则，同权重情况下样式定义最近者为准；<br>2.载入样式以最后载入的定位为准；<br>3.!important &gt; id &gt; class &gt; tag；<br>4.important 比 内联优先级高，但内联比id要高。</p>
          </div>

<h2 id="前端三种存储方式"><a href="#前端三种存储方式" class="headerlink" title="前端三种存储方式"></a>前端三种存储方式</h2><p>参考： <a href="https://blog.csdn.net/qq_40779721/article/details/79196893" target="_blank" rel="noopener">https://blog.csdn.net/qq_40779721/article/details/79196893</a><br>js-cookie使用： <a href="https://www.cnblogs.com/zzz-knight/p/11692362.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzz-knight/p/11692362.html</a></p>
<h2 id="什么是面向对象？面向对象的特征是什么？"><a href="#什么是面向对象？面向对象的特征是什么？" class="headerlink" title="什么是面向对象？面向对象的特征是什么？"></a>什么是面向对象？面向对象的特征是什么？</h2><p>参考：<a href="https://www.cnblogs.com/zhengyufeng/p/10992972.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengyufeng/p/10992972.html</a><br>和另一篇博客：<br><a href="http://localhost:4000/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">http://localhost:4000/blog/2020/04/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</a></p>
<h2 id="千位分隔符（js实现）"><a href="#千位分隔符（js实现）" class="headerlink" title="千位分隔符（js实现）"></a>千位分隔符（js实现）</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//方法一</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 千位分隔符(js 实现)</span></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">thousandBitSeparator</span><span class="params">(str)</span></span>&#123; </span></span><br><span class="line"><span class="javascript">    str = <span class="built_in">String</span>(str);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span> (str.indexOf(<span class="string">'.'</span>)&gt;=<span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> postfix = str.substring(str.indexOf(<span class="string">'.'</span>));</span></span><br><span class="line"><span class="actionscript">        str = str.substring(<span class="number">0</span>,str.indexOf(<span class="string">'.'</span>));</span></span><br><span class="line"><span class="actionscript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> postfix = <span class="string">''</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="actionscript">    <span class="comment">// console.log(postfix);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// .99</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// console.log(str);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 9999999999999</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> iNum = str.length % <span class="number">3</span>; </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> prev = <span class="string">''</span>; </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> iNow = <span class="number">0</span>; </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> temp = <span class="string">''</span>; </span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr = []; </span></span><br><span class="line">    if (iNum != 0)&#123; </span><br><span class="line">        prev = str.substring(0, iNum); </span><br><span class="line">        arr.push(prev); </span><br><span class="line">    &#125; </span><br><span class="line">    str = str.substring(iNum); </span><br><span class="line"><span class="actionscript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123; </span></span><br><span class="line">        iNow++; </span><br><span class="line">        temp += str[i]; </span><br><span class="line">        if (iNow == 3 &amp;&amp; temp)&#123; </span><br><span class="line">          arr.push(temp); </span><br><span class="line"><span class="actionscript">          temp = <span class="string">''</span>; </span></span><br><span class="line">          iNow = 0; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"><span class="actionscript">    <span class="comment">// console.log(arr);</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// ["9", "999", "999", "999", "999"]</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> arr.join(<span class="string">','</span>) + postfix; </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(thousandBitSeparator(<span class="string">'9999999999999.99222'</span>));</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 9,999,999,999,999.99</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//方法二，正则表达式</span></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 正则</span></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">thousandBitSeparator</span><span class="params">(num)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> num</span></span><br><span class="line">        .toString()</span><br><span class="line"><span class="javascript">        .replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">0</span>, $<span class="number">1</span></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> $<span class="number">1</span> + <span class="string">","</span>;</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(thousandBitSeparator(<span class="number">-1234567.9012</span>));</span></span><br><span class="line"><span class="actionscript"><span class="comment">// -1,234,567.9012</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>参考：<a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">https://www.cnblogs.com/onepixel/articles/7674659.html</a><br>我写过的快排代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array,left,right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//待排序的区域至少有两个元素</span></span><br><span class="line">    <span class="keyword">let</span> len = array.length</span><br><span class="line">    left = <span class="keyword">typeof</span> left != <span class="string">'number'</span>? <span class="number">0</span> : left;</span><br><span class="line">    right = <span class="keyword">typeof</span> right != <span class="string">'number'</span>? len - <span class="number">1</span> : right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        mid = partition(array,left,right)</span><br><span class="line">        quickSort(array,left,mid<span class="number">-1</span>)</span><br><span class="line">        quickSort(array,mid+<span class="number">1</span>,right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分区操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;     <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">let</span> pivot = left,                      <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = quickSort(list)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line">--------------------------------------------------------------------</span><br><span class="line">方法二：</span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array,left,right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = array.length</span><br><span class="line">    left = <span class="keyword">typeof</span> left != <span class="string">'number'</span>? <span class="number">0</span> : left;</span><br><span class="line">    right = <span class="keyword">typeof</span> right != <span class="string">'number'</span>? len - <span class="number">1</span> : right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        mid = partition(array,left,right)</span><br><span class="line">        quickSort(array,left,mid<span class="number">-1</span>)</span><br><span class="line">        quickSort(array,mid+<span class="number">1</span>,right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分区函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array,left,right</span>) </span>&#123;</span><br><span class="line">    temp = array[left]</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; array[right] &gt;= temp) &#123;</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[left] = array[right]</span><br><span class="line">         <span class="keyword">while</span> (left &lt; right &amp;&amp; array[left] &lt;= temp) &#123;</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">         &#125;</span><br><span class="line">        array[right] = array[left]</span><br><span class="line">    &#125;</span><br><span class="line">    array[left] = temp</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(list))</span><br></pre></td></tr></table></figure>
<h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94%E8%A1%A8.png" alt="数组和链表区别对比表"></p>
<h2 id="强制缓存和协商缓存的区别"><a href="#强制缓存和协商缓存的区别" class="headerlink" title="强制缓存和协商缓存的区别"></a>强制缓存和协商缓存的区别</h2><p>很棒的总结： <a href="https://segmentfault.com/a/1190000016199807" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016199807</a></p>
<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>参考博客： <a href="https://www.cnblogs.com/zgq0/p/8780893.html" target="_blank" rel="noopener">https://www.cnblogs.com/zgq0/p/8780893.html</a></p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>（这题给出了一个ul标签和三个li标签，每个li标签各有一个id名，js部分通过for循环给每个li标签添加了一个click事件。问以下代码还有什么可以优化的地方？）<br>原题代码：</p>
<p>HTML部分：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'menu'</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">'list1'</span>&gt;</span>list1 was clicked<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">'list2'</span>&gt;</span>list2 was clicked<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">'list3'</span>&gt;</span>list3 was clicked<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JS部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">	list[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>懂得人一眼就看出这题考察的是什么知识点。我们知道每添加一个事件，就会耗费一部分内存，所以事件越少性能越高。<br><strong>事件委托就是利用事件冒泡的原理，委托子元素的父元素去代理执行事件，所以，上述方式是添加了三个事件，而通过事件委托可只需要添加一个点击事件即可实现相同的功能。</strong><br>修改之后的JS代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> menu = <span class="built_in">document</span>.getElementById(<span class="string">'menu'</span>);</span><br><span class="line">menu.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// console.log(e.target.id + ' was clicked')</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端面经</category>
      </categories>
      <tags>
        <tag>前端面经</tag>
      </tags>
  </entry>
  <entry>
    <title>散列(哈希表)</title>
    <url>/blog/2020/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97/</url>
    <content><![CDATA[<p>散列是一种常用的数据存储技术， 散列后的数据可以快速地插入或取用。 散列使用的数据结构叫做散列表。 在散列表上插入、 删除和取用数据都非常快， 但是对于查找操作来说却效率低下， 比如查找一组数据中的最大值和最小值。 这些操作得求助于其他数据结构， 二叉查找树就是一个很好的选择。 本章将介绍如何实现散列表， 并且了解什么时候应该用散列表存取数据。</p>
<h2 id="散列概览"><a href="#散列概览" class="headerlink" title="散列概览"></a>散列概览</h2><p>散列表是基于数组设计的，数组的长度是预先设定的。如有需要，可以随时增加。所有元素根据该元素对应的键保存在数组的特定位置。使用散列表存储数据时，通过一个散列函数将键映射为一个数字，这个数字的范围是0到散列表的长度。</p>
<h2 id="HashTable类"><a href="#HashTable类" class="headerlink" title="HashTable类"></a>HashTable类</h2><p>使用一个类来包含散列表，该类包含计算散列值的方法、向散列中插入数据的方法、从散列表中读取数据的方法、显示散列表中数据分布的方法，以及一些其他的可能会用到的工具方法。<br>HashTable类的构造函数如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">137</span>);</span><br><span class="line">  <span class="keyword">this</span>.simpleHash = simpleHash;</span><br><span class="line">  <span class="keyword">this</span>.showDistro = showDistro;</span><br><span class="line">  <span class="keyword">this</span>.put = put;</span><br><span class="line">  <span class="comment">// this.get = get;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择一个散列函数"><a href="#选择一个散列函数" class="headerlink" title="选择一个散列函数"></a>选择一个散列函数</h3><p>散列函数的选择依赖于键值的数据类型。如果键是整型，最简单的散列函数就是以数组的长度对键取余。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleHash</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;data.length;i++) &#123;</span><br><span class="line">    total += data.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total % <span class="keyword">this</span>.table.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将数据存入散列表"><a href="#将数据存入散列表" class="headerlink" title="将数据存入散列表"></a>将数据存入散列表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pos = <span class="keyword">this</span>.simpleHash(data);</span><br><span class="line">  <span class="keyword">this</span>.table[pos] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显示散列表中的数据"><a href="#显示散列表中的数据" class="headerlink" title="显示散列表中的数据"></a>显示散列表中的数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDistro</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.table.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.table[i] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i + <span class="string">": "</span> + <span class="keyword">this</span>.table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取存储在散列表中的数据"><a href="#读取存储在散列表中的数据" class="headerlink" title="读取存储在散列表中的数据"></a>读取存储在散列表中的数据</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.table[<span class="keyword">this</span>.betterHash(key)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="散列表示例"><a href="#散列表示例" class="headerlink" title="散列表示例"></a>散列表示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">137</span>);</span><br><span class="line">  <span class="keyword">this</span>.simpleHash = simpleHash;</span><br><span class="line">  <span class="keyword">this</span>.showDistro = showDistro;</span><br><span class="line">  <span class="keyword">this</span>.put = put;</span><br><span class="line">  <span class="comment">// this.get = get;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleHash</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;data.length;i++) &#123;</span><br><span class="line">    total += data.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total % <span class="keyword">this</span>.table.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pos = <span class="keyword">this</span>.simpleHash(data);</span><br><span class="line">  <span class="keyword">this</span>.table[pos] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDistro</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.table.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.table[i] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i + <span class="string">": "</span> + <span class="keyword">this</span>.table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someNames = [<span class="string">"David"</span>, <span class="string">"Jennifer"</span>, <span class="string">"Donnie"</span>, <span class="string">"Raymond"</span>,<span class="string">"Cynthia"</span>, <span class="string">"Mike"</span>, <span class="string">"Clayton"</span>, <span class="string">"Danny"</span>, <span class="string">"Jonathan"</span>];</span><br><span class="line"><span class="keyword">var</span> hTable = <span class="keyword">new</span> HashTable();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; someNames.length; ++i) &#123;</span><br><span class="line">  hTable.put(someNames[i]);</span><br><span class="line">&#125;</span><br><span class="line">hTable.showDistro();</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">35</span>: Cynthia</span><br><span class="line"><span class="number">45</span>: Clayton</span><br><span class="line"><span class="number">57</span>: Donnie</span><br><span class="line"><span class="number">77</span>: David</span><br><span class="line"><span class="number">95</span>: Danny</span><br><span class="line"><span class="number">116</span>: Mike</span><br><span class="line"><span class="number">132</span>: Jennifer</span><br><span class="line"><span class="number">134</span>: Jonathan</span><br></pre></td></tr></table></figure>
<p><strong>注意：你会发现， 数据并不是均匀分布的， 人名向数组的两端集中。比起这种不均匀的分布， 还有一个更严重的问题。 如果你仔细观察输出， 会发现初始数组中的人名并没有全部显示。</strong></p>
<h3 id="一个更好的散列函数"><a href="#一个更好的散列函数" class="headerlink" title="一个更好的散列函数"></a>一个更好的散列函数</h3><p>为了避免碰撞， 在给散列表一个合适的大小后， 接下来要有一个计算散列值的更好方法。霍纳算法很好地解决了这个问题。 </p>
<h3 id="拥有更好散列函数-betterHash-的-HashTable-类"><a href="#拥有更好散列函数-betterHash-的-HashTable-类" class="headerlink" title="拥有更好散列函数 betterHash() 的 HashTable 类"></a>拥有更好散列函数 betterHash() 的 HashTable 类</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HashTable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.table = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">137</span>);</span><br><span class="line">  <span class="keyword">this</span>.simpleHash = simpleHash;</span><br><span class="line">  <span class="keyword">this</span>.betterHash = betterHash;</span><br><span class="line">  <span class="keyword">this</span>.showDistro = showDistro;</span><br><span class="line">  <span class="keyword">this</span>.put = put;</span><br><span class="line">  <span class="comment">//this.get = get;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> pos = <span class="keyword">this</span>.betterHash(data);<span class="number">92</span> ｜ 第 <span class="number">8</span> 章</span><br><span class="line"><span class="keyword">this</span>.table[pos] = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleHash</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; ++i) &#123;</span><br><span class="line">    total += data.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hash value: "</span> + data + <span class="string">" -&gt; "</span> + total);</span><br><span class="line">  <span class="keyword">return</span> total % <span class="keyword">this</span>.table.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDistro</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.table.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.table[i] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i + <span class="string">": "</span> + <span class="keyword">this</span>.table[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.table[<span class="keyword">this</span>.betterHash(key)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">betterHash</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> H = <span class="number">37</span>;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; string.length; ++i) &#123;</span><br><span class="line">    total += H * total + string.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  total = total % <span class="keyword">this</span>.table.length;</span><br><span class="line">  <span class="keyword">if</span> (total &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    total += <span class="keyword">this</span>.table.length<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someNames = [<span class="string">"David"</span>, <span class="string">"Jennifer"</span>, <span class="string">"Donnie"</span>, <span class="string">"Raymond"</span>,<span class="string">"Cynthia"</span>, <span class="string">"Mike"</span>, <span class="string">"Clayton"</span>, <span class="string">"Danny"</span>, <span class="string">"Jonathan"</span>];</span><br><span class="line"><span class="keyword">var</span> hTable = <span class="keyword">new</span> HashTable();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; someNames.length; ++i) &#123;</span><br><span class="line">    hTable.put(someNames[i]);</span><br><span class="line">&#125;</span><br><span class="line">htable.showDistro();</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">17</span>: Cynthia</span><br><span class="line"><span class="number">25</span>: Donnie</span><br><span class="line"><span class="number">30</span>: Mike</span><br><span class="line"><span class="number">33</span>: Jennifer</span><br><span class="line"><span class="number">37</span>: Jonathan</span><br><span class="line"><span class="number">57</span>: Clayton</span><br><span class="line"><span class="number">65</span>: David</span><br><span class="line"><span class="number">66</span>: Danny</span><br><span class="line"><span class="number">99</span>: Raymon</span><br></pre></td></tr></table></figure>
<p>这次所有的人名都显示出来了， 而且没有碰撞。</p>
]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>查找与排序</title>
    <url>/blog/2020/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="二分查找方法"><a href="#二分查找方法" class="headerlink" title="二分查找方法"></a>二分查找方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">方法一</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearch</span>(<span class="params">arr,item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> left = <span class="number">0</span>,</span><br><span class="line">      right = arr.length<span class="number">-1</span></span><br><span class="line">  <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">      <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">if</span>(arr[mid] == item)&#123;</span><br><span class="line">          <span class="keyword">return</span> mid</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;item)&#123;</span><br><span class="line">          right = mid<span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">          left = mid+<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BinarySearch</span>(<span class="params">arr,item,start,end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mid = <span class="built_in">Math</span>.floor((start+end)/<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span>(item === arr[mid])&#123;</span><br><span class="line">      <span class="keyword">return</span> mid</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(item&lt;arr[mid])&#123;</span><br><span class="line">      <span class="keyword">return</span> BinarySearch(arr,item,start,mid<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> BinarySearch(arr,item,mid+<span class="number">1</span>,end)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> len = array.length</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;len-i<span class="number">-1</span>;j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>]) &#123;</span><br><span class="line">        [array[j],array[j+<span class="number">1</span>]] = [array[j+<span class="number">1</span>],array[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> array</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = bubbleSort(list)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//桶排序</span></span><br><span class="line"><span class="comment">/*实现步骤（从小到大排序）：</span></span><br><span class="line"><span class="comment">假设元素列中的元素均处于 [0,1） 区间内。</span></span><br><span class="line"><span class="comment">准备一个长度为 10 的数组 temp。</span></span><br><span class="line"><span class="comment">假设元素的值为 x，则将它放入 temp 数组索引为 ⌊10x⌋ 的位置。</span></span><br><span class="line"><span class="comment">对数组 temp 下的每个“桶”进行排序，然后将排序后的“桶”拼接在一起。</span></span><br><span class="line"><span class="comment">时间复杂度：需要考虑每个桶内排序所消耗的时间</span></span><br><span class="line"><span class="comment">空间复杂度：O(n+k)</span></span><br><span class="line"><span class="comment">稳定性：稳定*/</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">0.78</span>, <span class="number">0.17</span>, <span class="number">0.39</span>, <span class="number">0.26</span>, <span class="number">0.72</span>, <span class="number">0.94</span>, <span class="number">0.21</span>, <span class="number">0.12</span>, <span class="number">0.23</span>, <span class="number">0.68</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>), () =&gt; []);</span><br><span class="line"></span><br><span class="line">    array.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="built_in">Math</span>.floor(item * <span class="number">10</span>);</span><br><span class="line">        temp[index].push(item);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    temp = temp.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            insertionSort(item)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [].concat(...temp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = array.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> unsortValue = array[i]</span><br><span class="line">        <span class="keyword">let</span> currentIndex = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ((currentIndex &gt;= <span class="number">0</span>) &amp;&amp; (array[currentIndex] &gt; unsortValue)) &#123;</span><br><span class="line">            array[currentIndex + <span class="number">1</span>] = array[currentIndex]</span><br><span class="line">            currentIndex--</span><br><span class="line">        &#125;</span><br><span class="line">        array[currentIndex + <span class="number">1</span>] = unsortValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bucketSort(list))       <span class="comment">// [ 0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94 ]</span></span><br></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> temp = []</span><br><span class="line">   array.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(temp[item]) &#123;</span><br><span class="line">         temp[item] = temp[item] + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         temp[item] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">let</span> res = []</span><br><span class="line">   <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">      <span class="keyword">while</span>(temp[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         res[index++] = i</span><br><span class="line">         temp[i] --</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;temp.length;j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = <span class="keyword">typeof</span> temp[j] === <span class="string">'number'</span> ? temp[j] :<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(j===<span class="number">0</span>) &#123;</span><br><span class="line">         temp[j] = cur</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         temp[j] = temp[j<span class="number">-1</span>] + cur</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(temp)</span><br><span class="line">&#125;</span><br><span class="line">countSort(list)</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = []</span><br><span class="line">  array.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(temp[item]) &#123;</span><br><span class="line">        temp[item] = temp[item] + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp[item] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(temp[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res[index++] = i</span><br><span class="line">        temp[i] --</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;temp.length;j++) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="keyword">typeof</span> temp[j] === <span class="string">'number'</span> ? temp[j] :<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(j===<span class="number">0</span>) &#123;</span><br><span class="line">        temp[j] = cur</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp[j] = temp[j<span class="number">-1</span>] + cur</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(temp)</span><br><span class="line">&#125;</span><br><span class="line">countSort(list)</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = array.length</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;len;i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> unsortValue = array[i]</span><br><span class="line">    <span class="keyword">let</span> currentIndex = i<span class="number">-1</span></span><br><span class="line">  <span class="keyword">while</span>((currentIndex &gt;= <span class="number">0</span>) &amp;&amp; (array[currentIndex] &gt; unsortValue)) &#123;</span><br><span class="line">        array[currentIndex + <span class="number">1</span>] = array[currentIndex]</span><br><span class="line">        currentIndex --</span><br><span class="line">    &#125;</span><br><span class="line">    array[currentIndex + <span class="number">1</span>] = unsortValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = insertSort(list)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现步骤（从小到大排序）：</span></span><br><span class="line"><span class="comment">不断地将元素列分成两个部分，然后对这两个部分递归执行归并排序。</span></span><br><span class="line"><span class="comment">当元素列只有1个元素时，停止递归。</span></span><br><span class="line"><span class="comment">对于被划分的两个部分，需要按照顺序将它们合并为一个整体。</span></span><br><span class="line"><span class="comment">最坏时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">平均时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">最好时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">空间复杂度：O(n)</span></span><br><span class="line"><span class="comment">稳定性：稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = array.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">      left = array.slice(<span class="number">0</span>, middle),</span><br><span class="line">      right = array.slice(middle)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((left.length &gt; <span class="number">0</span>) &amp;&amp; (right.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">          result.push(left.shift())</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result.push(right.shift())</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">      result.push(left.shift())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = mergeSort(list)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现步骤（从小到大排序）：</span></span><br><span class="line"><span class="comment">通过三数中值分割法，从元素列中选出最左侧，中间和最右侧的三个元素，并排序。</span></span><br><span class="line"><span class="comment">从步骤1中排序后的三个元素中选择中间元素作为枢纽元素，并交换枢纽元素和元素列倒数第二个元素的位置。</span></span><br><span class="line"><span class="comment">选择i = left + 1, j = right - 2。</span></span><br><span class="line"><span class="comment">不断执行i++操作，直到i所处元素大于等于枢纽元素为止。</span></span><br><span class="line"><span class="comment">不断执行j--操作，直到j所处元素小于等于枢纽元素为止。</span></span><br><span class="line"><span class="comment">如果i &lt; j，那么交换这两个位置上的元素，然后重复执行步骤4、5。</span></span><br><span class="line"><span class="comment">如果i &gt;= j，那么此刻位置i上的元素一定是大于等于枢纽元素的，此时交换位置i上的元素和枢纽元素的位置。交换之后，枢纽元素左侧的元素均小于等于它，而它右侧的元素均大于等于它。</span></span><br><span class="line"><span class="comment">不断对被枢纽元素分割开来的两个子元素列执行步骤1至步骤7，直到排序完成。</span></span><br><span class="line"><span class="comment">最坏时间复杂度：O(n2)</span></span><br><span class="line"><span class="comment">平均时间复杂度：O(nlgn)</span></span><br><span class="line"><span class="comment">最好时间复杂度：O(nlgn)</span></span><br><span class="line"><span class="comment">空间复杂度：O(lgn) 至 O(n) 之间</span></span><br><span class="line"><span class="comment">稳定性：不稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array,left,right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//待排序的区域至少有两个元素</span></span><br><span class="line">    <span class="keyword">let</span> len = array.length</span><br><span class="line">    left = <span class="keyword">typeof</span> left != <span class="string">'number'</span>? <span class="number">0</span> : left;</span><br><span class="line">    right = <span class="keyword">typeof</span> right != <span class="string">'number'</span>? len - <span class="number">1</span> : right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        mid = partition(array,left,right)</span><br><span class="line">        quickSort(array,left,mid<span class="number">-1</span>)</span><br><span class="line">        quickSort(array,mid+<span class="number">1</span>,right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分区操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>&#123;     <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="keyword">let</span> pivot = left,                      <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = quickSort(list)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array,left,right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = array.length</span><br><span class="line">    left = <span class="keyword">typeof</span> left != <span class="string">'number'</span>? <span class="number">0</span> : left;</span><br><span class="line">    right = <span class="keyword">typeof</span> right != <span class="string">'number'</span>? len - <span class="number">1</span> : right;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        mid = partition(array,left,right)</span><br><span class="line">        quickSort(array,left,mid<span class="number">-1</span>)</span><br><span class="line">        quickSort(array,mid+<span class="number">1</span>,right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分区函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">array,left,right</span>) </span>&#123;</span><br><span class="line">    temp = array[left]</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; array[right] &gt;= temp) &#123;</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[left] = array[right]</span><br><span class="line">         <span class="keyword">while</span> (left &lt; right &amp;&amp; array[left] &lt;= temp) &#123;</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">         &#125;</span><br><span class="line">        array[right] = array[left]</span><br><span class="line">    &#125;</span><br><span class="line">    array[left] = temp</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(list))</span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序</span></span><br><span class="line"><span class="comment">/*多关键字排序：先按照低要求排序，再到最高要求排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*实现步骤（从小到大排序）：</span></span><br><span class="line"><span class="comment">从最低有效位开始，依次根据当前位的关键字对元素列使用稳定排序算法进行排序。</span></span><br><span class="line"><span class="comment">时间复杂度：</span></span><br><span class="line"><span class="comment">给定 n 个 d 位数，其中每一个数位有 k 个可能的取值。如果使用的稳定排序方法耗时 Θ(n+k)，那么它就可以在 Θ(d(n+k)) 时间内将这些数排好序。</span></span><br><span class="line"><span class="comment">给定一个 b 位数和任何正整数 r≤b，如果使用稳定排序算法对数据取值区间为 [0,k] 的输入进行排序耗时 Θ(n+k)，那么它就可以在 Θ((b/r)(n+2r)) 时间内将这些数排好序。</span></span><br><span class="line"><span class="comment">空间复杂度：由过程中使用的稳定排序算法决定</span></span><br><span class="line"><span class="comment">稳定性：稳定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">329</span>, <span class="number">457</span>, <span class="number">657</span>, <span class="number">839</span>, <span class="number">436</span>, <span class="number">720</span>, <span class="number">355</span>, <span class="number">11</span>, <span class="number">20</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span> (<span class="params">array, d</span>) </span>&#123;</span><br><span class="line">    array = array.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="built_in">String</span>(item),</span><br><span class="line">            len = str.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0'</span>.repeat(d - len) + str</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = d - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = [];</span><br><span class="line"></span><br><span class="line">        array.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> temp[item[i]] === <span class="string">'number'</span>) &#123;</span><br><span class="line">                temp[item[i]] = temp[item[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[item[i]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// console.log(temp)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; temp.length; j++) &#123;</span><br><span class="line">            <span class="keyword">let</span> cur = <span class="keyword">typeof</span> temp[j] === <span class="string">'number'</span> ? temp[j] : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (j === <span class="number">0</span>) &#123;</span><br><span class="line">                temp[j] = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[j] = cur + temp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// console.log(temp)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = array.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">let</span> value = array[j],</span><br><span class="line">                singleValue = array[j][i];</span><br><span class="line">            res[temp[singleValue] - <span class="number">1</span>] = value;</span><br><span class="line">            temp[singleValue] = temp[singleValue] - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(res)</span><br><span class="line">        &#125;</span><br><span class="line">        array = res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseInt</span>(item))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">radixSort(list, <span class="number">3</span>);        <span class="comment">// [ 4, 11, 20, 329, 355, 436, 457, 657, 720, 839 ]</span></span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = array.length</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> minIndex = i</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;len; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = array[j]</span><br><span class="line">      array[j] = array[minIndex]</span><br><span class="line">      array[minIndex] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = selectSort(list)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序：第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">84</span>, <span class="number">83</span>, <span class="number">88</span>, <span class="number">87</span>, <span class="number">61</span>, <span class="number">50</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">80</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = array.length</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> gap=<span class="built_in">Math</span>.floor(len/<span class="number">2</span>); gap&gt;<span class="number">0</span>; gap=<span class="built_in">Math</span>.floor(gap/<span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="comment">//内部是插入排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=gap; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> unsortValue = array[i]</span><br><span class="line">        <span class="keyword">let</span> currentIndex = i-gap</span><br><span class="line">        <span class="keyword">while</span>((currentIndex &gt;= <span class="number">0</span>) &amp;&amp; (array[currentIndex] &gt; unsortValue)) &#123;</span><br><span class="line">          array[currentIndex + gap] = array[currentIndex]</span><br><span class="line">          currentIndex = currentIndex - gap</span><br><span class="line">        &#125;</span><br><span class="line">        array[currentIndex + gap] = unsortValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = shellSort(list)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>列表</title>
    <url>/blog/2020/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="列表的抽象数据类型"><a href="#列表的抽象数据类型" class="headerlink" title="列表的抽象数据类型"></a>列表的抽象数据类型</h2><p>列表是一组有序的数据，每个列表中的数据项称为元素，在JavaScript中，列表中的元素可以是任意数据类型，列表中可以保存多少元素没有事先限定，实际使用时元素的数量受到程序内存的限制。</p>
<p>列表的抽象数据类型定义如下所示：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>listSize(属性)</td>
<td>列表的元素个数</td>
</tr>
<tr>
<td>pos(属性)</td>
<td>列表的当前位置</td>
</tr>
<tr>
<td>length(属性)</td>
<td>返回列表中元素的个数</td>
</tr>
<tr>
<td>clear(方法)</td>
<td>清空列表中的所有元素</td>
</tr>
<tr>
<td>toString(方法)</td>
<td>返回列表的字符串形式</td>
</tr>
<tr>
<td>getElement(方法)</td>
<td>返回当前位置的元素</td>
</tr>
<tr>
<td>insert(方法)</td>
<td>在现有元素后插入新元素</td>
</tr>
<tr>
<td>append(方法)</td>
<td>在列表的末尾添加新元素</td>
</tr>
<tr>
<td>remove(方法)</td>
<td>从列表中删除元素</td>
</tr>
<tr>
<td>front(方法)</td>
<td>将列表的当前位置移动到第一个元素</td>
</tr>
<tr>
<td>end(方法)</td>
<td>将列表的当前位置移动到最后一个元素</td>
</tr>
<tr>
<td>prev(方法)</td>
<td>将当前位置前移一位</td>
</tr>
<tr>
<td>next(方法)</td>
<td>将当前位置后移一位</td>
</tr>
<tr>
<td>currPos(方法)</td>
<td>返回列表的当前位置</td>
</tr>
<tr>
<td>moveTo(方法)</td>
<td>将当前位置移动到指定位置</td>
</tr>
</tbody></table>
<h2 id="实现列表类"><a href="#实现列表类" class="headerlink" title="实现列表类"></a>实现列表类</h2><p>定义一个List类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">    this.dataStore = []; # 初始化一个空数组来保存列表元素</span><br><span class="line">    <span class="keyword">this</span>.clear = clear;</span><br><span class="line">    <span class="keyword">this</span>.find = find;</span><br><span class="line">    <span class="keyword">this</span>.toString = toString;</span><br><span class="line">    <span class="keyword">this</span>.insert = insert;</span><br><span class="line">    <span class="keyword">this</span>.append = append;</span><br><span class="line">    <span class="keyword">this</span>.remove = remove;</span><br><span class="line">    <span class="keyword">this</span>.front = front;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.currPos = currPos;</span><br><span class="line">    <span class="keyword">this</span>.moveTo = moveTo;</span><br><span class="line">    <span class="keyword">this</span>.getElement = getElement;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.contains = contains;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="append：给列表添加元素"><a href="#append：给列表添加元素" class="headerlink" title="append：给列表添加元素"></a>append：给列表添加元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore(<span class="keyword">this</span>.listSize++) = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="find-在列表中查找某一元素"><a href="#find-在列表中查找某一元素" class="headerlink" title="find: 在列表中查找某一元素"></a>find: 在列表中查找某一元素</h3><p>find()方法通过对数组对象dataStore进行迭代，查找给定的元素。如果找到就返回该元素在列表中的位置，否则返回-1。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i] == element) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove：-从列表中删除元素"><a href="#remove：-从列表中删除元素" class="headerlink" title="remove： 从列表中删除元素"></a>remove： 从列表中删除元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.find(element) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.splice(<span class="keyword">this</span>.find(element), <span class="number">1</span>);</span><br><span class="line">        --<span class="keyword">this</span>.listSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="length-列表中有多少个元素"><a href="#length-列表中有多少个元素" class="headerlink" title="length: 列表中有多少个元素"></a>length: 列表中有多少个元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.listSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString-显示列表中的元素"><a href="#toString-显示列表中的元素" class="headerlink" title="toString: 显示列表中的元素"></a>toString: 显示列表中的元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toString</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是一个数组，不是字符串。</p>
<h3 id="insert-向列表中插入一个元素-假设插入是指插入到某个元素之后"><a href="#insert-向列表中插入一个元素-假设插入是指插入到某个元素之后" class="headerlink" title="insert: 向列表中插入一个元素(假设插入是指插入到某个元素之后)"></a>insert: 向列表中插入一个元素(假设插入是指插入到某个元素之后)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">element,after</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> insertPos = <span class="keyword">this</span>.find(after);</span><br><span class="line">    <span class="keyword">if</span> (insertPos &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dataStore.splice(insertPos+<span class="number">1</span>, <span class="number">0</span>, element)</span><br><span class="line">        ++listSize;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clear-清空列表中的所有元素"><a href="#clear-清空列表中的所有元素" class="headerlink" title="clear: 清空列表中的所有元素"></a>clear: 清空列表中的所有元素</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.dataStore;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.listSize = <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="contains-判断给定值是否在列表中"><a href="#contains-判断给定值是否在列表中" class="headerlink" title="contains: 判断给定值是否在列表中"></a>contains: 判断给定值是否在列表中</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.dataStore[i] == element) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h3><ul>
<li>front: 将列表的当前位置移动到第一个元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">front</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>end: 将列表的当前位置移动到最后一个元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = <span class="keyword">this</span>.listSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>prev: 将当前位置前移一位</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prev</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        --<span class="keyword">this</span>.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>next: 将当前位置后移一位</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.pos &lt; (<span class="keyword">this</span>.listSize<span class="number">-1</span>)) &#123;</span><br><span class="line">        ++<span class="keyword">this</span>.pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>currPos: 返回列表的当前位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currPos</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>moveTo: 将当前位置移动到指定位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveTo</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pos = position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getElement: 返回列表的当前位置的元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElement</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.pos];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用迭代器访问列表"><a href="#使用迭代器访问列表" class="headerlink" title="使用迭代器访问列表"></a>使用迭代器访问列表</h2><p>使用迭代器，可以不用关心数据的内部存储方式，以实现对列表的遍历。使用迭代器的优点如下：</p>
<ul>
<li>访问列表元素时不必关心底层的数据存储结构</li>
<li>当为列表添加一个元素时，索引的值就不对了，此时只用更新列表，不用更新迭代器。</li>
<li>可以用不同类型的数据存储方式实现 cList 类，迭代器为访问列表里的元素提供了一种统一的方式。</li>
</ul>
<p>使用迭代器遍历列表的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (names.front(); names.currPos() &lt; names.length; names.next()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(names.getElement());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在for 循环的一开始，将列表的当前位置设置为第一个元素。只要currPos 的值小于列表的长度，就一直循环，每一次循环都调用next() 方法将当前位置向前移动一位。</p>
]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>字典</title>
    <url>/blog/2020/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<p>字典是一个以键-值对形式存储数据的数据结构，就像电话号码簿里的名字和电话号码一样，要找一个电话时，先找名字，名字找到了，紧接着它的电话号码就找到了。这里的键是你用来查找的东西，值是你的查找得到的结果。</p>
<h2 id="Dictionary类"><a href="#Dictionary类" class="headerlink" title="Dictionary类"></a>Dictionary类</h2><p>Dictionay 类的基础是 <code>Array</code> 类， 而不是<code>Object</code> 类。以下面的代码开始定义 <code>Dictionary</code> 类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.datastore = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义add()方法，该方法接受两个参数：键和值。键是值在字典中的索引。代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">key,value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.datastore[key] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义find()方法，该方法接受以键作为参数，返回和其关联的值。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义showAll()方法，显示字典中的所有的键-值对，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showALL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//必须为for of, for in 得到的是数字0，1,... (亲测)</span></span><br><span class="line">  <span class="comment">//for in是ES5标准，遍历key. for of是ES6标准，遍历value.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">"-&gt;"</span> + <span class="keyword">this</span>.datastore[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dictionary类调用代码示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dictionary</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.add = add;</span><br><span class="line">    <span class="keyword">this</span>.datastore = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">this</span>.find = find;</span><br><span class="line">    <span class="keyword">this</span>.remove = remove;</span><br><span class="line">    <span class="keyword">this</span>.showAll = showAll;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.datastore[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//必须为for of, for in 得到的是数字0，1,...</span></span><br><span class="line">      <span class="comment">//for in是ES5标准，遍历key. for of是ES6标准，遍历value.</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key)</span><br><span class="line">        <span class="built_in">console</span>.log(key + <span class="string">" -&gt; "</span> + <span class="keyword">this</span>.datastore[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pbook = <span class="keyword">new</span> Dictionary();</span><br><span class="line">  pbook.add(<span class="string">"Mike"</span>,<span class="string">"123"</span>);</span><br><span class="line">  pbook.add(<span class="string">"David"</span>, <span class="string">"345"</span>);</span><br><span class="line">  pbook.add(<span class="string">"Cynthia"</span>, <span class="string">"456"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"David's extension: "</span> + pbook.find(<span class="string">"David"</span>));</span><br><span class="line">  pbook.remove(<span class="string">"David"</span>);</span><br><span class="line">  pbook.showAll();</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">David<span class="string">'s extension: 345</span></span><br><span class="line"><span class="string">Mike -&gt; 123</span></span><br><span class="line"><span class="string">Cynthia -&gt; 456</span></span><br></pre></td></tr></table></figure>
<h2 id="Dictionary类的辅助方法"><a href="#Dictionary类的辅助方法" class="headerlink" title="Dictionary类的辅助方法"></a>Dictionary类的辅助方法</h2><p>定义count()方法，计算字典中的元素个数。**不能使用length方法，因为当键的类型为字符串时，length属性就不管用了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore)) &#123;</span><br><span class="line">    ++n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义全部删除方法，clear()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore)) &#123;</span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">this</span>.datastore[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为Dictionary类添加排序功能"><a href="#为Dictionary类添加排序功能" class="headerlink" title="为Dictionary类添加排序功能"></a>为Dictionary类添加排序功能</h2><p>字典的主要用途是通过键取值， 我们无须太关心数据在字典中的实际存储顺序。 然而， 很多人都希望看到一个有序的字典。 下面来看看怎样让前面实现的字典按顺序显示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.datastore).sort()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">"-&gt;"</span> + <span class="keyword">this</span>.datastore[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>该定义和之前的定义唯一的区别是： 从数组 datastore 拿到键后， 调用 sort() 方法对键重新排了序。</strong></p>
]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组、对象数组</title>
    <url>/blog/2020/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="JavaScripta中对数组的定义"><a href="#JavaScripta中对数组的定义" class="headerlink" title="JavaScripta中对数组的定义"></a>JavaScripta中对数组的定义</h2><p>JavaScript 中的数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可能是整数。然而，这些数字索引在内部被转换为字符串类型，这是因为JavaScript 对象中<br>的属性名必须是字符串。数组在JavaScript 中只是一种特殊的对象，所以效率上不如其他语言中的数组高。<br>JavaScript 中的数组，严格来说应该称作对象，是特殊的JavaScript 对象，在内部被归类为数组。由于Array 在JavaScript 中被当作对象，因此它有许多属性和方法可以在编程时使用。</p>
<p><strong>数组的基本使用方法以及迭代器方法等在这里就不介绍了，参照博客的JavaScript高级程序设计中的引用类型，这里介绍一些关于二维数组以及对象数组等知识。</strong></p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="处理二维数组的元素"><a href="#处理二维数组的元素" class="headerlink" title="处理二维数组的元素"></a>处理二维数组的元素</h3><p>处理二维数组中的元素，有两种最基本的方式：按列访问和按行访问。对于这两种方式，均采用一组嵌入式的for循环，对于按列访问，外层循环对应行，内层循环对应列。示例如下：数组grades的每一行对应一个学生的成绩记录，我们可以将该学生的所有成绩相加，然后除以科目数得到该学生的平均成绩。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> grades = [[<span class="number">89</span>,<span class="number">77</span>,<span class="number">78</span>], [<span class="number">76</span>,<span class="number">82</span>,<span class="number">81</span>], [<span class="number">91</span>,<span class="number">94</span>,<span class="number">89</span>]];</span><br><span class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> average = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; grades.length; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; grades[row].length; col++) &#123;</span><br><span class="line">        total += grades[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">    average = total/grades[row].length;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"studuent"</span> + <span class="built_in">parseInt</span>(row+<span class="number">1</span>)+ <span class="string">"average:"</span> + average.toFixed(<span class="number">2</span>));</span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line">    average = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">studuent <span class="number">1</span> average: <span class="number">81.33</span></span><br><span class="line">studuent <span class="number">2</span> average: <span class="number">79.67</span></span><br><span class="line">studuent <span class="number">3</span> average: <span class="number">91.33</span></span><br></pre></td></tr></table></figure>

<p><strong>对于按列访问，只需稍微调整for循环的顺序，使外层循环对应列，内层循环对应行即可。</strong><br><strong>JavaScript在处理参差不齐的数组时表现良好，很多语言在处理这种参差不齐的数组时表现都不是很好</strong></p>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p><strong>数组不仅可以包含基本数据类型的元素，还可以包含对象，数组的方法对对象依然适用。</strong>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayPts</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; ++i) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(arr[i].x + <span class="string">", "</span> + arr[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> Point(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> points = [p1,p2,p3,p4];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length; ++i) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Point "</span> + <span class="built_in">parseInt</span>(i+<span class="number">1</span>) + <span class="string">": "</span> + points[i].x + <span class="string">", "</span> + points[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> Point(<span class="number">12</span>,<span class="number">-3</span>);</span><br><span class="line">points.push(p5);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"After push: "</span>);</span><br><span class="line">displayPts(points);</span><br><span class="line">points.shift();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"After shift: "</span>);</span><br><span class="line">displayPts(points);</span><br></pre></td></tr></table></figure>

<p>结果如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Point <span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">Point <span class="number">2</span>: <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">Point <span class="number">3</span>: <span class="number">2</span>, <span class="number">8</span></span><br><span class="line">Point <span class="number">4</span>: <span class="number">4</span>, <span class="number">4</span></span><br><span class="line">After push:</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="number">3</span>, <span class="number">5</span></span><br><span class="line"><span class="number">2</span>, <span class="number">8</span></span><br><span class="line"><span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="number">12</span>, <span class="number">-3</span></span><br><span class="line">After shift:</span><br><span class="line"><span class="number">3</span>, <span class="number">5</span></span><br><span class="line"><span class="number">2</span>, <span class="number">8</span></span><br><span class="line"><span class="number">4</span>, <span class="number">4</span></span><br><span class="line"><span class="number">12</span>, <span class="number">-3</span></span><br></pre></td></tr></table></figure>

<h2 id="对象中的数组"><a href="#对象中的数组" class="headerlink" title="对象中的数组"></a>对象中的数组</h2><p>在对象中，可以使用数组存储复杂的数据，比如：我们创建了一个对象，用于保存观测到的周最高气温，该对象有两个方法，一个方法用来增加一条新的气温记录，另外一个方法用来计算存储在对象中的平均气温。代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">weekTemps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.add = add;</span><br><span class="line">    <span class="keyword">this</span>.average = average;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">temp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore.push(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.dataStore.length; ++i) &#123;</span><br><span class="line">    total += <span class="keyword">this</span>.dataStore[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total / <span class="keyword">this</span>.dataStore.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> thisWeek = <span class="keyword">new</span> weekTemps();</span><br><span class="line">thisWeek.add(<span class="number">52</span>);</span><br><span class="line">thisWeek.add(<span class="number">55</span>);</span><br><span class="line">thisWeek.add(<span class="number">61</span>);</span><br><span class="line">thisWeek.add(<span class="number">65</span>);</span><br><span class="line">thisWeek.add(<span class="number">55</span>);</span><br><span class="line">thisWeek.add(<span class="number">50</span>);</span><br><span class="line">thisWeek.add(<span class="number">52</span>);</span><br><span class="line">thisWeek.add(<span class="number">49</span>);</span><br><span class="line">console.log(thisWeek.average());  # 54.875</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树和二叉查找树</title>
    <url>/blog/2020/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<p>树是计算机科学中经常用到的一种数据结构，树是一种非线性的数据机构，以分层的方式存储数据。树被用来存储具有层级关系的数据，比如文件系统中的文件；树还被用来存储有序列表。</p>
<h2 id="二叉树和二叉查找树的关系"><a href="#二叉树和二叉查找树的关系" class="headerlink" title="二叉树和二叉查找树的关系"></a>二叉树和二叉查找树的关系</h2><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点，较大的值保存在右节点。</p>
<h2 id="实现二叉查找树"><a href="#实现二叉查找树" class="headerlink" title="实现二叉查找树"></a>实现二叉查找树</h2><p>二叉查找树由节点组成，所以我们第一个要定义的对象就是Node，该对象和链表的对象类似，Node类的定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data,left,right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = data;</span><br><span class="line">  <span class="keyword">this</span>.left = left;</span><br><span class="line">  <span class="keyword">this</span>.right = right;</span><br><span class="line">  <span class="keyword">this</span>.show = show;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node对象既保存数据，也保存和其他节点的链接（left和right），show()方法用来显示保存在节点中的数据。</p>
<div class="note info">
            <p>查找正确插入点的算法如下。</p><ol><li>设根节点为当前节点。</li><li>如果待插入节点保存的数据小于当前节点， 则设新的当前节点为原节点的左节点； 反之， 执行第 4 步。</li><li>如果当前节点的左节点为 null， 就将新的节点插入这个位置， 退出循环； 反之， 继续执行下一次循环。</li><li>设新的当前节点为原节点的右节点。</li><li>如果当前节点的右节点为 null， 就将新的节点插入这个位置， 退出循环； 反之， 继续执行下一次循环。</li></ol>
          </div>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data,left,right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = data;</span><br><span class="line">  <span class="keyword">this</span>.left = left;</span><br><span class="line">  <span class="keyword">this</span>.right = right;</span><br><span class="line">  <span class="keyword">this</span>.show = show;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BST</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.insert = insert;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="keyword">new</span> Node(data,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">    <span class="keyword">var</span> parent;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      parent = current;</span><br><span class="line">      <span class="keyword">if</span> (data &lt; current.data) &#123;</span><br><span class="line">        current = current.left;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">null</span>) &#123;</span><br><span class="line">          parent.left = n;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        current = current.right;</span><br><span class="line">        <span class="keyword">if</span>(current == <span class="literal">null</span>) &#123;</span><br><span class="line">          parent.right = n;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历二叉查找树"><a href="#遍历二叉查找树" class="headerlink" title="遍历二叉查找树"></a>遍历二叉查找树</h2><div class="note info">
            <p>三种遍历BST的方式：</p><ul><li>中序：中序遍历按照节点上的键值，以升序访问BST上的所有节点；</li><li>先序：先序遍历先访问根节点，然后以同样的方式访问左子树和右子树；</li><li>后序：后序遍历先访问叶子节点，从左子树到右子树，再到根节点。</li></ul>
          </div>

<p>中序遍历的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">    inOrder(node.left);</span><br><span class="line">    putstr(node.show()+<span class="string">" "</span>);</span><br><span class="line">    inOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序遍历的定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">    putstr(node.show() + <span class="string">" "</span>);</span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历的定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">    postOrder(node.left);</span><br><span class="line">    postOrder(node.right);</span><br><span class="line">    putstr(node.show() + <span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在二叉查找树上进行查找"><a href="#在二叉查找树上进行查找" class="headerlink" title="在二叉查找树上进行查找"></a>在二叉查找树上进行查找</h2><div class="note info">
            <p>对BST通常有下列三种类型的查找：</p><ol><li>查找最大值；</li><li>查找最小值；</li><li>查找给定值。</li></ol>
          </div>

<h3 id="查找最小值和最大值"><a href="#查找最小值和最大值" class="headerlink" title="查找最小值和最大值"></a>查找最小值和最大值</h3><p><strong>查找BST上的最小值和最大值非常简单。因为较小的值总是在左子节点上，在BST上查找最小值，只需要遍历左子树，直到找到最后一个节点。</strong></p>
<p>getMin()方法查找BST上的最小值，该方法的定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">  <span class="keyword">while</span>(!(current.left == <span class="literal">null</span>)) &#123;</span><br><span class="line">    current = current.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMax()方法查找BST上的最小值，该方法的定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">  <span class="keyword">while</span>(!(current.right == <span class="literal">null</span>)) &#123;</span><br><span class="line">    current = current.right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找给定值的代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current = <span class="keyword">this</span>.root;</span><br><span class="line">  <span class="keyword">while</span>(!(node == <span class="literal">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(current.data == data) &#123;</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(data &lt; current.data) &#123;</span><br><span class="line">      current = current.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      current = current.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从二叉查找树上删除节点"><a href="#从二叉查找树上删除节点" class="headerlink" title="从二叉查找树上删除节点"></a>从二叉查找树上删除节点</h3><p>从 BST 上删除节点的操作最复杂， 其复杂程度取决于删除哪个节点。 如果删除没有子节点的节点， 那么非常简单。 如果节点只有一个子节点， 不管是左子节点还是右子节点， 就变得稍微有点复杂了。 删除包含两个子节点的节点最复杂。为了管理删除操作的复杂度， 我们使用递归操作， 同时定义两个方法： <code>remove()</code> 和<code>removeNode()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  root = removeNode(<span class="keyword">this</span>.root,data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeNode</span>(<span class="params">node,data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data == node.data) &#123;</span><br><span class="line">    <span class="comment">//没有子节点的节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有左子节点的节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有右子节点的节点</span></span><br><span class="line">    <span class="keyword">if</span>(node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有两个子节点的节点</span></span><br><span class="line">    <span class="keyword">var</span> tempNode = node.right;</span><br><span class="line">    node.data = tempNode.data;</span><br><span class="line">    node.right = removeNode(node.right,tempNode.data);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(data&lt;node.data) &#123;</span><br><span class="line">    node.left = removeNode(node.left,data);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    node.right = removeNode(node.right,data);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h2><p>BST 的一个用途是记录一组数据集中数据出现的次数。 比如， 可以使用 BST 记录考试成绩的分布。 给定一组考试成绩， 可以写一段程序将它们加入一个 BST， 如果某成绩尚未在<br>BST 中出现， 就将其加入 BST； 如果已经出现， 就将出现的次数加 1。<br>为了解决该问题， 我们来修改 Node 对象， 为其增加一个记录成绩出现频次的成员， 同时我们还需要一个方法， 当在 BST 中发现某成绩时， 需要将出现的次数加 1， 并且更新该节点。<br>先修改 Node 对象的定义， 为其增加记录成绩出现次数的成员：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data,left,right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.data = data;</span><br><span class="line">  <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.left = left;</span><br><span class="line">  <span class="keyword">this</span>.right = right;</span><br><span class="line">  <span class="keyword">this</span>.show = show;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当向 BST 插入一条成绩（Node 对象） 时， 将出现频次设为 1。 此时 BST 的 <code>insert()</code> 方法还能正常工作， 但是， 当次数增加时， 我们就需要一个新方法来更新 BST 中的节点。 这个方法就是 <code>update()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> grade = <span class="keyword">this</span>.find(data);</span><br><span class="line">  grade.count++;</span><br><span class="line">  <span class="keyword">return</span> grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BST 类的其他方法不需要修改， 只需要再增加一些随机产生成绩及显示它们的函数。</p>
]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/blog/2020/04/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/</url>
    <content><![CDATA[<p>栈是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。</p>
<h2 id="对栈的操作"><a href="#对栈的操作" class="headerlink" title="对栈的操作"></a>对栈的操作</h2><p>栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。<strong>栈被称为一种后入先出的数据结构。</strong><br><strong>栈的两种操作：入栈 push() 方法，出栈 pop() 方法。</strong><br>另一个常用的操作是预览栈顶的元素。pop() 方法虽然可以访问栈顶的元素，但是调用该方法后，栈顶元素也从栈中被永久性地删除了。<strong>peek() 方法则只返回栈顶元素，而不删除它。</strong><br>其它属性与方法： clear() 方法清除栈内所有元素；length 属性记录栈内元素的个数；empty 属性表示栈内是否含有元素。</p>
<h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p>实现一个栈，当务之急是决定存储数据的底层数据结构。这里采用的是数组。<br>定义一个Stack类的构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.push = push;</span><br><span class="line">    <span class="keyword">this</span>.pop = pop;</span><br><span class="line">    <span class="keyword">this</span>.peek = peek;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="push-方法"><a href="#push-方法" class="headerlink" title="push()方法"></a>push()方法</h3><p>当向栈中压入一个新元素时，需要将其保存在数组中变量top所对应的位置，然后将top值加1，让其指向数组中下一个空位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top++] = element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pop-方法"><a href="#pop-方法" class="headerlink" title="pop()方法"></a>pop()方法</h3><p>出栈，与push()方法相反，返回栈顶元素，同时将变量top的值减1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[--<span class="keyword">this</span>.top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="peek-方法"><a href="#peek-方法" class="headerlink" title="peek()方法"></a>peek()方法</h3><p>返回栈顶元素（即第top-1个位置的元素）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h3><p>栈内存储了多少个元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h3><p>清空栈元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Stack类"><a href="#使用Stack类" class="headerlink" title="使用Stack类"></a>使用Stack类</h2><h3 id="栈结构面试题"><a href="#栈结构面试题" class="headerlink" title="栈结构面试题"></a>栈结构面试题</h3><p>有六个元素6，5，4，3，2，1，按照顺序进栈，下面哪一个不是合法的出栈序列？（C）<br>A 5 4 3 6 1 2  B 4 5 3 2 1 6  C 3 4 6 5 2 1   D 2 3 4 1 56</p>
<h3 id="数制间的相互转换"><a href="#数制间的相互转换" class="headerlink" title="数制间的相互转换"></a>数制间的相互转换</h3><p>可以利用栈将一个数字从一种数制转换为另一种数制。假设想将数字n转换为以b为基数的数字，实现转换的算法如下：</p>
<div class="note info">
            <p>(1) 最高位为n%b，将此位压入栈。<br>(2) 使用n/b代替n。<br>(3) 重复步骤1和2， 直到n等于0，且没有余数。<br>(4) 持续将栈内元素弹出，直到栈为空，依次将这些元素排列，就得到转换后数字的字符串形式。</p>
          </div>
<p><strong>注意：此算法只针对基数为2~9的情况。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.push = push;</span><br><span class="line">    <span class="keyword">this</span>.pop = pop;</span><br><span class="line">    <span class="keyword">this</span>.peek = peek;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top++] = element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[--<span class="keyword">this</span>.top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mulBase</span>(<span class="params">num,base</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        s.push(num % base);</span><br><span class="line">        num = <span class="built_in">Math</span>.floor(num/base);</span><br><span class="line">    &#125; <span class="keyword">while</span> (num &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> converted = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        converted += s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> converted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">var</span> base = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> newNum = mulBase(num,base);</span><br><span class="line"><span class="built_in">console</span>.log(newNum);   <span class="comment">//1000</span></span><br></pre></td></tr></table></figure>

<h3 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h3><p>回文是指这样一种现象：一个单词、短语或数字，从前往后写和从后往前写都是一样的。<br>使用栈，可以轻松地判断一个字符串是否是回文，我们将拿到的字符串的每个字符按从左到右的顺序压入栈。当字符串中的字符都入栈后，栈内就保存了一个反转后的字符串，最后的字符在栈顶，第一个字符在栈底。字符串完整压入栈内后，通过持续弹出栈中的每个字母就可以得到一个新字符串，该字符串刚好与原来的字符串顺序相反，我们只需要比较这两个字符串即可，如果他们相等，就是一个回文。<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore = [];</span><br><span class="line">    <span class="keyword">this</span>.top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.push = push;</span><br><span class="line">    <span class="keyword">this</span>.pop = pop;</span><br><span class="line">    <span class="keyword">this</span>.peek = peek;</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top++] = element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[--<span class="keyword">this</span>.top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">peek</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dataStore[<span class="keyword">this</span>.top<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义回文函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;word.length; i++) &#123;</span><br><span class="line">        s.push(word[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> rword = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> (s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rword += s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (word == rword) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> word =<span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(word));  <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> ses = <span class="string">"ses"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(ses));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="递归演示"><a href="#递归演示" class="headerlink" title="递归演示"></a>递归演示</h3><p>可以用栈来模拟递归过程。下面是一个递归函数，可以计算任意数字的阶乘，分别用寻常递归函数与栈模拟递归过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻常递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">5</span>));   <span class="comment">//120</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用栈模拟递归过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        s.push(n--);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        product *= s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fact(<span class="number">5</span>));     <span class="comment">//120</span></span><br></pre></td></tr></table></figure>

<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>1、栈可以用来判断一个算术表达式中的括号是否匹配。编写一个函数，该函数接受一个算术表达式作为参数，返回括号缺失的位置，下面是一个括号不匹配的算术表达式的例子：2.3+23/12+(3.14159*0.24。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 练习1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkBracket</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i]==<span class="string">'('</span>) &#123;</span><br><span class="line">            arr.push(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            arr.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.peek();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkBracket(<span class="string">'2.3 + 23 / 12 + (3.14159*0.24'</span>));  <span class="comment">//16</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/blog/2020/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>如下图所示为有头节点的链表<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" alt="链表示意图"></p>
<h3 id="数组的缺点"><a href="#数组的缺点" class="headerlink" title="数组的缺点"></a>数组的缺点</h3><p>JavaScript中的数组的主要问题是：它们被实现成了对象，与其他语言的数组相比，效率很低。若在实际使用中，发现数组效率很慢，可以考虑用链表代替，如果需要随机访问，数组还是最好的选择。</p>
<h2 id="基于对象的链表"><a href="#基于对象的链表" class="headerlink" title="基于对象的链表"></a>基于对象的链表</h2><p>链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一个节点的引用叫做链。<br>我们设计的链表包含两个类。Node类用来表示节点，LinkedList类提供了插入节点、删除节点、显示列表元素的方法，以及其他一些辅助方法。</p>
<h3 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h3><p>Node类型包含两个属性：element用来保存节点上的数据，next用来保存指向下一个节点的链接。我们使用一个构造函数来创建节点，该构造函数设置了这两个属性的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.element = element;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><p>LList类提供了对链表进行操作的方法。该类的功能包括插入删除节点、在列表中查找给定的值。该类也有一个构造函数，链表只有一个属性，那就是使用一个Node对象来保存该链表的头节点。该类的构造函数如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">  <span class="keyword">this</span>.find = find;</span><br><span class="line">  <span class="keyword">this</span>.insert = insert;</span><br><span class="line">  <span class="keyword">this</span>.remove = remove;</span><br><span class="line">  <span class="keyword">this</span>.display = display;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <ul><li>insert方法：插入新节点, 向链表中插入一个新节点时需要明确指出要在哪个节点前面或者后面插入；</li><li>find方法：遍历链表，查找给定数据；</li><li>display方法：显示链表中的元素；</li><li>remove方法：删除链表中的元素。</li></ul>
          </div>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.element = element;</span><br><span class="line">      <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">      <span class="keyword">this</span>.find = find;</span><br><span class="line">      <span class="keyword">this</span>.insert = insert;</span><br><span class="line">      <span class="keyword">this</span>.remove = remove;</span><br><span class="line">      <span class="keyword">this</span>.display = display;</span><br><span class="line">      <span class="keyword">this</span>.findPrevious = findPrevious;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">      <span class="keyword">while</span>(currNode.element != item) &#123;</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newElement,item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">      <span class="keyword">let</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">      newNode.next = current.next;</span><br><span class="line">      current.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">      <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(currNode.next.element);</span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findPrevious</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">      <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>) &amp;&amp; currNode.next.element != item) &#123;</span><br><span class="line">        currNode = currNode.next</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> currNode</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> prevNode = <span class="keyword">this</span>.findPrevious(item);</span><br><span class="line">      <span class="keyword">if</span>(!(prevNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">        prevNode.next = prevNode.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> cities = <span class="keyword">new</span> LList();</span><br><span class="line">    cities.insert(<span class="string">"Conway"</span>,<span class="string">"head"</span>);</span><br><span class="line">    cities.insert(<span class="string">"Russellville"</span>,<span class="string">"Conway"</span>);</span><br><span class="line">    cities.insert(<span class="string">"Alma"</span>,<span class="string">"Russellville"</span>);</span><br><span class="line">    cities.display();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"***********"</span>)</span><br><span class="line">    cities.remove(<span class="string">"Russellville"</span>);</span><br><span class="line">    cities.display();</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Conway</span><br><span class="line">Russellville</span><br><span class="line">Alma</span><br><span class="line">***********</span><br><span class="line">Conway</span><br><span class="line">Alma</span><br></pre></td></tr></table></figure>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>尽管从链表的头节点遍历到尾节点很简单，但反过来，从后向前遍历则没那么简单，通过给Node对象增加一个属性，该属性存储指向前驱节点的链接，这样就容易多了。此时向链表中插入一个节点需要更多的工作，我们需要指出该节点正确的前驱和后继。但是在从链表中删除节点时，效率提高了，不需要再查找待删除节点的前驱节点了。下图演示了双向链表的工作原理。<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" alt="双向链表工作原理"></p>
<p>与单向链表不同的是，Node类增加一个previous属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.element = element;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.previous = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>双向链表相对于单向链表来说，方法上有哪些不同：</p><ul><li>insert(): 与单向链表类似，但是需要设置新节点的previous属性，使其指向该节点的前驱。</li><li>remove(): 与单向链表相比效率更高，因为不需要查找前驱节点了。</li><li>findLast(): 增加的方法，用来查找最后的节点，同时免除了从后往前遍历之苦。</li><li>dispReverse()方法：反序显示双向链表中的元素。</li></ul>
          </div>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.element = element;</span><br><span class="line">  <span class="keyword">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.previous = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">  <span class="keyword">this</span>.find = find;</span><br><span class="line">  <span class="keyword">this</span>.insert = insert;</span><br><span class="line">  <span class="keyword">this</span>.display =display;</span><br><span class="line">  <span class="keyword">this</span>.remove = remove;</span><br><span class="line">  <span class="keyword">this</span>.findLast = findLast;</span><br><span class="line">  <span class="keyword">this</span>.dispReverse = dispReverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>(currNode.element != item) &#123;</span><br><span class="line">    currNode =currNode.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">newElement, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(newElement);</span><br><span class="line">  <span class="keyword">let</span> current = <span class="keyword">this</span>.find(item);</span><br><span class="line">  <span class="keyword">while</span>(current.element != item) &#123;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">  newNode.next = current.next;</span><br><span class="line">  newNode.previous = current;</span><br><span class="line">  current.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(currNode.element);</span><br><span class="line">    currNode = currNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currNode = <span class="keyword">this</span>.find(item);</span><br><span class="line">  <span class="keyword">if</span>(!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">    currNode.previous.next = currNode.next;</span><br><span class="line">    currNode.next.previous = currNode.previous;</span><br><span class="line">    currNode.next = <span class="literal">null</span>;</span><br><span class="line">    currNode.previous = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLast</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>)) &#123;</span><br><span class="line">    currNode = currNode.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> currNode</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispReverse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  currNode = <span class="keyword">this</span>.findLast();</span><br><span class="line">  <span class="keyword">while</span>(!(currNode.previous == <span class="literal">null</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(currNode.element);</span><br><span class="line">    currNode = currNode.previous;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cities = <span class="keyword">new</span> LList();</span><br><span class="line">cities.insert(<span class="string">"Conway"</span>,<span class="string">"head"</span>);</span><br><span class="line">cities.insert(<span class="string">"Russellville"</span>,<span class="string">"Conway"</span>);</span><br><span class="line">cities.insert(<span class="string">"Alma"</span>,<span class="string">"Russellville"</span>);</span><br><span class="line">cities.display();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"***********"</span>)</span><br><span class="line">cities.remove(<span class="string">"Russellville"</span>);</span><br><span class="line">cities.display();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;"</span>)</span><br><span class="line">cities.dispReverse()</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">head</span><br><span class="line">Conway</span><br><span class="line">Russellville</span><br><span class="line">***********</span><br><span class="line">head</span><br><span class="line">Conway</span><br><span class="line">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span><br><span class="line">Alma</span><br><span class="line">Conway</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表和单向链表相似，节点类型也是一样的。唯一的区别是：在创建循环链表时，让其头节点的next属性指向它本身，即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">head.next = head</span><br></pre></td></tr></table></figure>
<p>这种行为会传导至链表中的每个节点，使得每个节点的next属性都指向链表的头节点。换句话说，链表的尾节点指向头节点，形成了一个循环链表。如下图所示：<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95javascript%E6%8F%8F%E8%BF%B0/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" alt="循环链表工作原理"></p>
<p>如果你希望可以从后往前遍历链表，但是又不想付出额外代价来创建一个双向链表，那么就需要使用循环链表。从循环链表的尾节点向后移动，就等于从后向前遍历链表。<br>创建循环链表，只需要修改LList类的构造函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LList</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span><br><span class="line">  <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">this</span>.find = find;</span><br><span class="line">  <span class="keyword">this</span>.insert = insert;</span><br><span class="line">  <span class="keyword">this</span>.display = display;</span><br><span class="line">  <span class="keyword">this</span>.findPrevious = findPrevious;</span><br><span class="line">  <span class="keyword">this</span>.remove = remove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要修改一处就可以将单向链表变成了循环链表。但是其他一些方法需要修改才能工作正常。比如：display()需要修改，原来的方式在循环链表里会陷入死循环。while循环的循环条件需要修改，需要检查头节点，当循环到头节点时推出循环。<br>循环链表的display()方法如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span><br><span class="line">  <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>) &amp;&amp; !(currNode.next.element == <span class="string">"head"</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(currNode.element);</span><br><span class="line">    currNode = currNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他方法与此类似。</p>
<h2 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h2><p>传说在公元 1 世纪的犹太战争中， 犹太历史学家弗拉维奥· 约瑟夫斯和他的 40 个同胞被罗马士兵包围。 犹太士兵决定宁可自杀也不做俘虏， 于是商量出了一个自杀方案。 他们围成一个圈， 从一个人开始， 数到第三个人时将第三个人杀死， 然后再数， 直到杀光所有人。 约瑟夫和另外一个人决定不参加这个疯狂的游戏， 他们快速地计算出了两个位置， 站在那里得以幸存。 写一段程序将 n 个人围成一圈， 并且第 m 个人会被杀掉， 计算一圈人中哪两个人最后会存活。 使用循环链表解决该问题。</p>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//Node类</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">Node</span><span class="params">(element)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.element = element;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.next = <span class="literal">null</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//构造函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">LList</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="string">"head"</span>);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.head;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.advance = advance;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.currentNode = <span class="keyword">this</span>.head;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.find = find;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.insert = insert;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.remove = remove;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.display = display;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.findPrevious = findPrevious;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.count = count;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//查找节点</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(item)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">while</span>(!(currNode.next == <span class="literal">null</span>) &amp;&amp; !(currNode.element == item)) &#123;</span></span><br><span class="line">        currNode = currNode.next</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> currNode</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//插入节点</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">(newElement,item)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> newNode = <span class="keyword">new</span> Node(newElement);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> current = <span class="keyword">this</span>.find(item);</span></span><br><span class="line">      newNode.next = current.next;</span><br><span class="line">      current.next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//找到当前节点的前一个节点</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">findPrevious</span><span class="params">(item)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">while</span>(!(currNode.next.element == <span class="string">"head"</span>) &amp;&amp; (currNode.next.element != item)) &#123;</span></span><br><span class="line">        currNode = currNode.next</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> currNode</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//删除节点</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span><span class="params">(item)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> prevNode = <span class="keyword">this</span>.findPrevious(item);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span>(!(prevNode.next.element == <span class="string">"head"</span>)) &#123;</span></span><br><span class="line">        prevNode.next = prevNode.next.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//计算有多少节点</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> node = <span class="keyword">this</span>.head;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> i = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">while</span>(!(node.next.element == <span class="string">"head"</span>)) &#123;</span></span><br><span class="line">        node = node.next;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> i;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//显示</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> currNode = <span class="keyword">this</span>.head;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">while</span>(!(currNode.next.element == <span class="string">"head"</span>)) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(currNode.next.element +  <span class="string">"&amp;nbsp;"</span>);</span></span><br><span class="line">        currNode = currNode.next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//向前移动n个节点</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">advance</span> <span class="params">(n)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">while</span> (n&gt;<span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(<span class="keyword">this</span>.currentNode.next.element == <span class="string">"head"</span>)&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.currentNode = <span class="keyword">this</span>.currentNode.next.next;</span></span><br><span class="line"><span class="actionscript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.currentNode = <span class="keyword">this</span>.currentNode.next;</span></span><br><span class="line">        &#125;        </span><br><span class="line">        n--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> list = <span class="keyword">new</span> LList();</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> n = <span class="number">10</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> temp = <span class="string">"head"</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span></span><br><span class="line">      list.insert(i,temp);</span><br><span class="line">      temp = i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> index = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> m = <span class="number">3</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">while</span>(list.count() &gt; <span class="number">2</span>) &#123;</span></span><br><span class="line">      list.advance(n);</span><br><span class="line">      list.remove(list.currentNode.element);</span><br><span class="line">      list.display();</span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">'&lt;br&gt;'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>假设有10个人，输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> </span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">8</span> </span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/blog/2020/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础</title>
    <url>/blog/2020/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>计算机网络主要包括实现资源共享，实现数据信息的快速传递。</p>
<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><div class="note info">
            <p>制定组织：ISO(国际标准化组织)<br>作用：使网络通信工作流程标准化<br>应用层：提供用户服务，具体功能有应用程序实现；<br>表示层：数据的压缩优化加密；<br>会话层：建立用户级的连接，选择适当的传输服务；<br>传输层：提供传输服务；<br>网络层：路由选择，网络互联；<br>链路层：进行数据交换，控制具体数据的发送；<br>物理层：提供数据传输的硬件保证，网卡接口，传输介质。</p><hr><p>优点：</p><ol><li>建立了统一的工作机制；</li><li>分部清晰，各司其职，每个步骤分工明确；</li><li>降低了各个模块之间的耦合度，便于开发。</li></ol>
          </div>

<h2 id="四层模型（TCP-IP模型）"><a href="#四层模型（TCP-IP模型）" class="headerlink" title="四层模型（TCP/IP模型）"></a>四层模型（TCP/IP模型）</h2><p>背景：实际工作中工程师无法按照七层模型要求操作，逐渐演化为更符合实际的四层模型。<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94" alt="attr"></p>
<h3 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h3><div class="note info">
            <ol><li>发送端的应用程序发送消息，逐层添加首部信息，最终再由物理层发送消息包；</li><li>发送的消息经过多个节点（交换机，路由器）传输，最终到达目标主机；</li><li>目标主机由物理层逐层解析首部消息包，最终到应用程序呈现消息。</li></ol>
          </div>

<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>在网络数据传输中，都遵循的规定，包括建立什么样的数据结构，什么样的特殊标志等。</p>
<h2 id="网络基础概念"><a href="#网络基础概念" class="headerlink" title="网络基础概念"></a>网络基础概念</h2><h3 id="网络主机（host）"><a href="#网络主机（host）" class="headerlink" title="网络主机（host）"></a>网络主机（host）</h3><div class="note info">
            <p>功能：标识一台主机在网络中的位置（地址）<br>本地地址：&#39;localhost’,&#39;127.0.0.1’<br>网络地址(IP地址)：&#39;172.60.50.12’（例子）<br>自动获取地址（自动获取合适网卡IP）：&#39;0.0.0.0’</p>
          </div>

<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><div class="note info">
            <p>功能：确定一台主机的网络路由地址<br>结构：</p><ul><li>IPv4 点分十进制表示172.60.50.12，每部分取值范围0-255</li><li>IPv6 128位 扩大了地址范围</li></ul><p>特殊IP:</p><ul><li>127.0.0.1 本机测试IP</li><li>0.0.0.0 自动获取本机网卡地址</li><li>172.60.50.0 通常表示一个网段</li><li>172.60.50.1 通常表示一个网关</li><li>172.60.50.12用作广播地址</li></ul><p>域名：</p><ul><li>定义：给网络服务器地址起的名字</li><li>作用：方便记忆，表达一定的含义</li><li>ping[ip]: 测试和某个主机是否联通</li></ul><p>端口号：</p><ul><li>作用：端口是网络地址的一部分，用于区分主机上不同的网络应用程序</li><li>特点：一个系统中的应用监听端口不能重复</li><li>取值范围：1-65535  1-1023系统应用或者大众程序监听端口；1024-65535自用端口</li></ul>
          </div>

<h2 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h2><h3 id="面向连接的传输服务（基于TCP协议的数据传输）"><a href="#面向连接的传输服务（基于TCP协议的数据传输）" class="headerlink" title="面向连接的传输服务（基于TCP协议的数据传输）"></a>面向连接的传输服务（基于TCP协议的数据传输）</h3><div class="note info">
            <ol><li>传输特征：提供了可靠的数据传输，可靠性指数据传输过程中无丢失、无失序、无差错、无重复。</li><li>实现手段：在通信前需要建立数据连接，通信结束要正常断开连接。</li><li>适用情况：对数据传输准确性有明确要求，传数文件较大，需要确保可靠性的情况，比如：网页获取，文件下载，邮件收发。</li></ol>
          </div>

<div class="note info">
            <p>三次握手（建立连接）</p><ul><li>客户端向服务器发送消息报文请求连接；</li><li>服务器收到请求后，回复报文确认可以连接；</li><li>客户端收到回复，发送最终报文连接建立。</li></ul>
          </div>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<div class="note info">
            <p>四次挥手（断开连接）</p><ul><li>主动方发送报文请求断开连接；</li><li>被动方收到请求后，立即回复，表示准备离开；</li><li>被动放准备就绪，再次发送报文表示离开；</li><li>主动方收到确认，发送最终报文完成断开。</li></ul>
          </div>

<p><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<h3 id="面向无连接的传输服务（基于UDP协议的数据传输）"><a href="#面向无连接的传输服务（基于UDP协议的数据传输）" class="headerlink" title="面向无连接的传输服务（基于UDP协议的数据传输）"></a>面向无连接的传输服务（基于UDP协议的数据传输）</h3><div class="note info">
            <ol><li>传输特点：不保证传输的可靠性，传输过程没有连接和断开，数据收发自由随意。</li><li>适用情况：网络较差，对传输可靠性要求不高。比如：网络视频，群聊，广播等。</li></ol>
          </div>

<h2 id="socket套接字编程"><a href="#socket套接字编程" class="headerlink" title="socket套接字编程"></a>socket套接字编程</h2><h3 id="套接字介绍"><a href="#套接字介绍" class="headerlink" title="套接字介绍"></a>套接字介绍</h3><div class="note info">
            <ol><li>套接字：实现网络编程进行数据传输的一种技术手段；</li><li>Python实现套接字编程：import socket；</li><li>套接字分类：<ul><li>流式套接字(SOCK_STREAM)：以字节流方式传输数据，实现tcp网络传输方案。（面向连接–tcp协议– 可靠的–流式套接字）；</li><li>数据报套接字(SOCK_DGTAM)：以数据报形式传输数据，实现udp网络传输方案。（无连接–udp协议–不可靠—数据报套接字）</li></ul></li></ol>
          </div>

<h3 id="tcp套接字编程"><a href="#tcp套接字编程" class="headerlink" title="tcp套接字编程"></a>tcp套接字编程</h3><h4 id="服务端流程"><a href="#服务端流程" class="headerlink" title="服务端流程"></a>服务端流程</h4><p>—&gt;socket —&gt; bind  —&gt; listen —&gt; accept —&gt; send/recv —&gt; close</p>
<p>代码实现(python版本)：</p>
<ol>
<li><p>创建套接字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sockfd = socket.socket(socket_family=AF_INET, socket_type=SOCK_STREAM,proto=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能：创建套接字<br>参数：socket_family  网络地址类型  AF_INET表示ipv4<br>      socket_type   套接字类型SOCK_STREAM（流式） SOCK_DGRAM（数据报）<br>      proto     通常为0  选择子协议<br>返回值： 套接字对象</p>
          </div></li>
<li><p>绑定地址</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sockfd.bind(addr)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能：绑定本机网络地址<br>参数：二元元组(ip,port)  (‘0.0.0.0’,8888)</p>
          </div>
</li>
<li><p>设置监听</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sockfd.listen(n)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能：将套接字设置为监听套接字，确认监听队列大小<br>参数：监听队列大小</p>
          </div>
</li>
<li><p>等待处理客户端连接请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">connfd,addr = sockfd.accept()</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能：阻塞等待处理客户端请求<br>返回值：connfd   客户端连接套接字<br>        addr    连接的客户端地址</p>
          </div>
</li>
<li><p>消息收发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data = connfd.recv(buffersize)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能：接受客户端消息；<br>参数：每次最多接收消息的大小；<br>返回值：接收到的内容。</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">n = connfd.send(data)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能：发送消息；<br>参数：data： 要发送的内容  bytes格式<br>返回值：发送的字节数</p>
          </div>
</li>
<li><p>关闭套接字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>TCP套接字服务端代码（python版重点代码）(亲测有效)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 创建流式套接字</span></span><br><span class="line">sockfd = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定地址 本地连接</span></span><br><span class="line">sockfd.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置监听</span></span><br><span class="line">sockfd.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Waiting for connet....."</span>)</span><br><span class="line"><span class="comment">#等待处理客户端连接请求</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  print(<span class="string">"Waiting for connect...."</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    connfd,addr = sockfd.accept()</span><br><span class="line">  <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    print(<span class="string">"退出服务"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 收发消息</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">     data = connfd.recv(<span class="number">1024</span>)</span><br><span class="line">     <span class="comment"># 得到空就退出</span></span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     print(<span class="string">"接收到的消息："</span>,data.decode())</span><br><span class="line"></span><br><span class="line">     n = connfd.send(<span class="string">b'Receive your message'</span>)</span><br><span class="line">     print(<span class="string">"发送了%d个字节的数据"</span>%n)</span><br><span class="line">  <span class="comment">#关闭客户端套接字</span></span><br><span class="line">  connfd.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭服务端套接字</span></span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure>

<h4 id="客户端流程"><a href="#客户端流程" class="headerlink" title="客户端流程"></a>客户端流程</h4><p>—&gt;socket —&gt; bind —&gt; connect —&gt; send/recv —&gt; close<br>(bind这个步骤一般不用，所以一般不写)</p>
<ol>
<li><p>创建套接字<br>要注意创建相同类型的套接字才能进行通信</p>
</li>
<li><p>请求连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.connect(server_addr)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能： 连接服务器<br>参数：元组  服务器地址</p>
          </div>
</li>
<li><p>收发消息<br>注意：防止两端都阻塞，recv send要配合</p>
</li>
<li><p>关闭套接字</p>
</li>
</ol>
<p>TCP套接字客户端代码(Python版重点代码)(亲测有效)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 创建套接字</span></span><br><span class="line">sockfd = socket() <span class="comment">#默认参数为TCP套接字，ipv4</span></span><br><span class="line"><span class="comment"># 发起连接 我写的是本地连接</span></span><br><span class="line">server_addr = (<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line">sockfd.connect(server_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收发消息(循环发送)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  data = input(<span class="string">'消息：'</span>)</span><br><span class="line">  <span class="comment"># 得到空就退出</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  sockfd.send(data.encode())</span><br><span class="line">  data = sockfd.recv(<span class="number">1024</span>)</span><br><span class="line">  print(<span class="string">"From server:"</span> , data.decode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭套接字</span></span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure>

<h4 id="tcp-套接字数据传输特点"><a href="#tcp-套接字数据传输特点" class="headerlink" title="tcp 套接字数据传输特点"></a>tcp 套接字数据传输特点</h4><div class="note info">
            <ol><li>tcp连接中当一端退出，另一端如果阻塞在recv，此时recv会立即返回一个空字符串；</li><li>tcp连接中如果一端已经不存在，然而试图通过send发送则会产生BrokenPipeError(管道破裂异常)</li><li>一个监听套接字可以同时连接多个客户端，也能够重复被连接</li></ol>
          </div>

<h4 id="网络收发缓冲区"><a href="#网络收发缓冲区" class="headerlink" title="网络收发缓冲区"></a>网络收发缓冲区</h4><div class="note info">
            <ol><li>网络缓冲区有效的协调了消息的收发速度</li><li>send和recv实际是向缓冲区发送消息，当缓冲区不为空recv就不会阻塞。</li></ol>
          </div>

<h4 id="tcp粘包"><a href="#tcp粘包" class="headerlink" title="tcp粘包"></a>tcp粘包</h4><div class="note info">
            <p>原因：tcp是以字节流的方式传输，没有消息边界。多次发送的消息被一次接收，此时就会形成粘包。<br>影响：如果每次发送内容是一个独立的含义，需要接收端独立解析此时的粘包会有影响。<br>处理方法：</p><ul><li>人为的添加消息边界</li><li>控制发送速度</li></ul>
          </div>

<h3 id="UDP套接字编程"><a href="#UDP套接字编程" class="headerlink" title="UDP套接字编程"></a>UDP套接字编程</h3><h4 id="服务端流程-1"><a href="#服务端流程-1" class="headerlink" title="服务端流程"></a>服务端流程</h4><p>—&gt;socket —&gt; bind —&gt; recvfrom/sendto —&gt; close()</p>
<ol>
<li><p>创建数据报套接字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd = socket(AF_INET, SOCK_DGRAM)</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.bind(addr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息收发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data,addr = sockfd.recvfrom(buffersize)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能：接收UDP消息；<br>参数：每次最多接收多少字节；<br>返回值：data：接收到的内容<br>       addr：消息发送方地址</p>
          </div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">n = sockfd.sendto(data,addr)</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>功能：发送UDP消息；<br>参数：data: 要发送的内容  bytes格式<br>      addr: 目标地址<br>返回值：发送的字节数</p>
          </div>
</li>
<li><p>关闭套接字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">UDP服务端</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 创建数据报套接字</span></span><br><span class="line">sockfd = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定地址</span></span><br><span class="line">server_addr = (<span class="string">'0.0.0.0'</span>, <span class="number">8888</span>)</span><br><span class="line">sockfd.bind(server_addr)</span><br><span class="line"><span class="comment"># 收发消息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data,addr = sockfd.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">"收到的消息"</span>, data.decode())</span><br><span class="line">    sockfd.sendto(<span class="string">b"Thanks"</span>, addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure>
<h4 id="客户端流程-1"><a href="#客户端流程-1" class="headerlink" title="客户端流程"></a>客户端流程</h4><p>—&gt;socket —&gt; sendto/recvfrom —&gt; close()</p>
<ol>
<li>创建套接字</li>
<li>收发消息</li>
<li>关闭套接字<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">udp客户端</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 服务器地址</span></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">8888</span></span><br><span class="line">ADDR = (HOST,PORT)</span><br><span class="line"><span class="comment"># 创建套接字</span></span><br><span class="line">sockfd = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 收发消息</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = input(<span class="string">"Msg&gt;&gt;"</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sockfd.sendto(data.encode(),ADDR)</span><br><span class="line">    msg,addr = sockfd.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">"From server: "</span>, msg.decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure>
<div class="note info">
            <p>总结：tcp和udp套接字编程区别</p><ol><li>流式套接字是以字节流方式传输数据，数据报套接字以数据报形式传输</li><li>tcp套接字会有粘包，udp套接字有消息边界不会粘包</li><li>tcp套接字保证消息的完整性，udp套接字则不能</li><li>tcp套接字以来listen accept建立连接才能收发消息，udp套接字不需要</li><li>tcp套接字使用send，recv收发消息，udp套接字使用sendto，recvfrom</li></ol>
          </div>

</li>
</ol>
<h3 id="练习，客户端向服务端发送图片（TCP）"><a href="#练习，客户端向服务端发送图片（TCP）" class="headerlink" title="练习，客户端向服务端发送图片（TCP）"></a>练习，客户端向服务端发送图片（TCP）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">s = socket()</span><br><span class="line">s.bind((<span class="string">'0.0.0.0'</span>,<span class="number">8888</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line">c,addr = s.accept()</span><br><span class="line">print(<span class="string">"Connect from"</span>,addr)</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'cxk.gif'</span>,<span class="string">'wb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收内容写入文件</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = c.recv(<span class="number">1024</span>)   <span class="comment">#字节串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    f.write(data)</span><br><span class="line">f.close()</span><br><span class="line">c.close()</span><br><span class="line">s.close()</span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">s= socket()</span><br><span class="line">s.connect((<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>))</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'timg.jfif'</span>,<span class="string">'rb'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取内容进行发送</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = f.read(<span class="number">1024</span>) <span class="comment">#字节串</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    s.send(data)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<h3 id="UDP套接字广播"><a href="#UDP套接字广播" class="headerlink" title="UDP套接字广播"></a>UDP套接字广播</h3><div class="note info">
            <ol><li>广播定义：一端发送多点接收。</li><li>广播地址：每个网络的最大地址为发送广播的地址，向该地址发送，则网段内所有的主机都能接收到。</li></ol>
          </div>

<h2 id="TCP套接字之HTTP传输"><a href="#TCP套接字之HTTP传输" class="headerlink" title="TCP套接字之HTTP传输"></a>TCP套接字之HTTP传输</h2><h3 id="HTTP协议（超文本传输协议）"><a href="#HTTP协议（超文本传输协议）" class="headerlink" title="HTTP协议（超文本传输协议）"></a>HTTP协议（超文本传输协议）</h3><div class="note info">
            <ol><li>用途：网页获取，数据传输</li><li>特点：<ul><li>应用层协议，传输层使用tcp传输</li><li>简单，灵活，很多语言都有HTTP专门接口</li><li>无状态，协议不记录传输内容</li><li>http1.1支持持久连接，丰富了请求类型</li></ul></li></ol>
          </div>

<p><strong>网页请求过程</strong><br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http%E8%AF%B7%E6%B1%82%E4%B8%8E%E8%BF%9E%E6%8E%A5" alt="网页请求过程"></p>
<div class="note info">
            <ol><li>客户端（浏览器）通过tcp传输，发送http请求给服务端</li><li>服务端接收到http请求后进行解析</li><li>服务端处理请求内容，组织响应内容</li><li>服务端将响应内容以http响应格式发送给浏览器</li><li>浏览器接收到响应内容，解析展示</li></ol>
          </div>

<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><div class="note info">
            <ol><li>请求行：具体的请求类别和请求内容<ul><li>请求类别：每个请求类别表示要做不同的事情<ul><li>GET: 获取网络资源</li><li>POST: 提交一定的信息，得到反馈</li><li>HEAD: 只获取网络资源的响应头</li><li>PUT: 更新服务器资源</li><li>DELETE: 删除服务器资源</li><li>CONNECT</li><li>TRACE: 测试</li><li>OPTIONS: 获取服务器性能信息</li></ul></li></ul></li><li>请求头： 对请求的进一步解释和描述</li><li>空行</li><li>请求体：请求参数或者提交内容</li></ol>
          </div>

<h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><div class="note info">
            <ol><li>响应格式：响应行，响应头，空行，响应体<ul><li>响应行：反馈基本的响应情况   （版本信息   响应码  附加信息）<br>响应码：<ul><li>1xx 提示信息，表示请求被接收</li><li>2xx 响应成功</li><li>3xx 响应需要进一步操作，重定向</li><li>4xx 客户端错误</li><li>5xx 服务端错误</li></ul></li><li>响应头：对应响应内容的描述  Content-Type:text/html</li><li>空行</li><li>响应体：响应的主体内容信息</li></ul></li></ol>
          </div>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程</title>
    <url>/blog/2020/08/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="多任务编程"><a href="#多任务编程" class="headerlink" title="多任务编程"></a>多任务编程</h2><div class="note info">
            <ol><li>意义：充分利用计算机多核资源，提高程序的运行效率。</li><li>实现方案：多进程，多线程。</li><li>并行和并发<ul><li>并发：同时处理多个任务，内核在任务间不断的切换达到好像多个任务被同时执行的效果，实际每个时刻只有一个任务占有内核。</li><li>并行：多个任务利用计算机多核资源在同时执行，此时多个任务间为并行关系。 </li></ul></li></ol>
          </div>
<h2 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h2><h3 id="进程理论基础"><a href="#进程理论基础" class="headerlink" title="进程理论基础"></a>进程理论基础</h3><div class="note info">
            <ol><li>定义：程序在计算机中的一次运行。<ul><li>程序是一个可执行的文件，是静态的占有磁盘。</li><li>进程是一个动态的过程描述，占有计算机运行资源，有一定的生命周期。</li></ul></li><li>系统中如何产生一个进程<ul><li>用户空间通过调用程序接口或者命令发起请求；</li><li>操作系统接收用户请求，开始创建进程；</li><li>操作系统调配计算机资源，确定进程状态等；</li><li>操作系统将创建的进程提供给用户使用。</li></ul></li></ol>
          </div>

<h3 id="进程基本概念"><a href="#进程基本概念" class="headerlink" title="进程基本概念"></a>进程基本概念</h3><div class="note info">
            <p>cpu时间片：如果一个进程占有cpu内核，则称这个进程在cpu时间片上。<br>PCB（进程控制块）：在内存中开辟的一块空间，用于存放进程的基本信息，也用于系统查找识别进程。<br>进程ID(PID): 系统为每个进程分配的一个大于0的整数，作为进程ID。每个进程ID不重复。<br>父子进程：系统中每一个进程（除了系统初始化进程）都有唯一的父进程，可有0个或者多个子进程，父子进程关系便于进程管理。</p>
          </div>

<div class="note info">
            <p>进程状态：</p><ul><li>三态：<ul><li>就绪态：进程具备执行条件，等待分配cpu资源；</li><li>运行态：进程占有cpu时间片正在运行；</li><li>等待态：进程暂时停止运行，让出cpu。</li></ul></li><li>五态（在三态基础上增加新建和终止）：<ul><li>新建：创建一个进程，获取资源的过程；</li><li>终止：终止进程。</li></ul></li></ul>
          </div>

<div class="note info">
            <ol><li>进程可以使用计算机多核资源；</li><li>进程是计算机分配资源的最小单位；</li><li>进程之间的运行互不影响，各自独立；</li><li>每个进程拥有独立的空间，各自使用自己空间资源。</li></ol>
          </div>

<h2 id="基于fork的多进程编程"><a href="#基于fork的多进程编程" class="headerlink" title="基于fork的多进程编程"></a>基于fork的多进程编程</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/blog/2020/05/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列也是一种受限的线性结构，受限之处在于只在表的前端进行删除操作，在表的后端进行插入操作。</p>
<h3 id="队列结构封装"><a href="#队列结构封装" class="headerlink" title="队列结构封装"></a>队列结构封装</h3><p>队列的实现和栈一样，有两种结构：一个是基于数组操作，另一种是基于链表操作。</p>
<h3 id="基于数组实现的队列"><a href="#基于数组实现的队列" class="headerlink" title="基于数组实现的队列"></a>基于数组实现的队列</h3><p>程序实现代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.items = []</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//方法</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 1. 将元素加入到队列中</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.enqueue = <span class="function"><span class="keyword">function</span><span class="params">(element)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.items.push(element)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//2. 从队列中剔除前端元素</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.dequeue = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">               <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//3. 查看前端元素</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.front = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>]</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//4. 查看队列是否为空</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.isEmpty = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.items.length == <span class="number">0</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//5. 查看队列元素的个数</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.size = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//6. toString方法</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.toString = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> resultString = <span class="string">''</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.items.length;i++) &#123;</span></span><br><span class="line"><span class="actionscript">                    resultString += <span class="keyword">this</span>.items[i] + <span class="string">''</span></span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> resultString</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue()</span></span><br><span class="line"><span class="actionscript">        queue.enqueue(<span class="string">'abc'</span>)</span></span><br><span class="line"><span class="actionscript">        queue.enqueue(<span class="string">'cba'</span>)</span></span><br><span class="line"><span class="actionscript">        queue.enqueue(<span class="string">'nba'</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(queue.isEmpty())   <span class="comment">//false</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(queue.dequeue())   <span class="comment">//abc</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(queue.front())     <span class="comment">//cba</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="击鼓传花"><a href="#击鼓传花" class="headerlink" title="击鼓传花"></a>击鼓传花</h3><p>击鼓传花是一个常见的面试算法题，使用队列可以非常方便的实现最终的结果。<br>修改原本的击鼓传花游戏规则，几个朋友一起玩一个游戏，围成一圈，开始数数，数到某个数字的人自动淘汰，最后剩下的这个人会获得胜利，请问最后剩下的是原来在哪个位置上的人？<br>程序实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.items = []</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//方法</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 1. 将元素加入到队列中</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.enqueue = <span class="function"><span class="keyword">function</span><span class="params">(element)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.items.push(element)</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//2. 从队列中剔除前端元素</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.dequeue = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">               <span class="keyword">return</span> <span class="keyword">this</span>.items.shift()</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//3. 查看前端元素</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.front = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.items[<span class="number">0</span>]</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//4. 查看队列是否为空</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.isEmpty = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.items.length == <span class="number">0</span></span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//5. 查看队列元素的个数</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.size = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> <span class="keyword">this</span>.items.length</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            <span class="comment">//6. toString方法</span></span></span><br><span class="line"><span class="actionscript">            Queue.prototype.toString = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> resultString = <span class="string">''</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.items.length;i++) &#123;</span></span><br><span class="line"><span class="actionscript">                    resultString += <span class="keyword">this</span>.items[i] + <span class="string">''</span></span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> resultString</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue()</span></span><br><span class="line"><span class="actionscript">       <span class="comment">//击鼓传花</span></span></span><br><span class="line"><span class="actionscript">       <span class="function"><span class="keyword">function</span> <span class="title">passGame</span><span class="params">(nameList,num)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">           <span class="comment">//1.创建一个队列结构</span></span></span><br><span class="line"><span class="actionscript">           <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue()</span></span><br><span class="line"><span class="actionscript">           <span class="comment">//2.将所有人依次加入到队列中</span></span></span><br><span class="line"><span class="actionscript">           <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;nameList.length;i++) &#123;</span></span><br><span class="line">               queue.enqueue(nameList[i])</span><br><span class="line">           &#125;</span><br><span class="line"><span class="actionscript">           <span class="comment">//3.开始数数字，不是num的时候，重新加入到队列的末尾，是num数字的时候，将其从队列中删除掉</span></span></span><br><span class="line"><span class="actionscript">           <span class="keyword">while</span>(queue.size() &gt; <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;num<span class="number">-1</span>;i++) &#123;</span></span><br><span class="line">                queue.enqueue(queue.dequeue())</span><br><span class="line">                &#125;</span><br><span class="line">                queue.dequeue()</span><br><span class="line">            &#125;</span><br><span class="line">            alert(queue.size())</span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> endName = queue.front()</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">"最终剩下的人"</span> + endName)</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> nameList.indexOf(endName)</span></span><br><span class="line">       &#125;</span><br><span class="line"><span class="actionscript">       <span class="comment">//测试击鼓传花</span></span></span><br><span class="line"><span class="actionscript">       nameList = [<span class="string">"Lily"</span>,<span class="string">"Lucy"</span>,<span class="string">"Tom"</span>,<span class="string">"Lilei"</span>,<span class="string">"Why"</span>]</span></span><br><span class="line">       alert(passGame(nameList,3))</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>优先级队列的特点：</p>
<ul>
<li><ol>
<li>我们知道，普通的队列插入一个元素，数据会被放在后端，并且需要前面所有的元素都处理完成后才会处理后面的数据。</li>
</ol>
</li>
<li><ol start="2">
<li>但是优先级队列，在插入一个元素的时候，会考虑该数据的优先级</li>
</ol>
</li>
<li><ol start="3">
<li>和其他数据优先级进行比较</li>
</ol>
</li>
<li><ol start="4">
<li>比较完成后，可以得出这个元素在队列中正确的位置</li>
</ol>
</li>
<li><ol start="5">
<li>比较完成后，可以得出这个元素在队列中正确的位置</li>
</ol>
</li>
<li><ol start="6">
<li>其他处理方式和基本队列的处理方式一样。</li>
</ol>
</li>
</ul>
<p>优先级队列主要考虑的问题：</p>
<ul>
<li><ol>
<li>每个元素不再是一个数据，而且包含数据的优先级</li>
</ol>
</li>
<li><ol start="2">
<li>在添加方式上，根据优先级放入正确的位置</li>
</ol>
</li>
</ul>
<p>实现优先级队列主要有两方面需要考虑：</p>
<ul>
<li><ol>
<li>封装元素和优先级放在一起(可以封装一个新的构造函数)</li>
</ol>
</li>
<li><ol start="2">
<li>添加元素时，将新插入元素的优先级和队列中已经存在的元素优先级进行比较，以获得自己正确的位置。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法JavaScript描述</category>
      </categories>
      <tags>
        <tag>数据结构与算法JavaScript描述</tag>
      </tags>
  </entry>
  <entry>
    <title>块级作用域绑定</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>变量声明的工作方式历来是JS编程中最微妙的部分之一。在大多数类C语言中，变量（或绑定）总是在它被声明的地方创建。然而JS就不是这样，变量实际创建的位置取决于你如何声明它，而ES6提供了额外选择以便你能更轻易地控制变量的作用域。</p>
<h2 id="var声明与变量提升"><a href="#var声明与变量提升" class="headerlink" title="var声明与变量提升"></a>var声明与变量提升</h2><p>使用var关键字声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部），这种方式就是变量提升。<br>如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = <span class="string">"blue"</span>;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不太熟悉 JS ，或许会认为仅当 condition 的值为 true 时，变量 value 才会被创建。但实际上，value 无论如何都会被创建。 JS 引擎在后台对 getValue 函数进行了调整，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        value = <span class="string">"blue"</span>;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>value 变量的声明被提升到了顶部，而初始化工作则保留在原处。这意味着在 else 分支内value 变量也是可访问的，此处它的值会是 undefined ，因为它并没有被初始化。</strong></p>
<h2 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h2><p>块级声明即让所声明的变量在指定块的作用域外无法被访问。块级作用域（又被称为词法作用域）在如下情况被创建：</p>
<ul>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ul>
<h3 id="let声明"><a href="#let声明" class="headerlink" title="let声明"></a>let声明</h3><p>let声明与var的语法一致，但是let声明不会被提升到当前代码块的顶部，需要手动将let声明放置到顶部，以便让变量在整个代码块内部使用。<strong>let声明会将变量的作用域限制在当前代码块中。</strong>范例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">"blue"</span>;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value 在此处不可用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// value 在此处不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h3><p><strong>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行let声明就会导致抛出错误。</strong><br>但是在嵌套的作用域内使用let声明一个同名的新变量，则不会抛出错误。范例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">40</span>;</span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>使用const语法进行声明的变量是常量，在设置完成后就不能再被改变，正因为如此，所有的const变量都需要在声明时进行初始化。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有效的常量</span></span><br><span class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 语法错误；未进行初始化</span></span><br><span class="line"><span class="keyword">const</span> name;</span><br></pre></td></tr></table></figure>

<ul>
<li>对比常量声明与let声明： 常量声明与let声明一样，都是块级声明。即常量在声明它们的语句块外部是无法访问的，并且声明也不会被提升；同样不能重复声明。</li>
<li>使用const声明对象：const声明会阻止对于变量绑定与变量自身值的修改，意味着const声明并不会阻止对变量成员的修改。如下例所示：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 工作正常</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">person = &#123;</span><br><span class="line">name: <span class="string">"Greg"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上例中，修改 person.name 是可能的，并不会抛出错误，因为该操作只修改了 person 对象的成员，而没有修改 person 的绑定值。当代码试图为 person 对象自身赋值时（这会改变变量绑定），就会导致错误。</p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>使用let或const声明的变量在达到声明处之前是无法访问的，试图访问会导致一个引用错误。</p>
<h2 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h2><h3 id="循环内的函数"><a href="#循环内的函数" class="headerlink" title="循环内的函数"></a>循环内的函数</h3><p>长期以来，var的特点是使得循环变量在循环作用域之外仍然可被访问，于是在循环内创建函数就变得很有问题。例如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func(); <span class="comment">// 输出数值 "10" 十次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>上例预期为这段代码会输出0到9的数值，但它却在同一行将数值10输出了十次。因为变量i在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对于同一变量的引用。</strong></p>
<h3 id="循环内的let声明"><a href="#循环内的let声明" class="headerlink" title="循环内的let声明"></a>循环内的let声明</h3><p>let是属于局部作用域声明，因此使用let代替var将避免上面的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func(); <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>在循环中let声明每次都创建了一个新的i变量，因此在循环内部创建的函数获得了各自的i副本，而每个i副本的值都在每次循环迭代声明变量的时候被确定了。</strong></p>
<h3 id="循环内的常量声明"><a href="#循环内的常量声明" class="headerlink" title="循环内的常量声明"></a>循环内的常量声明</h3><p>ES6中没有明确禁止在循环中使用const声明，但是它会根据循环方式的不同而有不同行为。在常规的for循环中，可以在初始化时使用const，但循环会在你试图改变该变量的值时抛出错误。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="comment">// 在一次迭代后抛出错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>const 变量在 for-in 或 for-of 循环中使用时，与 let 变量效果相同。</strong>const 能够在 for-in 与 for-of 循环内工作，是因为循环为每次迭<br>代创建了一个新的变量绑定，而不是试图去修改已绑定的变量的值</p>
<h2 id="全局块级绑定"><a href="#全局块级绑定" class="headerlink" title="全局块级绑定"></a>全局块级绑定</h2><p>在全局作用域上使用var时，会创建一个新的全局变量，并成为全局对象（在浏览器中是window）的一个属性，即使用var可能会无意覆盖一个已有的全局属性。<br>在全局作用域上使用let或const时，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。即不能使用let或const来覆盖一个全局变量，只能将其屏蔽。</p>
]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Set与Map</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/Set%E4%B8%8EMap(%E6%9C%AA%E5%AE%8C)/</url>
    <content><![CDATA[<p>JS的大部分历史时期都只存在一种集合类型，也就是数组类型（尽管有人会争论说，所有非数组的对象都是键值对的集合，它们曾被用于与数组完全不同的用途）。数组在JS 中的使用正如其他语言的数组一样，但缺少更多类型的集合导致数组也经常被当作队列和栈来使用。数组只使用了数值型的索引，而如果非数值型的索引是有必要的，开发者便会使用非数组的对象，这种技巧引出了非数组对象的定制实现。即Set与Map。<br><strong>Set是不包含重复值的列表。</strong>你一般不会像对待数组那样来访问Set中的某个项；相反更常见的是，只在<code>Set</code>中检查某个值是否存在。<strong>Map则是键与相对应的值的集合</strong>。因此<code>Map</code>中的每个项都存储了两块数据，通过读取所需读取的键即可检索对应的值。<code>Map</code>常被用做缓存，存储数据以便以后快速检索。由于<code>Set</code>与<code>Map</code>并不正式存在于ES5中，开发者就只能使用非数组的对象。</p>
<h2 id="ES5中的Set与Map"><a href="#ES5中的Set与Map" class="headerlink" title="ES5中的Set与Map"></a>ES5中的Set与Map</h2><p>在ES5中，开发者使用对象属性来模拟Set与Map，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = Object.create(null);</span><br><span class="line"><span class="keyword">set</span>.foo = true;</span><br><span class="line">// 检查属性的存在性</span><br><span class="line">if (<span class="keyword">set</span>.foo) &#123;</span><br><span class="line">    <span class="comment">// 一些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例中的 set 变量是一个原型为 null 的对象，确保在此对象上没有继承属性。使用对象的属性作为需要检查的唯一值在 ES5 中是很常用的方法。当一个属性被添加到 set 对象<br>时，它的值也被设为 true ，因此条件判断语句（例如本例中的 if 语句）就可以简单判断出该值是否存在。</p>
<p>使用对象模拟 Set 与模拟 Map 之间唯一真正的区别是所存储的值。例如，以下例子将对象作为 <code>Map</code> 使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">map.foo = <span class="string">"bar"</span>;</span><br><span class="line"><span class="comment">// 提取一个值</span></span><br><span class="line"><span class="keyword">let</span> value = map.foo;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>

<p>此代码将字符串值 “bar” 存储在 foo 键上。与 Set 不同， Map 多数被用来提取数据，不是仅检查键的存在性。</p>
<h2 id="变通方法的问题"><a href="#变通方法的问题" class="headerlink" title="变通方法的问题"></a>变通方法的问题</h2><p>尽管在简单情况下将对象作为Set与Map来使用都是可行的，但一旦接触到对象属性的局限性，此方式就会遇到更多麻烦。例如：由于对象属性的类型必须为字符串，你就必须保证任意两个键不能被转换为相同的字符串，研究如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">map[<span class="number">5</span>] = <span class="string">"foo"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="string">"5"</span>]); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p>本例将字符串值 “foo” 赋值到数值类型的键 5 上，而数值类型的键会在内部被转换为字符串，因此 map[“5”] 与 map[5] 实际上引用了同一个属性。当你想将数值与字符串都作为键来使用时，这种内部转换会引起问题。而若使用对象作为键，就会出现另一个问题，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>),</span><br><span class="line">    key1 = &#123;&#125;,</span><br><span class="line">    key2 = &#123;&#125;;</span><br><span class="line">map[key1] = <span class="string">"foo"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(map[key2]); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p>此处的 map[key2] 与 map[key1] 引用了同一个值。由于对象的属性只能是字符串， key1与 key2 对象就均被转换为字符串；又因为对象默认的字符串类型表达形式是 “[object<br>Object]” ， key1 与 key2 就被转换为了同一个字符串。这种行为导致的错误可能不太显眼，因为貌似合乎逻辑的假设是：键如果使用了不同对象，它们就应当是不同的键。<br>将对象转换为默认的字符串表现形式，使得对象很难被当作 Map 的键来使用（此问题同样存在于将对象作为 Set 来使用的尝试上）。</p>
<p>当键的值为假值时， Map 也遇到了自身的特殊问题。在需要布尔值的位置（例如在 if 语句内），任何假值都会被自动转换为 false 。这种转换单独说来并不是问题——只要对如何使用值的问题足够小心。例如，查看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    map.count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 是想检查 "count" 属性的存在性，还是想检查非零值？</span></span><br><span class="line"><span class="keyword">if</span> (map.count) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note into">
            <p>此例中 map.count 的用法存在歧义。此处的 if 语句是想检查 map.count 属性的存在性，还是想检查非零值？该 if 语句内的代码会被执行是因为 1 是真值。然而若 map.count 的值为 0 ，或者该属性不存在，则 if 语句内的代码都将不会被执行。在大型应用中，这类问题都是难以确认、难以调试的，这也是 ES6 新增 Set 与 Map 类型的<br>首要原因。</p>
          </div>

<h2 id="ES6的Set"><a href="#ES6的Set" class="headerlink" title="ES6的Set"></a>ES6的Set</h2><p><strong>ES6新增了 <code>Set</code> 类型，这是一种无重复值的有序列表，Set允许对它包含的数据进行快速访问，从而增加了一个追踪离散值的更有效方式。</strong></p>
<h3 id="创建Set并添加项目"><a href="#创建Set并添加项目" class="headerlink" title="创建Set并添加项目"></a>创建Set并添加项目</h3><p>Set使用 <code>new Set()</code> 来创建，而调用 <code>add()</code>方法就能向Set中添加项目，检查<code>size</code>属性还能查看其中包含有多少项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(5);</span><br><span class="line"><span class="keyword">set</span>.add("5");</span><br><span class="line">console.log(<span class="keyword">set</span>.size);  //2</span><br></pre></td></tr></table></figure>

<p><strong>Set不会使用强制类型转换来判断值是否重复。</strong>同时在Set内部的比较使用了之前介绍的Object.js()方法，来判断两个值是否相等，唯一的例外是 <strong>+0</strong> 与 <strong>-0</strong> 在Set中被判断为是相等的。<br>向<strong>Set</strong>添加多个对象，它们不会被合并为同一项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(),</span><br><span class="line">    key1 = &#123;&#125;,</span><br><span class="line">    key2 = &#123;&#125;;</span><br><span class="line"><span class="keyword">set</span>.add(key1);</span><br><span class="line"><span class="keyword">set</span>.add(key2);</span><br><span class="line">console.log(<span class="keyword">set</span>.size);    //2</span><br></pre></td></tr></table></figure>

<p>由于 <code>key1</code> 与 <code>key2</code> 并不会被转换为字符串，所以它们在这个 <code>Set</code> 内部被认为是两个不同的项（记住：如果它们被转换为字符串，那么都会等于 “[object Object]” ）</p>
<p>可以使用数组来初始化一个Set，并且 <code>Set</code> 构造器会确保不重复地使用这些值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1,2,3,5,4,5,5,5]);</span><br><span class="line">console.log(<span class="keyword">set</span>.size);    //5</span><br></pre></td></tr></table></figure>

<div class="note info">
            <p><code>set</code> 构造器实际上可以接收任意可迭代对象作为参数。能使用数组是因为它们默认就是可迭代的，<code>Set</code> 与 <code>Map</code> 也是一样。<code>Set</code> 构造器会使用迭代器来提取参数中的值。</p>
          </div>
<p>可以使用 <code>has()</code> 方法来测试某个值是否存在于 Set 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(5);</span><br><span class="line"><span class="keyword">set</span>.add("5");</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(5));   //true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(6));   //false</span><br></pre></td></tr></table></figure>

<h3 id="移除值"><a href="#移除值" class="headerlink" title="移除值"></a>移除值</h3><p>可以使用 <code>delete()</code> 方法移除 Set 中的单个值，也可以使用 <code>clear()</code>方法来将所有的值从Set中移除。以下代码展示了二者的作用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"><span class="keyword">set</span>.add(5);</span><br><span class="line"><span class="keyword">set</span>.add("5");</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(5)); // true</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.delete(5);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(5)); // false</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has("5")); // false</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 0</span><br></pre></td></tr></table></figure>

<h3 id="Set上的-forEach-方法"><a href="#Set上的-forEach-方法" class="headerlink" title="Set上的 forEach()方法"></a>Set上的 forEach()方法</h3><p><code>forEach()</code> 方法会被传递一个回调函数，该回调接受三个参数：</p>
<ol>
<li>Set中下一个位置的值；</li>
<li>与第一个参数相同的值；</li>
<li>目标Set本身。</li>
</ol>
<p>Set版本的 <code>forEach()</code> 方法与数组版本有个奇怪差异：前者传给回调函数的第一个与第二个参数是相同的。<br>具有 <code>forEach()</code> 方法的其他对象（即数组与Map）都会给回调函数传递三个参数，前两个参数都分别是下个位置的值与键（给数组使用的键是数值索引）。<br>然而Set中没有键，所以为了让Set的 <code>forEach()</code> 方法与数组及Map版本的保持一致，该回调函数的前两个参数就始终相同了。<br>示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2]);</span><br><span class="line"><span class="keyword">set</span>.forEach(function(value,key,ownerSet) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" "</span> + value);  </span><br><span class="line">    <span class="built_in">console</span>.log(ownerSet === <span class="keyword">set</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此代码在 Set 的每一项上进行迭代，并对传递给 <code>forEach()</code> 的回调函数的值进行了输出。回调函数每次执行时， <code>key</code> 与 <code>value</code> 总是相同的，同时 <code>ownerSet</code> 也始终等于 set 。此代码输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>与使用数组相同，如果想在回调函数中使用 <code>this</code>，你可以给 <code>forEach()</code> 传入一个 <code>this</code> 值作为第二个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1,2]);</span><br><span class="line">let processor = &#123;</span><br><span class="line">    output(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    process(dataSet) &#123;</span><br><span class="line">        dataSet.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.output(value);</span><br><span class="line">        &#125;, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">processor.process(<span class="keyword">set</span>);</span><br></pre></td></tr></table></figure>

<p>本例中 <code>processor.process()</code> 方法在Set上调用了 <code>forEach()</code>, 并传递了当前 <code>this</code> 作为回调函数的 <code>this</code> 值。这个传递非常必要，这样 <code>this.output()</code> 就能正确地解析到 <code>processor.output()</code> 方法。此处的 <code>forEach()</code> 的回调函数仅使用了第一个参数 <code>value</code>， 其余参数被省略了。也可以使用箭头函数来达到相同效果，而无须传入第二个参数，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1,2]);</span><br><span class="line">let processor = &#123;</span><br><span class="line">    output(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">    &#125;,</span><br><span class="line">    process(dataSet) &#123;</span><br><span class="line">        dataSet.forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.output(value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">processor.process(<span class="keyword">set</span>);</span><br></pre></td></tr></table></figure>

<p><strong>要记住，虽然 Set 能非常好地追踪值，并且 forEach() 可以让你按顺序处理每一项，但是却无法像数组那样用索引来直接访问某个值。如果你想这么做，最好的选择是将 Set 转换为数组。</strong></p>
<h3 id="将Set转换为数组"><a href="#将Set转换为数组" class="headerlink" title="将Set转换为数组"></a>将Set转换为数组</h3><p>使用扩展运算符用于将可迭代对象（例如Set）转换为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([1, 2, 3, 3, 3, 4, 5]),</span><br><span class="line">array = [...<span class="keyword">set</span>];</span><br><span class="line">console.log(array); // [1,2,3,4,5]</span><br><span class="line">console.log(<span class="keyword">set</span>);   //Set &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>当存在一个数组，想用它创建一个无重复值的新数组时，可以使用这种方法，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eliminateDuplicates</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...new <span class="built_in">Set</span>(items)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">noDuplicates = eliminateDuplicates(numbers);</span><br><span class="line"><span class="built_in">console</span>.log(noDuplicates); <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h3 id="Weak-Set"><a href="#Weak-Set" class="headerlink" title="Weak Set"></a>Weak Set</h3><p>由于 Set 类型存储对象引用的方式，它也可以被称为 Strong Set 。对象存储在 Set 的一个实例中时，实际上相当于把对象存储在变量中。只要对于 Set 实例的引用仍然存在，所存储的对象就无法被垃圾回收机制回收，从而无法释放内存。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(),</span><br><span class="line">key = &#123;&#125;;</span><br><span class="line"><span class="keyword">set</span>.add(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 1</span><br><span class="line">// 取消原始引用</span><br><span class="line">key = null;</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 1</span><br><span class="line">// 重新获得原始引用</span><br><span class="line">key = [...<span class="keyword">set</span>][0];</span><br><span class="line">console.log(key);   //&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在本例中，将 <code>key</code> 设置为 <code>null</code> 清除了对 key 对象的一个引用，但是另一个引用还存于<code>set</code> 内部。你仍然可以使用扩展运算符将 <code>Set</code> 转换为数组，然后访问数组的第一项， <code>key</code>变量就取回了原先的对象。这种结果在大部分程序中是没问题的，但有时，当其他引用消失之后若 <code>Set</code> 内部的引用也能消失，那就更好。例如，当 <code>JS</code> 代码在网页中运行，同时你想保持与 <code>DOM</code> 元素的联系，在该元素可能被其他脚本移除的情况下，你应当不希望自己的代码保留对该 <code>DOM</code> 元素的最后一个引用（这种情况被称为内存泄漏）。为了缓解这个问题， <code>ES6</code> 也包含了 <code>Weak Set</code> ，该类型只允许存储对象弱引用，而不能存储基本类型的值。对象的弱引用在它自己成为该对象的唯一引用时，不会阻止垃圾回收。</p>
<ul>
<li>创建 Weak Set</li>
</ul>
<p><code>Weak Set</code> 使用 <code>WeakSet</code> 构造器来创建，并包含 <code>add()</code> 方法、 <code>has()</code> 方法以及 <code>delete()</code>方法。以下例子使用了这三个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet(),</span><br><span class="line">    key = &#123;&#125;;</span><br><span class="line"><span class="comment">// 将对象加入 set</span></span><br><span class="line"><span class="keyword">set</span>.add(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)); // true</span><br><span class="line"><span class="keyword">set</span>.delete(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key)); // false</span><br></pre></td></tr></table></figure>

<p>使用<code>WeakSet</code>很像在使用正规的<code>Set</code>。可以在<code>WeakSet</code>上添加、移除或检查引用，也可以给构造器传入一个可迭代对象来初始化<code>WeakSet</code>的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;,</span><br><span class="line">    key2 = &#123;&#125;,</span><br><span class="line">    <span class="keyword">set</span> = new WeakSet([key1, key2]);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key1)); // true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key2)); // true</span><br></pre></td></tr></table></figure>

<p>在本例中，一个数组被传给了<code>WeakSet</code>构造器。由于该数组包含了两个对象，这些对象就被添加到了<code>WeakSet</code>中。<strong>记住：若数组中包含了非对象的值，就会抛出错误，因为<code>WeakSet</code>构造器不接受基本类型的值。</strong></p>
<p><strong><code>Set</code>类型与正规<code>Set</code>之间最大的区别是对象的弱引用。</strong>如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new WeakSet();</span><br><span class="line">    key = &#123;&#125;;</span><br><span class="line"><span class="keyword">set</span>.add(key);</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key));  //true</span><br><span class="line">key = null;</span><br><span class="line">console.log(<span class="keyword">set</span>.has(key));  //false</span><br></pre></td></tr></table></figure>

<p>除此之外，他们还有一些关键差异。即：</p>
<div class="note info">
            <ol><li>对于<code>WeakSet</code>的实例，若调用<code>add()</code>方法时传入了非对象的参数，就会抛出错误（<code>has()</code>或<code>delete()</code>则会在传入了非对象的参数时返回<code>false</code>）;</li><li><code>WeakSet</code>不可迭代，因此不能用在<code>for-of</code>循环中；</li><li><code>WeakSet</code>无法暴露处任何迭代器（例如<code>key()</code>与<code>values()</code>方法），因此没有任何编程手段可用于判断<code>WeakSet</code>的内容；</li><li><code>WeakSet</code>没有<code>forEach()</code>方法；</li><li><code>WeakSet</code>没有<code>size</code>属性。</li></ol>
          </div>

<p>**<code>WeakSet</code>看起来功能有限，而这对于正确管理内存而言是必要的，一般来说，若只想追踪对象的引用，应当使用<code>WeakSet</code>而不是正规的<code>Set</code>。</p>
<h2 id="ES6中的Map"><a href="#ES6中的Map" class="headerlink" title="ES6中的Map"></a>ES6中的Map</h2><p>ES6中的<code>Map</code>类型是键值对的有序列表，而键和值都可以是任意类型。键的比较使用的是<code>Object.is()</code>，因此你能将<code>5</code>与<code>&quot;5&quot;</code>同时作为键，因为它们类型不同。这与使用对象属性作为键的方式（指的是用对象模拟Map）截然不同，因为对象的属性会被强制转换为字符串。<br>你可以调用<code>set()</code>方法并给它传递一个键与一个关联的值，来给Map添加项；此后使用键名来调用<code>get()</code>方法便能提取对应的值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">"title"</span>, <span class="string">"Understanding ES6"</span>);</span><br><span class="line">map.set(<span class="string">"year"</span>, <span class="string">"2016"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"title"</span>));   <span class="comment">//Understanding ES6</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"year"</span>));    <span class="comment">//2016</span></span><br></pre></td></tr></table></figure>

<p>同时也可以将对象作为键，这也是从前使用对象属性来创建Map的变通方法所无法做到的。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    key1 = &#123;&#125;;</span><br><span class="line">    key2 = &#123;&#125;;</span><br><span class="line">map.set(key1, <span class="number">5</span>);</span><br><span class="line">map.set(key2, <span class="number">42</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1));  <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2));  <span class="comment">//42</span></span><br></pre></td></tr></table></figure>

<p>此处代码使用了对象<code>key1</code>与<code>key2</code>作为<code>Map</code>的键，并存储了两个不同的值。由于这些键不会被强制转换成其他形式，每个对象都被认为是唯一的。这允许你给对象关联额外数据，而无须修改对象自身。</p>
<h3 id="Map的方法"><a href="#Map的方法" class="headerlink" title="Map的方法"></a>Map的方法</h3><p>Map与Set共享了几个方法，这是有意的，允许你使用相似的方式来与Map及Set进行交互。以下三个方法在Map与Set上都存在：</p>
<div class="note info">
            <ul><li>has(key): 判断指定的键是否存在于Map中；</li><li>delete(key): 移除Map中的键以及对应的值；</li><li>clear(): 移除Map中所有的键与值。</li></ul>
          </div>

<p>Map同样拥有<code>size</code>属性，用于指明包含了多少个键值对。</p>
<h3 id="Map的初始化"><a href="#Map的初始化" class="headerlink" title="Map的初始化"></a>Map的初始化</h3><p><strong>与<code>Set</code>类似，将数组传递给<code>Map</code>构造器，以便使用数据来初始化一个<code>Map</code>。该数组中的每一项必须为数组，内部数组的首个项会作为键，第二项则为对应值。因此<code>Map</code>就被这些双项数组所填充。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>, <span class="string">"Nicholas"</span>], [<span class="string">"age"</span>, <span class="number">25</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"name"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"name"</span>)); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">"age"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">"age"</span>)); <span class="comment">// 25</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>通过构造器中的初始化，<code>&quot;name&quot;</code>与<code>&quot;age&quot;</code>这两个键就被添加到<code>map</code>变量中。虽然由数组构成的数组看起来有点奇怪，这对于准确表示键来说却是必要的：因为键允许是任意数据类型，将键存储在数组中，是确保它们在添加到Map之前不会被强制转换为其他类型的唯一方法。</p>
<h3 id="Map上的forEach方法"><a href="#Map上的forEach方法" class="headerlink" title="Map上的forEach方法"></a>Map上的forEach方法</h3><p><code>Map</code>的<code>forEach()</code>方法类似于<code>Set</code>与数组的同名方法，它接受一个能接收三个参数的回调函数：</p>
<ul>
<li><ol>
<li>Map中下个位置的值；</li>
</ol>
</li>
<li><ol start="2">
<li>该值所对应的键；</li>
</ol>
</li>
<li><ol start="3">
<li>目标Map自身。<br>回调函数的这些参数更紧密契合了数组<code>forEach()</code>方法的行为，即：第一个参数是值、第二个参数则是键（数组中的键是数值索引）。示例如下：</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">"name"</span>,<span class="string">"Nicholas"</span>], [<span class="string">"age"</span>, <span class="number">25</span>]]);</span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, ownerMap</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" "</span> + value);</span><br><span class="line">    <span class="built_in">console</span>.log(ownerMap === map);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name Nicholas</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">age <span class="number">25</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<div class="note into">
            <p>也可以给<code>forEach()</code>提供第二个参数来指定回调函数中的<code>this</code>值，其行为与<code>Set</code>版本的<code>forEach()</code>一致。</p>
          </div>

<h3 id="Weak-Map"><a href="#Weak-Map" class="headerlink" title="Weak Map"></a>Weak Map</h3><p>Weak Map对Map而言，就像Weak Set对Set一样：Weak版本都是存储对象弱引用的方式。在<code>Weak Map</code>中，所有的键都必须是对象（尝试使用非对象的键会抛出错误），而且这<br>些对象都是弱引用，不会干扰垃圾回收。当<code>Weak Map</code>中的键在<code>Weak Map</code>之外不存在引用时，该键值对会被移除。</p>
<div class="note into">
            <p>必须注意的是，Weak Map的键才是弱引用，而值不是，在Weak Map的值中存储对象会阻止垃圾回收，即使该对象的其他引用已全部被移除。</p>
          </div>

<h3 id="使用Weak-Map"><a href="#使用Weak-Map" class="headerlink" title="使用Weak Map"></a>使用Weak Map</h3><p>ES6的<code>Weak Map</code>类型是键值对的无序列表，其中键必须是非空的对象，值则允许是任意类型。<code>Weak Map</code>的接口与<code>Map</code>非常相似，都使用<code>set()</code>与<code>get()</code>方法来分别添加与提取数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6兼容性</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/ES6%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>提供两个关于 ES5 与 ES6 兼容的浏览器等的表。</p>
<div class="note info">
            <p><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a><br><a href="http://kangax.github.io/compat-table/es5/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es5/</a></p>
          </div>

<p><strong>ES6也叫ES2015,目前支持的浏览器版本有IE10+、Chrome、FireFox、移动端、NodeJS。</strong><br>对于更早版本的浏览器若想实现兼容性问题，需要进行编译或者转换，有以下两种方式。</p>
<ul>
<li><strong>在线编译</strong>：容易造成用户刷新页面时出现卡顿现象，用户体验不太好</li>
<li><strong>提前转换</strong>：用的较多</li>
</ul>
<p>目前使用较多的提前转换方式是使用<code>babel</code>库，<code>babel</code>是一个<code>Javascript编译器</code>，是目前前端开发最常用的工具之一，主要用于将 <code>ECMAScript 2015+</code> 版本的代码转换为向后兼容的 <code>JavaScript</code> 语法，以便能够运行在当前和旧版本的浏览器或其他环境。比如在代码中使用了ES6的箭头函数，这种写法在IE里面是会报错的，为了让代码能在IE中运行，就需要将代码编译成IE支持的写法，这就是<code>babel</code>的工作。</p>
]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串与正则表达式</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>关于字符串与正则表达式，这里不介绍太多细致内容，本章整理的不是很全面。</strong></p>
<h2 id="识别子字符串的方法"><a href="#识别子字符串的方法" class="headerlink" title="识别子字符串的方法"></a>识别子字符串的方法</h2><p>自从 JS 引入了 indexOf() 方法，开发者们就使用它来识别字符串是否存在于其它字符串中。ES6 包含了以下三个方法来满足这类需求：</p>
<div class="note info">
            <ul><li><strong>includes()方法</strong>：在给定文本存在于字符串中的任意位置时会返回 true，否则返回false；</li><li><strong>startsWith()方法</strong>：在给定文本出现在字符串起始处时返回 true ，否则返回 false；</li><li><strong>endsWith()方法</strong>：在给定文本出现在字符串结尾处时返回 true，否则返回 false。</li></ul>
          </div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"Hello"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"!"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"world!"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"x"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.startsWith(<span class="string">"o"</span>, <span class="number">4</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.endsWith(<span class="string">"o"</span>, <span class="number">8</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(msg.includes(<span class="string">"o"</span>, <span class="number">8</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="repeat-方法"><a href="#repeat-方法" class="headerlink" title="repeat()方法"></a>repeat()方法</h2><p>ES6 还为字符串添加了一个 repeat() 方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"x"</span>.repeat(<span class="number">3</span>));  <span class="comment">// "xxx"</span></span><br></pre></td></tr></table></figure>

<p>此方法比相同目的的其余方法更加方便，在操纵文本时特别有用，尤其是在需要产生缩进的代码格式化工具中，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// indent 使用了一定数量的空格</span></span><br><span class="line"><span class="keyword">var</span> indent = <span class="string">" "</span>.repeat(<span class="number">4</span>),</span><br><span class="line">indentLevel = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每当你增加缩进</span></span><br><span class="line"><span class="keyword">var</span> newIndent = indent.repeat(++indentLevel);</span><br></pre></td></tr></table></figure>

<p><strong>上面的代码在第一次调用<code>repeat()</code>创建了一个包含四个空格的字符串，而<code>indentLevel</code>变量会持续追踪缩进的级别，此后，你可以通过增加<code>indentLevel</code>的值来调用`repeat()方法，便可以改变空格数量。</strong></p>
<h2 id="正则表达式的其他改动"><a href="#正则表达式的其他改动" class="headerlink" title="正则表达式的其他改动"></a>正则表达式的其他改动</h2><p>正则表达式是在JS中操作字符串的重要方面之一，与该语言的其他方面相似，它在以往的版本中并未有太多改变。不过，为了配合字符串的更新，ES6也对正则表达式进行了一些改进。</p>
<h3 id="正则表达式-y-标志"><a href="#正则表达式-y-标志" class="headerlink" title="正则表达式 y 标志"></a>正则表达式 y 标志</h3><p><code>y</code>标志影响正则表达式搜索时的粘连（<code>sticky</code>）属性，它表示从正则表达式的<code>lastIndex</code>属性值的位置开始检索字符串中的匹配字符，如果在该位置没有匹配成功，那么正则表达式将停止检索。看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</span><br><span class="line">pattern = <span class="regexp">/hello\d\s?/</span>,</span><br><span class="line">result = pattern.exec(text),</span><br><span class="line">globalPattern = <span class="regexp">/hello\d\s?/g</span>,</span><br><span class="line">globalResult = globalPattern.exec(text),</span><br><span class="line">stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line">pattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">globalPattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">stickyPattern.lastIndex = <span class="number">1</span>;</span><br><span class="line">result = pattern.exec(text);</span><br><span class="line">globalResult = globalPattern.exec(text);</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]); <span class="comment">// "hello2 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]); <span class="comment">// Error! stickyResult is null</span></span><br></pre></td></tr></table></figure>

<p>此例中有三个正则表达式： pattern 中的表达式没有使用任何标志， globalPattern 使用了<code>g</code> 标志， stickyPattern 则使用了 <code>y</code> 标志。对 console.log() 的第一次调用，三个正则表达式分别都返回了 “hello1 “ ，此字符串尾部有个空格。<br>此后，三个模式的 lastIndex 属性全部被更改为 1 ，表示三个模式的正则表达式都应当从第二个字符开始尝试匹配。不使用任何标志的正则表达式完全忽略了对于 lastIndex 的更改，仍然毫无意外地匹配了 “hello1 “ ；而使用 g 标志的正则表达式继续匹配了 “hello2 “ ，因为它从第二个字符（ “e” ）开始，持续向着字符串尾部方向搜索；粘连的正则表达式则在第二个字符处没有匹配成功，因此 stickyResult 的值是 null 。<br>一旦匹配操作成功，粘连标志就会将匹配结果之后的那个字符的索引值保存在 lastIndex中；若匹配未成功，那么 lastIndex 的值将重置为 0 。全局标志的行为与其相同，如下所<br>示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">"hello1 hello2 hello3"</span>,</span><br><span class="line">pattern = <span class="regexp">/hello\d\s?/</span>,</span><br><span class="line">result = pattern.exec(text),</span><br><span class="line">globalPattern = <span class="regexp">/hello\d\s?/g</span>,</span><br><span class="line">globalResult = globalPattern.exec(text),</span><br><span class="line">stickyPattern = <span class="regexp">/hello\d\s?/y</span>,</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex); <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex); <span class="comment">// 7</span></span><br><span class="line">result = pattern.exec(text);</span><br><span class="line">globalResult = globalPattern.exec(text);</span><br><span class="line">stickyResult = stickyPattern.exec(text);</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]); <span class="comment">// "hello1 "</span></span><br><span class="line"><span class="built_in">console</span>.log(globalResult[<span class="number">0</span>]); <span class="comment">// "hello2 "</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyResult[<span class="number">0</span>]); <span class="comment">// "hello2 "</span></span><br><span class="line"><span class="built_in">console</span>.log(pattern.lastIndex); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(globalPattern.lastIndex); <span class="comment">// 14</span></span><br><span class="line"><span class="built_in">console</span>.log(stickyPattern.lastIndex); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<p>对于 stickyPattern 和 globalPattern 模式变量来说，第一次调用之后 lastIndex 的值均被更改为 7 ，而第二次则均被改为 14 。</p>
<div class="note info">
            <p><strong>有两个关于粘连标志的微妙细节需要牢记：</strong></p><ul><li>只有调用正则表达式对象上的方法（例如 exec() 与 test() 方法）， lastIndex 属性才会生效。而将正则表达式作为参数传递给字符串上的方法（例如 match() ），并不会<br>体现粘连特性。</li><li>当使用 ^ 字符来匹配字符串的起始处时，粘连的正则表达式只会匹配字符串的起始处（或者在多行模式下匹配行首）。当 lastIndex 为 0 时， ^ 不会让粘连的正则表达式<br>与非粘连的有任何区别；而当 lastIndex 在单行模式下不对应整个字符串起始处，或者当它在多行模式下不对应行首时，粘连的正则表达式永远不会匹配成功。</li></ul>
          </div>

<p><strong>和正则表达式其他标志相同，你可以根据一个属性来检测 y 标志是否存在。此时你需要检查的是 sticky 属性，如下：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/hello\d/y</span>;</span><br><span class="line"><span class="built_in">console</span>.log(pattern.sticky); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="带参数默认值的函数"><a href="#带参数默认值的函数" class="headerlink" title="带参数默认值的函数"></a>带参数默认值的函数</h2><h3 id="ES6中的参数默认值"><a href="#ES6中的参数默认值" class="headerlink" title="ES6中的参数默认值"></a>ES6中的参数默认值</h3><p>JS函数可以接受任意数量的参数，而无视函数声明处的参数数量。这样就会让你定义的函数可以使用不同的参数数量来调用，调用时未提供的参数经常会使用默认值来代替。<br>ES5为参数提供默认值比较麻烦，需要采用或语法（当变量为0时还有可能会导致错误）<br><strong>ES6能很容易地为参数提供默认值，它使用了初始化形式，以便在参数未被正式传递进来时使用。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">url, timeout = <span class="number">2000</span>, callback = function(</span>) </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 函数的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数只要求第一个参数始终要被传递。其余两个参数则都有默认值，这使得函数体更为小巧，因为不需要再添加更多代码来检查缺失的参数值<br>如果使用全部三个参数来调用 makeRequest() ，那么默认值将不会被使用，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用默认的 timeout 与 callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>);</span><br><span class="line"><span class="comment">//  使用默认的 callback</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>);</span><br><span class="line"><span class="comment">//  不使用默认值</span></span><br><span class="line">makeRequest(<span class="string">"/foo"</span>, <span class="number">500</span>, <span class="function"><span class="keyword">function</span>(<span class="params">body</span>) </span>&#123;</span><br><span class="line">    doSomething(body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>在本例中，只有在未传递第二个参数、或明确将第二个参数值指定为 undefined 时，timeout 的默认值才会被使用。</strong></p>
<h3 id="参数默认值如何影响arguments对象"><a href="#参数默认值如何影响arguments对象" class="headerlink" title="参数默认值如何影响arguments对象"></a>参数默认值如何影响arguments对象</h3><p>arguments对象会在使用参数默认值时有不同的表现。在ES5的非严格模式下，arguments对象会反映出具名参数的变化，如下面的代码所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">    first = <span class="string">"c"</span>;</span><br><span class="line">    second = <span class="string">"d"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>但是在ES5的严格模式下，关于 arguments 对象的这种混乱情况被消除了，它不再反映出具名参数的变化。</strong>在严格模式下重新使用上例中的函数，结果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>在使用ES6参数默认值的函数中，arguments对象的表现总是会与ES5的严格模式一致，无论此时函数是否明确运行在严格模式下。<strong>参数默认值的存在触发了arguments对象与具名参数的分离。</strong>示例如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second = <span class="string">"b"</span></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line"><span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">first = <span class="string">"c"</span>;</span><br><span class="line">second = <span class="string">"d"</span></span><br><span class="line"><span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="参数默认值表达式"><a href="#参数默认值表达式" class="headerlink" title="参数默认值表达式"></a>参数默认值表达式</h3><p>参数默认值最有意思的特性就是默认值并不要求一定时基本类型的值。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = getValue(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>

<p>此处若未提供第二个参数， getValue() 函数就会被调用以获取正确的默认值。需要注意的是，仅在调用 add() 函数而未提供第二个参数时， getValue() 函数才会被调用，而在<br>getValue() 的函数声明初次被解析时并不会进行调用。这意味着 getValue() 函数若被写为可变的，则它有可能会返回可变的值</p>
<p><strong>也可以将前面的参数作为后面参数的默认值。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first, second = first</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="参数默认值的暂时性死区"><a href="#参数默认值的暂时性死区" class="headerlink" title="参数默认值的暂时性死区"></a>参数默认值的暂时性死区</h3><p>看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>, <span class="number">1</span>)); <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure>

<p>本例中调用add(1, 1)与add(undefined, 1)，对应着以下的后台代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS 调用 add(1, 1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// JS 调用 add(1) 可表示为</span></span><br><span class="line"><span class="keyword">let</span> first = second;</span><br><span class="line"><span class="keyword">let</span> second = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>本例中调用 add(undefined, 1) 抛出了错误，是因为在 first 被初始化时 second 尚未被初始化。此处的 second 存在于暂时性死区内，对于 second 的引用就抛出了错误。</strong></p>
<h2 id="使用不具名参数"><a href="#使用不具名参数" class="headerlink" title="使用不具名参数"></a>使用不具名参数</h2><h3 id="ES5中的不具名参数"><a href="#ES5中的不具名参数" class="headerlink" title="ES5中的不具名参数"></a>ES5中的不具名参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(object);  <span class="comment">// &#123; title: 'Understanding ES6', author: 'Nicholas C. Zakas', year: 2015 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);   <span class="comment">// [Arguments] &#123;'0':&#123; title: 'Understanding ES6',author: 'Nicholas C. Zakas',year: 2015 &#125;,'1': 'title','2': 'author','3': 'year' &#125;</span></span><br><span class="line">    <span class="comment">//从第二个参数开始处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[<span class="built_in">arguments</span>[i]] = object[<span class="built_in">arguments</span>[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> book = &#123;</span><br><span class="line">        title: <span class="string">"Understanding ES6"</span>,</span><br><span class="line">        author: <span class="string">"Nicholas C. Zakas"</span>,</span><br><span class="line">        year: <span class="number">2015</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">let</span> bookData = pick(book, <span class="string">"title"</span>, <span class="string">"author"</span>, <span class="string">"year"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bookData.title);  <span class="comment">//"Understanding ES6"</span></span><br><span class="line"><span class="built_in">console</span>.log(bookData.author); <span class="comment">// "Nicholas C. Zakas"</span></span><br><span class="line"><span class="built_in">console</span>.log(bookData.year); <span class="comment">// 2015</span></span><br></pre></td></tr></table></figure>

<p>这个 pick() 函数有两点需要注意。首先，完全看不出该函数能够处理多个参数，你能为其再多定义几个参数，但依然不足以标明该函数能处理任意数量的参数。其次，由于第一个参<br>数被命名并被直接使用，当你寻找需要复制的属性时，就必须从 arguments 对象索引位置 1开始处理而不是从位置 0 。要记住使用 arguments 的适当索引值并不一定困难，但毕竟多了一件需要留意的事。<br><strong>ES6 引入了剩余参数以便解决这个问题。</strong></p>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数由三个点（…）与一个紧跟着的具名参数指定，它会是包含传递给函数的剩余参数的一个数组。pick()函数可以像下面这样用剩余参数来重写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...keys</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = keys.length; i &lt; len; i++) &#123;</span><br><span class="line">        result[keys[i]] = object[keys[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的函数中，keys是一个包含所有在object之后的参数的剩余参数（这与包含所有参数的arguments不同，后者会连第一个参数都包含在内）。即我们可以对keys从头到尾进行迭代，而不需要有所顾虑。</p>
<p><strong>剩余参数的限制条件：一是函数只能有一个剩余参数，并且它必须被放在最后；二是剩余参数不能在对象字面量的setter属性中使用。</strong></p>
<p><strong>剩余参数如何影响arguments对象：arguments 对象在函数被调用时反映了传入的参数，与剩余参数能协同工作</strong>，就像如下程序所演示的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArgs</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args.length);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="built_in">console</span>.log(args[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(args[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">checkArgs(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure>

<p>调用 checkArgs() 输出了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">a a</span><br><span class="line">b b</span><br></pre></td></tr></table></figure>

<p><strong>arguments 对象总能正确反映被传入函数的参数，而无视剩余参数的使用。</strong></p>
<h2 id="函数构造器的增强能力"><a href="#函数构造器的增强能力" class="headerlink" title="函数构造器的增强能力"></a>函数构造器的增强能力</h2><p>Function 构造器允许你动态创建一个新函数，但在 JS 中并不常用。传给该构造器的参数都是字符串，它们就是目标函数的参数与函数体，这里有个范例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"return first + second"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>与剩余参数关联最密切的就是扩展运算符。剩余参数允许你把多个独立的参数合并到一个数组中；而<strong>扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数</strong>。<br>比如下面的Math.max() 方法，它能接收任意数量的参数，并会返回其中的最大值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="number">25</span>,</span><br><span class="line">    value2 = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(value1, value2)); <span class="comment">//50</span></span><br></pre></td></tr></table></figure>

<p>但是Math.max() 方法并不允许你传入一个数组，因此无法判断一个数组中的值。ES6 的扩展运算符令这种情况变得简单。可以像使用剩余参数那样在该数组前添加 … ，并直接将其传递给 Math.max() 。 JS 引擎将会将该数组分割为独立参数并把它们传递进去，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">25</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">100</span>]</span><br><span class="line"><span class="comment">//等价于 console.log(Math.max(25, 50, 75, 100));</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>也可以将与其他参数混用，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">-25</span>, <span class="number">-50</span>, <span class="number">-75</span>, <span class="number">-100</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...values, <span class="number">0</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6的名称属性"><a href="#ES6的名称属性" class="headerlink" title="ES6的名称属性"></a>ES6的名称属性</h2><p>ES6 给所有函数添加了name属性。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doSomethingElse</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="keyword">get</span> firstName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Nicholas"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.name); <span class="comment">// "doSomethingElse"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name); <span class="comment">// "sayName"</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(person, <span class="string">"firstName"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor.get.name); <span class="comment">// "get firstName"</span></span><br></pre></td></tr></table></figure>

<p>本例中的 doSomething.name 的值是 “doSomethingElse” ，因为该函数表达式自己拥有一个名称，并且此名称的优先级要高于赋值目标的变量名。 person.sayName() 的 name 属性值是”sayName” ，正如对象字面量指定的那样。类似的， person.firstName 实际是个 getter 函数，因此它的名称是 “get firstName” ，以标明它的特征；同样， setter 函数也会带有”set” 的前缀（ getter 与 setter 函数都必须用 Object.getOwnPropertyDescriptor() 来检索）。</p>
<p>函数名称还有另外两个特殊情况。使用 bind() 创建的函数会在名称属性值之前带有”bound” 前缀；而使用 Function 构造器创建的函数，其名称属性则会有 “anonymous” 前缀，正如此例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.bind().name); <span class="comment">// "bound doSomething"</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Function</span>()).name); <span class="comment">// "anonymous"</span></span><br></pre></td></tr></table></figure>

<h2 id="明确函数的双重用途"><a href="#明确函数的双重用途" class="headerlink" title="明确函数的双重用途"></a>明确函数的双重用途</h2><p>在ES5以及更早的版本中，函数根据是否使用new来调用而有双重用途，当使用new时，函数内部的this是一个新对象，并作为函数的返回值。如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// "[Object object]"</span></span><br><span class="line"><span class="built_in">console</span>.log(notAPerson); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>

<p>JS 为函数提供了两个不同的内部方法： [[Call]] 与 [[Construct]] 。当函数未使用 new进行调用时， [[call]] 方法会被执行，运行的是代码中显示的函数体。而当函数使用 new进行调用时， [[Construct]] 方法则会被执行，负责创建一个被称为新目标的新的对象，并且使用该新目标作为 this 去执行函数体。拥有 [[Construct]] 方法的函数被称为构造器。</p>
<h3 id="在ES5中判断函数如何被使用"><a href="#在ES5中判断函数如何被使用" class="headerlink" title="在ES5中判断函数如何被使用"></a>在ES5中判断函数如何被使用</h3><p>在 ES5 中判断函数是不是使用了 new 来调用（即作为构造器），最流行的方式是使用instanceof。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person(<span class="string">"Nicholas"</span>); <span class="comment">// 抛出错误</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>); <span class="comment">// 奏效了！</span></span><br></pre></td></tr></table></figure>

<p>此处对 this 值进行了检查，来判断其是否为构造器的一个实例：若是，正常继续执行；否则抛出错误。这能奏效是因为 [[Construct]] 方法创建了 Person 的一个新实例并将其赋值给 this 。可惜的是，该方法并不绝对可靠，因为在不使用 new 的情况下 this 仍然可能是 Person 的实例.<br><strong>调用 Person.call() 并将 person 变量作为第一个参数传入，这意味着将 Person 内部的this 设置为了 person 。对于该函数来说，没有任何方法能将这种方式与使用 new 调用区分开来。</strong></p>
<h3 id="new-target元属性"><a href="#new-target元属性" class="headerlink" title="new.target元属性"></a>new.target元属性</h3><p>元属性指的是“非对象”（例如 new上的一个属性），并提供关联到它的目标的附加信息。<strong>当函数的 [[Construct]] 方法被调用时， new.target 会被填入 new 运算符的作用目标，该目标通常是新创建的对象实例的构造器，并且会成为函数体内部的 this 值。而若 [[Call]] 被执行， new.target 的值则会是undefined。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">new</span>.target !== <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">"Michael"</span>); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>

<p>使用 new.target 而非 this instanceof Person ， Person 构造器会在未使用 new 调用时正确地抛出错误。也可以检查 new.target 是否被使用特定构造器进行了调用，例如以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name; <span class="comment">// 使用 new</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"You must use new with Person."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AnotherPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="keyword">new</span> AnotherPerson(<span class="string">"Nicholas"</span>); <span class="comment">// 出错！</span></span><br></pre></td></tr></table></figure>

<h2 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h2><p>ES6中可以使用块级函数。块级函数与let函数表达式相似，在执行流跳出定义所在的代码块之后，函数定义就会被移除。关键区别在于：块级函数会被提升到所在代码块的顶部；而使用let的函数表达式则不会。正如以下范例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "function"</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> doAnotherSomething);  <span class="comment">//抛出错误</span></span><br><span class="line">    <span class="keyword">let</span> doAnotherSomething = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    doSomething();</span><br><span class="line">    doAnotherSomething();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>

<p>此处代码在 typeof doAnotherSomething 被执行时中断了，因为 let 声明尚未被执行，将doSomething() 放入了暂时性死区。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数与传统的JS函数有以下不同：</p>
<ul>
<li>没有this、super、arguments，也没有 new.target 绑定： this 、 super 、arguments 、以及函数内部的 new.target 的值由所在的、最靠近的非箭头函数来决定。</li>
<li>不能被使用 new 调用： 箭头函数没有 [[Construct]] 方法，因此不能被用为构造函数，使用 new 调用箭头函数会抛出错误。</li>
<li>没有原型： 既然不能对箭头函数使用 new ，那么它也不需要原型，也就是没有prototype 属性。</li>
<li>不能更改 this ： this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。</li>
<li>没有 arguments 对象： 既然箭头函数没有 arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。</li>
<li>不允许重复的具名参数： 箭头函数不允许拥有重复的具名参数，无论是否在严格模式下；而相对来说，传统函数只有在严格模式下才禁止这种重复。</li>
</ul>
<h3 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h3><p>接收单个参数并返回它本身的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"><span class="comment">//有效等价于：</span></span><br><span class="line"><span class="keyword">var</span> reflect = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>传入多个参数，只运行一条语句的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">//有效等价于：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>传入多个参数且函数体包含多条语句的语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  有效等价于：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建空函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//  有效等价于：</span></span><br><span class="line"><span class="keyword">var</span> doNothing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>返回对象字面量语法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br><span class="line"><span class="comment">//  有效等价于：</span></span><br><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        id: id,</span><br><span class="line">        name: <span class="string">"Temp"</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="创建立即调用函数表达式"><a href="#创建立即调用函数表达式" class="headerlink" title="创建立即调用函数表达式"></a>创建立即调用函数表达式</h3><p>JS中使用函数的一种流行方式是创建立即调用函数表达式（IIFE），IIFE允许你定义一个匿名函数并在未保存引用的情况下立刻调用它。箭头函数同样能实现创建立即函数表达式的功能。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数表达式</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="function">(<span class="params">(name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// "Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有效的JS函数表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;(<span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.getName()); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<h3 id="没有this绑定"><a href="#没有this绑定" class="headerlink" title="没有this绑定"></a>没有this绑定</h3><p>JS最常见的错误领域之一就是在函数内的this绑定。由于一个函数内部的this值可以被改变，这取决于调用函数时的上下文，因此完全可能错误地影响了一个对象，尽管本意是要修改另一个对象。用箭头函数不会出现这个问题，箭头函数没有this绑定，即箭头函数内部的this值只能通过查找作用域链来确定，如果箭头函数被包含在一个非箭头函数内，那么this值就会与函数的相等；否则，this值就是全局对象。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> PageHandler = &#123;</span><br><span class="line">    id: <span class="string">"123456"</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</span><br><span class="line">        event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上例中的事件处理函数是一个调用this.doSomething()的箭头函数，它的this值与init()方法的相同。</p>
<h3 id="箭头函数与数组"><a href="#箭头函数与数组" class="headerlink" title="箭头函数与数组"></a>箭头函数与数组</h3><p>能使用回调函数的数组方法（例如sort()、map()与reduce()方法），都能从箭头函数的简洁语法中获得收益，它将看似复杂的需求转换为简单的代码。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>

<h3 id="没有arguments绑定"><a href="#没有arguments绑定" class="headerlink" title="没有arguments绑定"></a>没有arguments绑定</h3><p>尽管箭头函数没有自己的arguments对象，但仍然能访问包含它的函数的arguments对象。无论此后箭头函数在何处执行，该对象都是可用的。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArrowFunctionReturningFirstArg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrowFunction = createArrowFunctionReturningFirstArg(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrowFunction()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="识别箭头函数"><a href="#识别箭头函数" class="headerlink" title="识别箭头函数"></a>识别箭头函数</h3><p>尽管语法不同，箭头函数依然属于函数，并能被照常识别。例如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> comparator = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> comparator); <span class="comment">// "function"</span></span><br><span class="line"><span class="built_in">console</span>.log(comparator <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>console.log()的输出揭示了typeof与instanceof在作用于箭头函数时的行为，与作用在其他函数上一样。</strong><br>同理，也可以对箭头函数使用call()、apply()、与bind()方法，但是函数的this绑定不受影响。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="built_in">console</span>.log(sum.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> boundSum = sum.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(boundSum()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上例中的函数的作用域为null,没设定，是sum的作用域。</p>
<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用指的是调用函数的语句是另一个函数的最后语句。在ES5引擎中实现的尾调用，其处理就像其他函数一样：一个新的栈帧被创建并推到调用栈之上，用于表示该次函数调用，但是这也意味着之前每个栈帧都被保留在内存中，当调用栈太大时会出问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doSomethingElse(); <span class="comment">// 尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6在严格模式下力图为特定尾调用减少调用栈的大小（非严格模式的尾调用则保持不变）。当满足以下条件时，尾调用优化会清除栈帧并再次利用它，而不是为尾调用创建新的栈帧：</p>
<ul>
<li>尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）。</li>
<li>进行尾调用的函数在尾调用返回结果后不能做额外操作。</li>
<li>尾调用的结果作为当前函数的返回值。</li>
</ul>
]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>解构：更方便的数据访问</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E8%A7%A3%E6%9E%84/</url>
    <content><![CDATA[<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构语法在赋值语句的左侧使用了对象字面量，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;type, name&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type);    <span class="comment">//"Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">//"foo"</span></span><br></pre></td></tr></table></figure>

<p>在此代码中，<code>node.type</code> 的值被存储到 <code>type</code> 本地变量中， <code>node.name</code> 的值则存储到<code>name</code>变量中, <code>type</code> 与 <code>name</code> 标识符既声明了本地变量，也读取了对象的相应属性值。</p>
<p>**不要遗忘初始化器：当使用解构来配合<code>var</code> <code>let</code> 或 <code>const</code>来声明变量时，必须提供初始化器（即等号右边的值）。下面的代码都会因为没有提供初始化器而抛出错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">var</span> &#123; type, name &#125;;</span><br><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">let</span> &#123; type, name &#125;;</span><br><span class="line"><span class="comment">// 语法错误！</span></span><br><span class="line"><span class="keyword">const</span> &#123; type, name &#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>const</code> 总是要求有初始化器，即使没有使用解构的变量；而 <code>var</code> 与 <code>let</code> 则仅在使用解构时才作此要求。</strong></p>
<h3 id="对象解构赋值"><a href="#对象解构赋值" class="headerlink" title="对象解构赋值"></a>对象解构赋值</h3><p>在变量声明之后也可以进行解构赋值。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;,</span><br><span class="line">type = <span class="string">"Literal"</span>,</span><br><span class="line">name = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 使用解构来分配不同的值</span></span><br><span class="line">(&#123; type, name &#125; = node);</span><br><span class="line"><span class="built_in">console</span>.log(type); <span class="comment">// "Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：必须用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符（即等号）左侧出现。圆括号标示了里面的花括号并不是块语句，而应该被解释为表达式，从而允许完成赋值操作。</strong></p>
<h3 id="对象解构默认值"><a href="#对象解构默认值" class="headerlink" title="对象解构默认值"></a>对象解构默认值</h3><p>当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为<code>undefined</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;type, name, value&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type);    <span class="comment">//"Indentifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">//"foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value);   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p>你可以选择性地定义一个默认值，以便在指定属性不存在时使用该值。若要这么做，需要在属性名后面添加一个等号并指定默认值，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;type, name, value=<span class="string">"12"</span>&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(type);    <span class="comment">//"Indentifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(name);    <span class="comment">//"foo"</span></span><br><span class="line"><span class="built_in">console</span>.log(value);   <span class="comment">//"12"</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值给不同的本地变量名"><a href="#赋值给不同的本地变量名" class="headerlink" title="赋值给不同的本地变量名"></a>赋值给不同的本地变量名</h3><p><strong>ES6</strong>有一个扩展语法，允许你在给本地变量赋值时使用一个不同的名称，而且该语法看上去就像是使用对象字面量的非简写的属性初始化，看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: localType, <span class="attr">name</span>: localName&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localType);    <span class="comment">//"Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName);    <span class="comment">//"foo"</span></span><br></pre></td></tr></table></figure>

<p>也可以给变量别名添加默认值，依然是在本地变量名称后添加等号与默认值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Identifier"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: localType, <span class="attr">name</span>: localName=<span class="string">"bar"</span>&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(localType);    <span class="comment">//"Identifier"</span></span><br><span class="line"><span class="built_in">console</span>.log(localName);    <span class="comment">//"bar"</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套的对象解构"><a href="#嵌套的对象解构" class="headerlink" title="嵌套的对象解构"></a>嵌套的对象解构</h3><p>使用类似于对象字面量的语法，可以深入到嵌套的对象结构中去提取你想要的数据。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line:<span class="number">1</span>,</span><br><span class="line">            column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;start&#125;&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(start.line);   <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>在对象的嵌套解构中同样能为本地变量使用不同的名称</strong>，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line:<span class="number">1</span>,</span><br><span class="line">            column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 提取 node.loc.start</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;<span class="attr">start</span>: localStart&#125;&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(localStart.line);   <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(localStart.column); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>数组解构的语法看起来与对象解构非常相似，只是将对象字面量替换成了数组字面量。数组解构时，解构作用在数组内部的位置上，而不是作用在对象的具名属性上，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, secondColor ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p>此处数组解构从<code>colors</code>数组中取出了<code>&quot;red&quot;</code> 与 <code>&quot;green&quot;</code> ，并将它们赋值给 <code>fristColor</code>与 <code>secondColor</code> 变量。这些值被选择，是由于它们在数组中的位置，实际的变量名称是任意的（与位置无关）。任何没有在解构模式中明确指定的项都会被忽略。记住，<strong>数组本身并没有以任何方式被改变</strong>。<br>在解构模式中可以忽略一些项，并且只给感兴趣的项提供变量名，例如：若只想获取数组中的第三个元素，那么不必给前两项提供变量名，以下展示了这种方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ , , thirdColor ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(thirdColor); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>

<h3 id="数组解构赋值"><a href="#数组解构赋值" class="headerlink" title="数组解构赋值"></a>数组解构赋值</h3><p><strong>可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号内</strong>，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ],</span><br><span class="line">firstColor = <span class="string">"black"</span>,</span><br><span class="line">secondColor = <span class="string">"purple"</span>;</span><br><span class="line">[firstColor, secondColor] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p><strong>数组解构赋值有一个非常独特的用例，能轻易地互换两个变量的值。互换变量值在排序算法中十分常用。</strong>如下例所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ES6 中互换值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>本例中的数组解构赋值看起来如同镜像。赋值语句左侧（即等号之前）的解构模式正如其他数组解构的范例，右侧则是为了互换而临时创建的数组字面量。 b 与 a 的值分别被复制到<br>临时数组的第一个与第二个位置，并对该数组进行解构，结果两个变量就互换了它们的值。<br><strong>与对象解构赋值相同，若等号右侧的计算结果为 null 或 undefined ，那么数组解构赋值表达式也会抛出错误。</strong></p>
<h3 id="数组解构默认值"><a href="#数组解构默认值" class="headerlink" title="数组解构默认值"></a>数组解构默认值</h3><p><strong>数组解构赋值同样允许在数组任意位置指定默认值，当指定位置的项不存在、或其值为<code>undefined</code>, 那么该默认值就会被使用。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, secondColor = <span class="string">"green"</span> ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<p>此代码的<code>colors</code>数组只有一个项，因此没有能与<code>secondColor</code>匹配的项，又由于此处有个默认值，<code>secondColor</code>的值就被设置为<code>&quot;green&quot;</code>，而不是<code>undefined</code>。</p>
<h3 id="嵌套的解构"><a href="#嵌套的解构" class="headerlink" title="嵌套的解构"></a>嵌套的解构</h3><p>与解构嵌套的对象相似，可以用类似的方式来解构嵌套的数组。在整个解构模式中插入另一个数组模式，解构数组就会下行到嵌套的数组中，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</span><br><span class="line"><span class="comment">// 随后</span></span><br><span class="line"><span class="keyword">let</span> [ firstColor, [ secondColor ] ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(secondColor); <span class="comment">// "green"</span></span><br></pre></td></tr></table></figure>

<h3 id="剩余项"><a href="#剩余项" class="headerlink" title="剩余项"></a>剩余项</h3><p>与函数的剩余参数类似，数组解构有一个名为剩余项的概念，它使用<code>...</code>语法来将剩下的项目赋值给一个指定的变量，范例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ firstColor, ...restColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(firstColor); <span class="comment">// "red"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]); <span class="comment">// "green"</span></span><br><span class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]); <span class="comment">// "blue"</span></span><br></pre></td></tr></table></figure>

<p><strong>除此之外在ES6中可以使用剩余项的语法来进行数组克隆。</strong>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ES6 中克隆数组</span></span><br><span class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</span><br><span class="line"><span class="keyword">let</span> [ ...clonedColors ] = colors;</span><br><span class="line"><span class="built_in">console</span>.log(clonedColors); <span class="comment">//"[red,green,blue]"</span></span><br></pre></td></tr></table></figure>

<p><strong>剩余项必须是数组解构模式中最后的部分，之后不能再有逗号，否则就是语法错误。</strong></p>
<h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><p><strong>对象与数组解构能被用在一起，以创建更复杂的解构表达式。在对象与数组混合而成的结构中，这么做便能准确提取其中你想要的信息片段。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    type: <span class="string">"Indentifier"</span>,</span><br><span class="line">    name: <span class="string">"foo"</span>,</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        end: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    range: [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    loc: &#123;start&#125;,</span><br><span class="line">    range: [startIndex]</span><br><span class="line">&#125; = node;</span><br><span class="line"><span class="built_in">console</span>.log(start);      <span class="comment">//&#123; line: 1, column: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(startIndex); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><p>解构的另外一个特别有用的场景，即在传递函数参数时，<strong>当JS的函数接收大量可选参数时，一个常用模式是创建一个<code>option</code>对象</strong>，其中包含了附加的参数，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line">    options = options || &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> secure = options.secure,</span><br><span class="line">        path = options.path,</span><br><span class="line">        domain = options.domain,</span><br><span class="line">        expires = options.expires;</span><br><span class="line">    <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>很多<code>JS</code>的库都包含了类似于此例的<code>setCookie()</code>函数。在此函数内，<code>name</code>与<code>value</code>参数是必需的，而<code>secure</code>、<code>path</code> 、 <code>domain</code> 与 <code>expires</code> 则不是。并且因为此处对于其余数据并没有顺序要求，将它们作为 <code>options</code> 对象的具名属性会更有效率，而无须列出一堆额外的具名参数。这种方法很有用，但无法仅通过查看函数定义就判断出函数所期望的输入，你必须阅读函数体的代码。<br>参数解构提供了更清楚地标明函数期望输入的替代方案。它使用对象或数组解构的模式替代了具名参数。要看到其实际效果，请查看下例中重写版本的 <code>setCookie()</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125;</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</span><br><span class="line">    secure: <span class="literal">true</span>,</span><br><span class="line">    expires: <span class="number">60000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在对于<code>setCookie()</code> 函数的使用者来说，解构参数之外的参数明显是必需的；而可选项目存在于额外的参数组中，这同样是非常明确的；同时，若使用了第三个参数，其中应当包含什么值当然也是极其明确的。解构参数在没有传递值的情况下类似于常规参数，它们会被设为<code>undefined</code>。</p>
<h3 id="解构的参数是必需的"><a href="#解构的参数是必需的" class="headerlink" title="解构的参数是必需的"></a>解构的参数是必需的</h3><p>参数解构有一个怪异点：默认情况下调用函数时未给参数解构传值会抛出错误，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出错！</span></span><br><span class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>);</span><br></pre></td></tr></table></figure>

<p>调用时第三个参数缺失了，因此它不出预料地等于<code>undefined</code>。这导致了一个错误，因为参数解构实际上只是解构声明的简写。当<code>setCookie()</code> 函数被调用时，<code>JS</code>引擎实际上是这么做的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options;</span><br><span class="line">    <span class="comment">// 设置 cookie 的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若你让解构的参数作为必选参数，那么上述行为并不会令人困扰。但若你要求它是可选的，可以给解构的参数提供默认值来处理这种行为，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例为第三个参数提供了一个空对象作为其默认值。给解构的参数提供默认值，也就意味着若未向 setCookie() 函数传递第三个参数，则 secure 、 path 、 domain 与 expires 的值全都会是 undefined ，此时不会有错误被抛出。</p>
<h3 id="参数解构的默认值"><a href="#参数解构的默认值" class="headerlink" title="参数解构的默认值"></a>参数解构的默认值</h3><p>你可以为参数解构提供可解构的默认值，就像在解构赋值时所做的那样，只需在其中每个参数后面添加等号并指定默认值即可。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,</span></span></span><br><span class="line"><span class="function"><span class="params">&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    secure = false,</span></span></span><br><span class="line"><span class="function"><span class="params">    path = <span class="string">"/"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    domain = <span class="string">"example.com"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    expires = new Date(Date.now(</span>) + 360000000)</span></span><br><span class="line"><span class="function">&#125; = </span>&#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展的对象功能</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E6%89%A9%E5%B1%95%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h2><p>对象类别包括：</p>
<ul>
<li>普通对象：拥有JS对象所有默认的内部行为。</li>
<li>奇异对象：其内部行为在某些方面有别于默认行为。</li>
<li>标准对象：Array、Data等标准对象。</li>
<li>内置对象：在脚本开始运行时由JS运行环境提供的对象，所有的标准对象都是内置对象。</li>
</ul>
<h3 id="属性初始化器的速记法"><a href="#属性初始化器的速记法" class="headerlink" title="属性初始化器的速记法"></a>属性初始化器的速记法</h3><p>ES5方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ES6重写方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    sayName() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-is-方法"><a href="#Object-is-方法" class="headerlink" title="Object.is()方法"></a>Object.is()方法</h2><p>当在 JS 中要比较两个值时，你可能会使用相等运算符（ == ）或严格相等运算符（ ===）。为了避免在比较时发生强制类型转换，许多开发者更倾向于使用后者。但严格相等运算符也并不完全准确，例如，它认为 +0 与 -0 相等，即使这两者在 JS 引擎中有不同的表示；另外 NaN === NaN 会返回 false ，因此有必要使用 isNaN() 函数来正确检测 NaN 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> == <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> == <span class="string">"5"</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="number">5</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> === <span class="string">"5"</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">5</span>, <span class="string">"5"</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign-方法"><a href="#Object-assign-方法" class="headerlink" title="Object.assign()方法"></a>Object.assign()方法</h2><p>Object.assign() 方法接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者的，示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver,</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">"js"</span>,</span><br><span class="line">        name: <span class="string">"file.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        type: <span class="string">"css"</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type); <span class="comment">// "css"</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver.name); <span class="comment">// "file.js"</span></span><br><span class="line">receiver.</span><br></pre></td></tr></table></figure>

<h2 id="自有属性的枚举属性"><a href="#自有属性的枚举属性" class="headerlink" title="自有属性的枚举属性"></a>自有属性的枚举属性</h2><p><strong>ES6严格定义了对象自有属性在被枚举时返回的顺序。</strong></p>
<div class="note info">
            <p>自有属性枚举时基本顺序如下：</p><ol><li>所有的数字类型键，按升序排列。</li><li>所有的字符串类型键，按被添加到对象的顺序排列。</li><li>所有的符号类型（详见第六章）键，也按添加顺序排列。</li></ol>
          </div>

<p>示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    c: <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.d = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj).join(<span class="string">""</span>)); <span class="comment">// "012acbd"</span></span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyNames()</code>方法按<code>012acbd</code>的顺序返回了<code>obj</code>对象的属性。**注意：数值类型的键会被合并并排序，即使这未遵循在对象字面量中<br>的顺序。字符串类型的键会跟在数值类型的键之后，按照被添加到 <code>obj</code> 对象的顺序，在对象字面量中定义的键会首先出现，接下来是此后动态添加到对象的键。</p>
<h2 id="更强大的原型"><a href="#更强大的原型" class="headerlink" title="更强大的原型"></a>更强大的原型</h2><p>原型是在 JS 中进行继承的基础， ES6 则在继续让原型更强大。早期的 JS 版本对原型的使用有严重限制，然而随着语言的成熟，开发者也越来越熟悉原型的工作机制，因此他们明显希望能对原型有更多控制权，并能更方便地使用它。于是 ES6 就给原型引入了一些改进。</p>
<h3 id="修改对象的原型"><a href="#修改对象的原型" class="headerlink" title="修改对象的原型"></a>修改对象的原型</h3><p>一般来说，对象的原型会在通过构造器或<code>Object.create()</code>方法创建该对象时被指定。直到ES5 为止，<code>JS</code> 编程最重要的假定之一就是对象的原型在初始化完成后会保持不变。尽管<code>ES5</code> 添加了 <code>Object.getPrototypeOf()</code> 方法来从任意指定对象中获取其原型，但仍然缺少在初始化之后更改对象原型的标准方法。<code>ES6</code>通过添加 <code>Object.setPrototypeOf()</code> 方法而改变了这种假定，此方法允许你修改任意指定对象的原型。<strong>它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象</strong>。<br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对象原型的实际值被存储在一个内部属性 <code>[[Prototype]]</code> 上， <code>Object.getPrototypeOf()</code> 方法会返回此属性存储的值，而 <code>Object.setPrototypeOf()</code> 方法则能够修改该值。不过，使用<code>[[Prototype]]</code> 属性的方式还不止这些。</p>
<h3 id="使用super引用的简答原型访问"><a href="#使用super引用的简答原型访问" class="headerlink" title="使用super引用的简答原型访问"></a>使用super引用的简答原型访问</h3><p>关于原型的另一项进步就是引入了<code>super</code>引用，这让在对象原型上的功能调用变得更容易。。例如，若要覆盖对象实例的一个方法、但依然要调用原型上的同名方法，你可能会这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Woof"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 将原型设置为 person</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === person); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 将原型设置为 dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, dog);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Woof, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(friend) === dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>本例中 <code>friend</code> 上的 <code>getGreeting()</code> 调用了对象上的同名方法。 <code>Object.getPrototypeOf()</code>方法确保了能调用正确的原型，并在其返回结果上附加了一个字符串；而附加的 <code>call(this)</code>代码则能确保正确设置原型方法内部的 this 值。调用原型上的方法时要记住使用 <code>Object.getPrototypeOf()</code> 与 <code>.call(this)</code> ，这有点复杂难懂，因此 <code>ES6</code> 才引入了 <code>super</code> 。<strong>简单来说，<code>super</code> 是指向当前对象的原型的一个指针，实际上就是 <code>Object.getPrototypeOf(this)</code> 的值。知道这些，你就可以像下面这样简化<code>getGreeting()</code> 方法</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">getGreeting() &#123;</span><br><span class="line">    <span class="comment">// 这相当于上个例子中的：</span></span><br><span class="line">    <span class="comment">// Object.getPrototypeOf(this).getGreeting.call(this)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此处调用 super.getGreeting() 等同于在上例的环境中使用<code>Object.getPrototypeOf(this).getGreeting.call(this)</code> 。类似的，你能使用 <code>super</code> 引用来调<br>用对象原型上的任何方法，只要这个引用是位于简写的方法之内。试图在方法简写之外的情况使用 <code>super</code> 会导致语法错误，正如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 语法错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此例使用了一个函数作为具名方法，于是调用 <code>super.getGreeting()</code> 就导致了语法错误，因为在这种上下文中 <code>super</code> 是不可用的。当使用多级继承时， <code>super</code> 引用就是非常强大的，因为这种情况下<code>Object.getPrototypeOf()</code> 不再适用于所有场景，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>).getGreeting.call(<span class="keyword">this</span>) + <span class="string">", hi!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="comment">// 原型为 friend</span></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend);</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting()); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>Object.getPrototypeOf()</code> 时，在调用 <code>relative.getGreeting()</code> 处发生了错误。这是因为此时 <code>this</code> 的值是 <code>relative</code> ，而 <code>relative</code>的原型是 <code>friend</code> 对象，这样<code>friend.getGreeting().call()</code> 调用就会导致进程开始反复进行递归调用，直到发生堆栈错误。<br>此问题在 ES5 中很难解决，但若使用 ES6 的 <code>super</code> ，就很简单了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="comment">// 原型为 friend</span></span><br><span class="line"><span class="keyword">let</span> relative = <span class="built_in">Object</span>.create(friend);</span><br><span class="line"><span class="built_in">console</span>.log(person.getGreeting()); <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(relative.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>super</code> 引用并非是动态的，它总是能指向正确的对象。在本例中，<code>super.getGreeting()</code> 总是指向 <code>person.getGreeting()</code> ，而不管有多少对象继承了此方法。</p>
<h3 id="正式的“方法”定义"><a href="#正式的“方法”定义" class="headerlink" title="正式的“方法”定义"></a>正式的“方法”定义</h3><p>在ES6之前，“方法”的概念从未被正式定义，它此前仅指对象的函数属性（而非数据属性）。 ES6 则正式做出了定义：方法是一个拥有 <code>[[HomeObject]]</code> 内部属性的函数，此内部<br>属性指向该方法所属的对象。研究如下的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 并非方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shareGreeting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hi!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此例定义了拥有单个 <code>getGreeting()</code> 方法的 <code>person</code> 对象。由于 <code>getGreeting()</code> 被直接赋给了一个对象，它的 <code>[[HomeObject]]</code> 属性值就是 <code>person</code> 。 而另一方面， <code>shareGreeting()</code>函数没有被指定 <code>[[HomeObject]]</code> 属性，因为它在被创建时并没有赋给一个对象。大多数情况下，这种差异并不重要，然而使用 <code>super</code> 引用时就完全不同了。<br>任何对 super 的引用都会使用 [[HomeObject]] 属性来判断要做什么。第一步是在<code>[[HomeObject]]</code> 上调用 <code>Object.getPrototypeOf()</code> 来获取对原型的引用；接下来，在该原型上查找同名函数；最后，创建 this 绑定并调用该方法。这里有个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 原型为 person</span></span><br><span class="line"><span class="keyword">let</span> friend = &#123;</span><br><span class="line">    getGreeting() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getGreeting() + <span class="string">", hi!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(friend, person);</span><br><span class="line"><span class="built_in">console</span>.log(friend.getGreeting()); <span class="comment">// "Hello, hi!"</span></span><br></pre></td></tr></table></figure>

<p>调用<code>friend.getGreeting()</code> 返回了一个字符串，也就是 <code>person.getGreeting()</code> 的返回值与”, hi!” 的合并结果。此时 <code>friend.getGreeting()</code> 的 <code>[[HomeObject]]</code> 值是 <code>friend</code> ，并且<code>friend</code> 的原型是 <code>person</code> ，因此 <code>super.getGreeting()</code> 就等价于<code>person.getGreeting.call(this)</code> 。</p>
]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器与生成器</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>许多编程语言都将迭代数据的方式从使用<code>for</code>循环转变到使用迭代器对象，<code>for</code>循环需要初始化变量以追踪集合内的位置，而迭代器则以编程方式返回集合中的下一个项。迭代器能使操作集合变得更简单，因此ES6也将其添加进JS中。</p>
<h2 id="何为迭代器"><a href="#何为迭代器" class="headerlink" title="何为迭代器"></a>何为迭代器</h2><p>迭代器是被设计专用于迭代的对象，带有特定接口，所有迭代器对象都拥有<code>next()</code>方法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的<code>value</code>,以及一个布尔类型的<code>done</code>，其值为<code>true</code>时表示没有更多值可供使用。迭代器有一个指向集合位置的内部指针，每当调用了<code>next()</code>方法，迭代器就会返回相应的下一个值。<br>若在最后一个值返回后再调用<code>next()</code>，所返回的<code>done</code>属性值会是<code>true</code>，并且<code>value</code>属性值会是迭代器自身的返回值。该返回值不是原数据集的一部分，却会成为相关数据的最后一个片段，或在迭代器未提供返回值的时候使用<code>undefined</code>。迭代器自身的返回值类似于函数的返回值，是向调用者返回信息的最后手段。</p>
]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>符号与符号属性</title>
    <url>/blog/2020/04/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/%E7%AC%A6%E5%8F%B7%E4%B8%8E%E7%AC%A6%E5%8F%B7%E5%B1%9E%E6%80%A7%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/</url>
    <content><![CDATA[<p>在JS已有的基本类型（字符串、数值、布尔类型、null与undefined）之外，ES6引入了一种新的基本类型：符号（Symbol）。符号起初被设计用于创建私有成员，而这也是JS开发者期待已久的特性。在符号诞生之前，将字符串作为属性名称导致属性可以被轻易访问，无论命名规则如何。而“私有名称”意味着开发者可以创建非字符串类型的属性名称，由此可以防止使用常规手段来探查这些名称。<br>“私有名称”提案最终发展成为ES6中的符号，而本章将会教你如何有效使用它。虽然它只保留了实现细节（即：引入了非字符串类型的属性名）而丢弃了私有性意图，但它仍然显著有别于对象的其余属性。</p>
<h2 id="创建符号值"><a href="#创建符号值" class="headerlink" title="创建符号值"></a>创建符号值</h2><p><strong>符号没有字面量形式。</strong>有别于布尔类型的<code>true</code>或数值类型的<code>42</code>等等。可以使用全局<code>Symbol</code>函数来创建一个符号值，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[firstName] = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]); <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>

<p>此代码创建了一个符号类型的<code>firstName</code>变量，并将它作为<code>person</code>对象的一个属性，而每次访问该属性都要使用这个符号值。为符号变量适当命名是个好主意，这样你就可以很容易地说明它的含义。</p>
<div class="note info">
            <p>由于符号值是基本类型的值，因此调用 new Symbol() 将会抛出错误。你可以通过 newObject(yourSymbol) 来创建一个符号实例，但尚不清楚这能有什么作用。</p>
          </div>

<p>Symbol 函数还可以接受一个额外的参数用于描述符号值，该描述并不能用来访问对应属性，但它能用于调试，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">"first name"</span>);</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line">person[firstName] = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"first name"</span> <span class="keyword">in</span> person); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(firstName); <span class="comment">// "Symbol(first name)"</span></span><br></pre></td></tr></table></figure>

<p>符号的描述信息被存储在内部属性<code>[[Description]]</code>中，当符号的<code>toString()</code>方法被显式或隐式调用时，该属性都会被读取。在本例中，<code>console.log()</code>隐式调用了 <code>firstName</code>变量的<code>toString()</code>方法，于是描述信息就被输出到日志。此外没有任何办法可以从代码中直接访问<code>[[Description]]</code>属性。我建议始终应给符号提供描述信息，以便更好地阅读代码或进行调试。</p>
<div class="note into">
            <p>识别符号值<br>由于符号是基本类型的值，因此你可以使用 typeof 运算符来判断一个变量是否为符号。 ES6 扩充了 typeof 的功能以便让它在作用于符号值的时候能够返回 “symbol” ，尽管有其他方法可以判断一个变量是否为符号， typeof 运算符依然是最准确、最优先的判别手段。例如：</p>
          </div>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol = <span class="built_in">Symbol</span>(<span class="string">"test symbol"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol); <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>

<h2 id="使用符号值"><a href="#使用符号值" class="headerlink" title="使用符号值"></a>使用符号值</h2><p>可以在任意能使用“需计算属性名”的场合使用符号，此外还可以在<code>Object.defineProperty()</code>或<code>Object.defineProperties()</code>调用中使用它。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">"first name"</span>);</span><br><span class="line"><span class="comment">// 使用一个需计算字面量属性</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    [firstName]: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 让该属性变为只读</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, firstName, &#123; <span class="attr">writable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="built_in">Symbol</span>(<span class="string">"last name"</span>);</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person, &#123;</span><br><span class="line">    [lastName]: &#123;</span><br><span class="line">        value: <span class="string">"Zakas"</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]); <span class="comment">// "Nicholas"</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastName]); <span class="comment">// "Zakas"</span></span><br></pre></td></tr></table></figure>

<h3 id="共享符号值"><a href="#共享符号值" class="headerlink" title="共享符号值"></a>共享符号值</h3><p>你或许想在不同的代码段中使用相同的符号值，例如：假设在应用中需要在两个不同的对象类型中使用同一个符号属性，用来表示一个唯一标识符。跨越文件或代码来追踪符号值是很<br>困难并且易错的，为此， <strong>ES6 提供了“全局符号注册表”供你在任意时间点进行访问。</strong><br>若你想创建共享符号值，应使用<code>Symbol.for()方法</code>而不是<code>Symbol()方法</code>。 <strong><code>Symbol.for()</code>方法仅接受单个字符串类型的参数，作为目标符号值的标识符，同时此参数也会成为该符号的描述信息。</strong>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;&#125;;</span><br><span class="line">object[uid] = <span class="string">"12345"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(object[uid]); <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid); <span class="comment">// "Symbol(uid)"</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for()</code> 方法首先会搜索全局符号注册表，看是否存在一个键值为 <code>&quot;uid&quot;</code> 的符号值。若是，该方法会返回这个已存在的符号值；否则，会创建一个新的符号值，并使用该键值将其记录到全局符号注册表中，然后返回这个新的符号值。这就意味着此后使用同一个键值去调用 <code>Symbol.for()</code>方法都将会返回同一个符号值，就像下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    [uid]: <span class="string">"12345"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object[uid]); <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid); <span class="comment">// "Symbol(uid)"</span></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(uid === uid2); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(object[uid2]); <span class="comment">// "12345"</span></span><br><span class="line"><span class="built_in">console</span>.log(uid2); <span class="comment">// "Symbol(uid)"</span></span><br></pre></td></tr></table></figure>

<p>本例中，<code>uid</code>与<code>uid2</code>包含同一个符号值，因此它们可以互换使用。<strong>第一次调用<code>Symbol.for()</code>创建了这个符号值，而第二次调用则从全局符号注册表中将其检索了出来。</strong><br><strong>共享符号值还有另一个独特用法，你可以使用<code>Symbol.keyFor()</code>方法在全局符号注册表中根据符号值检索出对应的键值</strong>，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid)); <span class="comment">// "uid"</span></span><br><span class="line"><span class="keyword">let</span> uid2 = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid2)); <span class="comment">// "uid"</span></span><br><span class="line"><span class="keyword">let</span> uid3 = <span class="built_in">Symbol</span>(<span class="string">"uid"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(uid3)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>注意：使用符号值<code>uid</code>与<code>uid2</code>都返回了键值<code>&quot;uid&quot;</code>，而符号值<code>uid3</code>在全局符号注册表中并不存在，因此没有关联的键值，<code>Symbol.keyFor()</code>方法只会返回 undefined 。</p>
<div class="note info">
            <p>全局符号注册表类似于全局作用域，是一个共享环境，这意味着你不应当假设某些值是否已存在于其中。在使用第三方组件时，为符号的键值使用命名空间能够减少命名冲突<br>的可能性，举个例子：<code>jQuery</code>代码应当为它的所有键值使用 <code>&quot;jquery.&quot;</code> 的前缀，如<code>&quot;jquery.element&quot;</code> 或类似的形式。</p>
          </div>

<h2 id="符号值的转换"><a href="#符号值的转换" class="headerlink" title="符号值的转换"></a>符号值的转换</h2><p>类型转换是<strong>JS</strong>语言重要的一部分，能够非常灵活地将一种数据类型转换为另一种。然而符号类型在进行转换时非常不灵活，因为其他类型缺乏与符号值的合理等价，尤其是符号值无法被转换为字符串值或数值。因此将符号作为属性所达成的效果，是其他类型所无法替代的。<br>前面例子中使用了<code>console.log()</code>来展示符号值的输出，能这么做是由于自动调用了符号的<code>String()</code>方法来产生输出，也可以直接调用<code>String()</code>方法来获取相同结果，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</span><br><span class="line">    desc = <span class="built_in">String</span>(uid);</span><br><span class="line"><span class="built_in">console</span>.log(desc); <span class="comment">// "Symbol(uid)"</span></span><br></pre></td></tr></table></figure>

<p><code>String()</code>方法调用了<code>uid.toString()</code>来获取符号的字符串描述信息。但若你想直接将符号转换为字符串，则会引发错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</span><br><span class="line">    desc = uid + <span class="string">""</span>; <span class="comment">// 引发错误！</span></span><br></pre></td></tr></table></figure>

<p>将 uid 与空字符串相连接，会首先要求把 uid 转换为一个字符串，而这会引发错误，从而阻止了转换行为。相似地，你不能将符号转换为数值，对符号使用所有数学运算符都会引发错误，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>),</span><br><span class="line">sum = uid / <span class="number">1</span>; <span class="comment">// 引发错误！</span></span><br></pre></td></tr></table></figure>

<p>此例试图把符号值除以 1 ，同样引发了错误。无论对符号使用哪种数学运算符都会导致错误，但使用逻辑运算符则不会，因为符号值在逻辑运算中会被认为等价于 true （就像 JS<br>中其他的非空值那样）。</p>
<h2 id="检索符号属性"><a href="#检索符号属性" class="headerlink" title="检索符号属性"></a>检索符号属性</h2><p><code>Object.keys()</code> 与 <code>Object.getOwnPropertyNames()</code> 方法可以检索对象的所有属性名称，前者返回所有的可枚举属性名称，而后者则返回所有属性名称而无视其是否可枚举。然而两者都不能返回符号类型的属性，以保持它们在<strong>ES5</strong>中的功能不发生变化。而 <strong>ES6</strong> 新增了<code>Object.getOwnPropertySymbols()</code> 方法，以便让你可以检索对象的符号类型属性。<br><code>Object.getOwnPropertySymbols()</code> 方法会返回一个数组，包含了对象自有属性名中的符号值，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">"uid"</span>);</span><br><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">    [uid]: <span class="string">"12345"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> symbols = <span class="built_in">Object</span>.getOwnPropertySymbols(object);</span><br><span class="line"><span class="built_in">console</span>.log(symbols.length);         <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(symbols[<span class="number">0</span>]);             <span class="comment">// "Symbol(uid)"</span></span><br><span class="line"><span class="built_in">console</span>.log(object[symbols[<span class="number">0</span>]]);    <span class="comment">// "12345"</span></span><br></pre></td></tr></table></figure>

<h2 id="使用知名符号暴露内部方法"><a href="#使用知名符号暴露内部方法" class="headerlink" title="使用知名符号暴露内部方法"></a>使用知名符号暴露内部方法</h2><p>ES5的中心主题之一是披露并定义了一些魔术般的成分，而这些部分是当时开发者所无法自行模拟的。ES6延续了这些工作，对原先属于语言内部逻辑的部分进行了进一步的暴露，允许使用符号类型的原型属性来定义某些对象的基础行为。</p>
<p>ES6定义了“知名符号”来代表JS中一些公共行为，而这些行为此前被认为只能是内部操作，每一个知名符号都对应全局<code>Sympol</code>对象的一个属性，例如<code>Sympol.create</code>。<br>这些知名符号是：</p>
<div class="note info">
            <ul><li><code>Sympol.hasInstance</code>: 供<code>instanceof</code>运算符使用的一个方法，用于判断对象继承关系。</li><li><code>Symbol.isConcatSpreadable</code>: 一个布尔类型值，在集合对象作为参数传递给<code>Array.prototype.concat()</code>方法时，指示是否要将该集合的元素扁平化。</li><li><code>Symbol.iterator</code>: 返回迭代器的一个方法。</li><li><code>Symbol.match</code>: 供<code>String.prototype.match()</code>函数使用的一个方法，用于比较字符串。</li><li><code>Symbol.replace</code>: 供<code>String.prototype.replace()</code>函数使用的一个方法，用于替换子字符串。</li><li><code>Symbol.search</code>: 供<code>String.prototype.search()</code> 函数使用的一个方法，用于定位子字符串。</li><li><code>Symbol.species</code>: 用于产生派生对象的构造器。</li><li><code>Symbol.split</code>: 供<code>String.prototype.split()</code>函数使用的一个方法，用于分割字符串。</li><li><code>Symbol.toPrimitive</code>: 返回对象所对应的基本类型值的一个方法。</li><li><code>Symbol.toStringTag</code>: 供 <code>String.prototype.toString()</code> 函数使用的一个方法，用于创建对象的描述信息。</li><li><code>Symbol.unscopables</code>: 一个对象，该对象的属性指示了哪些属性名不允许被包含在<code>with</code> 语句中。</li></ul>
          </div>

<div class="note into">
            <p>重写知名符号所定义的方法，会把一个普通对象改变成奇异对象，因为它改变了一些默认的内部行为。这并不会对你的代码造成实际影响，它只是改变了规范所描述的对象特征。</p>
          </div>

<h3 id="Symbol-hasInstance属性"><a href="#Symbol-hasInstance属性" class="headerlink" title="Symbol.hasInstance属性"></a>Symbol.hasInstance属性</h3><p>每个函数都具有一个 <code>Symbol.hasInstance</code> 方法，用于判断指定对象是否为本函数的一个实例。这个方法定义在 <code>Function.prototype</code> 上，因此所有函数都继承了面对<code>instanceof</code>运算符时的默认行为。<code>Symbol.hasInstance</code>属性自身不可写入、不可配置、不可枚举的，从而保证它不会被错误地重写。<br><code>Symbol.hasInstance</code> 方法只接受单个参数，即需要检测的值。如果该值是本函数的一个实例，则方法会返回 <code>true</code> 。为了理解该方法是如何工作的，可研究下述代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br></pre></td></tr></table></figure>

<p>这句话等价于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>[<span class="built_in">Symbol</span>.hasInstance](obj);</span><br></pre></td></tr></table></figure>

<p>ES6从本质上将<code>instanceof</code>运算符重定义为上述方法调用的简写语法，这样使用<code>instanceof</code> 便会触发一次方法调用，实际上允许你改变该运算符的工作。<br>例如:假设你想定义一个函数，使得任意对象都不会被判断为该函数的一个实例，你可以采用硬编码的方式让该函数的<code>Symbol.hasInstance</code>方法始终返回<code>false</code>，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    name: <span class="string">"foo"</span>;</span><br><span class="line">    type: <span class="string">"Indentifier"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(MyObject, <span class="built_in">Symbol</span>.hasInstance,&#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Obj = <span class="keyword">new</span> MyObject();</span><br><span class="line"><span class="built_in">console</span>.log(MyObject[<span class="built_in">Symbol</span>.hasInstance](Obj));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(Obj <span class="keyword">instanceof</span> MyObject);        <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>要重写一个不可写入的属性，你必须像这个例子一样使用 <code>Object.defineProperty()</code> 。此代码将 <code>Symbol.hasInstance</code> 方法重写为一个始终返回 <code>false</code> 的函数，所以此后即使传入的对象确实是 <code>MyObject</code> 类的一个实例， <code>instanceof</code> 运算符仍然会返回 <code>false</code>。</p>
<p>当然，你可以基于各种条件来决定一个值是否应当被判断为某个类的实例。例如，将介于 1到 100 之间的数值认定为一个特殊的数值类型，为此你可以书写如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(SpecialNumber, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (v <span class="keyword">instanceof</span> <span class="built_in">Number</span>) &amp;&amp; (v &gt;= <span class="number">1</span> &amp;&amp; v &lt;= <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> two = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>);</span><br><span class="line">    zero = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(two <span class="keyword">instanceof</span> SpecialNumber);   <span class="comment">//two</span></span><br><span class="line"><span class="built_in">console</span>.log(zero <span class="keyword">instanceof</span> SpecialNumber);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>此代码重写了 <code>Symbol.hasInstance</code> 方法，在目标对象是数值对象的实例、并且其值介于 1 到100 之间时，返回 true 。于是， <code>SpecialNumber</code> 类会把变量 <code>two</code>判断为自身的一个实例，即使二者之间并不存在直接的定义关联。需要注意的是： <code>instanceof</code> 的操作数必须是一个对象，以便触发 <code>Symbol.hasInstance</code> 调用；若操作数并非对象， instanceof 只会简单地返回 <code>false</code>。</p>
<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>JS在数组上设计了<code>concat()</code> 方法用于将两个数组连接在一起，此处示范了如何使用该方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors1 = [<span class="string">"red"</span>, <span class="string">"green"</span>],</span><br><span class="line">    colors2 = colors1.concat([<span class="string">"blue"</span>, <span class="string">"black"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colors2.length);    <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2);       <span class="comment">//[ 'red', 'green', 'blue', 'black' ]</span></span><br></pre></td></tr></table></figure>

<p>此代码将一个新数组连接到 <code>colors1</code> 末尾，并创建了 <code>colors2</code> ，后者包含了前两个数组中所有的项。不过， <code>concat()</code> 方法也可以接受非数组的参数，此时这些参数只是简单地被添加到数组末尾，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors1 = [ <span class="string">"red"</span>, <span class="string">"green"</span> ],</span><br><span class="line">    colors2 = colors1.concat([ <span class="string">"blue"</span>, <span class="string">"black"</span> ], <span class="string">"brown"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(colors2.length); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(colors2); <span class="comment">// ["red","green","blue","black","brown"]</span></span><br></pre></td></tr></table></figure>

<p>此代码向 <code>concat()</code> 方法传递了一个额外参数 <code>&quot;brown&quot;</code> ，使得它成为数组 <code>colors2</code> 的第 <strong>5</strong> 项。<strong>为何数组类型的参数与字符串类型的参数会被区别对待？这是因为 <code>JS</code> 规范要求此时数组类型的参数需要被自动分离出各个子项，而其他类型的参数无需如此处理。在 ES6 之前，没有任何手段可以改变这种行为。</strong><br><code>Symbol.isConcatSpreadable</code> 属性是一个布尔类型的属性，它表示目标对象拥有长度属性与数值类型的键、并且数值类型键所对应的属性值在参与 <code>concat()</code> 调用时需要被分离为个体。该符号与其他的知名符号不同，默认情况下并不会作为任意常规对象的属性。它只出现在特定类型的对象上，用来标示该对象在作为 <code>concat()</code> 参数时应如何工作，从而有效改变该对象的默认行为。你可以用它来定义任意类型的对象，让该对象在参与 <code>concat()</code> 调用时能够表现得像数组一样，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">"Hello"</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">"world"</span>,</span><br><span class="line">    length: <span class="number">2</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.isConcatSpreadable]: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> messages = [ <span class="string">"Hi"</span> ].concat(collection);</span><br><span class="line"><span class="built_in">console</span>.log(messages.length); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(messages); <span class="comment">// ["hi","Hello","world"]</span></span><br></pre></td></tr></table></figure>

<p>本例中的 <code>collection</code> 对象的特征类似于数组：拥有长度属性以及两个数值类型的键，并且<code>Symbol.isConcatSpreadable</code> 属性值被设为 <code>true</code> ，用于指示该对象在被添加到数组时应该使用分离的属性值。当 <code>collection</code> 对象被传递给 <code>concat()</code> 方法时， <code>&quot;Hello&quot;</code> 与 <code>&quot;world&quot;</code>被分离为独立的项，并跟在 <code>&quot;hi&quot;</code> 元素之后。</p>
<div class="note info">
            <p>你也可以将数组的子类的 <code>Symbol.isConcatSpreadable</code> 属性值设为 <code>false</code> ，用于在<code>concat()</code> 调用时避免项目被分离。子类的介绍在迭代器与生成器部分介绍。</p>
          </div>
]]></content>
      <categories>
        <category>深入理解ES6</category>
      </categories>
      <tags>
        <tag>深入理解ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript专项练习1</title>
    <url>/blog/2020/04/17/%E9%94%99%E9%A2%98%E7%AC%94%E8%AE%B0/JavaScript%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A01/</url>
    <content><![CDATA[<h2 id="JavaScript-打开新窗口（window-open）"><a href="#JavaScript-打开新窗口（window-open）" class="headerlink" title="JavaScript-打开新窗口（window.open）"></a>JavaScript-打开新窗口（window.open）</h2><p><code>open()</code> 方法可以查找一个已经存在或者新建的浏览器窗口。</p>
<p>语法：<br>window.open([URL], [窗口名称], [参数字符串])<br>参数说明：</p>
<ul>
<li>URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</li>
<li>窗口名称：可选参数，被打开窗口的名称。<ol>
<li>该名称由字母、数字和下划线字符组成。</li>
<li>“_top”、”_blank”、”_self”具有特殊意义的名称。其中：<br> “_blank”：在新窗口显示目标网页<br> “_self”：在当前窗口显示目标网页<br> “_top”：框架网页中在上部窗口中显示目标网页</li>
<li>相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</li>
<li>name 不能包含有空格。<br>例题如下所示：</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开名为 "window2" 的新窗口的 JavaScript 语法是？</span></span><br><span class="line"><span class="built_in">window</span>.open(<span class="string">"http://www.w3school.com.cn"</span>,<span class="string">"window2"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-setTimeout-用法详解"><a href="#JavaScript-setTimeout-用法详解" class="headerlink" title="JavaScript setTimeout() 用法详解"></a>JavaScript setTimeout() 用法详解</h3><p>setTimeout() 是属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。<strong>setTimeout(() =&gt; {}), 0) 用例是调用一个函数，会在代码中其他每个函数都已执行后再执行它。</strong><br>语法格式可以是以下两种：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(要执行的代码, 等待的毫秒数)</span><br><span class="line">setTimeout(JavaScript 函数, 等待的毫秒数)</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong>： 1000 毫秒= 1 秒。<br><strong>提示</strong>： 如果你只想重复执行可以使用 setInterval() 方法。使用setInterval()时的阻止方法是clearInterval()。<br><strong>提示</strong>： 使用 clearTimeout() 方法来阻止函数的执行。</p>
<p>例题如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下语句的执行结果是什么？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line">setTimeOut(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="string">'one'</span>,<span class="string">'three'</span>,<span class="string">'two'</span></span><br></pre></td></tr></table></figure>

<h2 id="js如何判断一个对象是不是Array"><a href="#js如何判断一个对象是不是Array" class="headerlink" title="js如何判断一个对象是不是Array"></a>js如何判断一个对象是不是Array</h2><p>在说明如何判断一个对象为数组类型前，我们先巩固下js的数据类型，js一共有六大数据类型：number、string、object、Boolean、null、undefined。</p>
<ul>
<li>string： 由单引号或双引号来说明，如”string”；</li>
<li>number：数组类型，比如整数、小数等；</li>
<li>Boolean: 有两个值：true、false;</li>
<li>undefined：未定义，就是你创建一个变量后却没给它赋值；</li>
<li>null: 顾名思义，null就是没有，什么也不表示；</li>
<li>object: 除了上面五种之外的类型。</li>
</ul>
<p>js的数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素可以是对象或其他数组，这样就可以创建复杂的数据结构。通常我们可以用一元运算符typeof来判断js的数据类型，但是对于数组这样一个特殊的对象却只能返回”object”。<br>typeof可以解决大部分的数据类型判断，是一个一元运算，放在一个运算值之前，其返回值为一个字符串，该字符串说明运算数的类型，所以判断某个是否为String类型，可以直接 if(typeof(你的值) == “string”){}。<br>除了前四个类型外，null、对象、数组返回的都是object类型；对于函数类型返回的则是function，再比如typeof(Date)，typeof(eval)等。<br><strong>js判断数组类型的方法有下面四种：</strong></p>
<h3 id="instance操作符"><a href="#instance操作符" class="headerlink" title="instance操作符"></a>instance操作符</h3><p>instanceof 用于判断一个变量是否某个对象的实例，左边操作数是一个对象，右边操作数是一个函数对象或者函数构造器。原理是通过判断左操作数的对象的原型链上是否具有右操作数的构造函数的prototype属性。<br>但是对于instanceof和多全局对象（多个frame或多个window之间的交互），即在浏览器中，我们的脚本需要在多个窗口之间进行交互，多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数，这可能会引发一些问题，比如：表达式[] instanceof window.frames[0].Array会返回false，因为Array.prototype !== window.frames[0].Array.prototype。</p>
<h3 id="Array-isArray-myObj-方法"><a href="#Array-isArray-myObj-方法" class="headerlink" title="Array.isArray(myObj)方法"></a>Array.isArray(myObj)方法</h3><p>数组自身判断的方法。</p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>在W3C定义中的定义：constructor 属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数。从定义上来说跟instanceof不太一致，但效果都是一样的。</p>
<h3 id="Object-prototype-toString-call-arr-“-object-Array-”"><a href="#Object-prototype-toString-call-arr-“-object-Array-”" class="headerlink" title="Object.prototype.toString.call(arr) === “[object Array]”"></a>Object.prototype.toString.call(arr) === “[object Array]”</h3><p>这是最简单的方法。与 Array.isArray(myObj)一样能准确判断数组。</p>
<h2 id="对象转布尔值情况"><a href="#对象转布尔值情况" class="headerlink" title="对象转布尔值情况"></a>对象转布尔值情况</h2><p>任何兑现转为布尔值，都得到true，切记<strong>在JS 中，只有0，-0，NaN,””, null，undefined这六个值转布尔值时，结果为false。</strong><br>例题如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  alert(<span class="string">'hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (y) &#123;</span><br><span class="line">  alert(<span class="string">'hello'</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为<code>&#39;hi&#39;</code></p>
<h3 id="原型继承试题"><a href="#原型继承试题" class="headerlink" title="原型继承试题"></a>原型继承试题</h3><p>试题如下所示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.a = <span class="string">'a'</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.b = <span class="string">'b'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br><span class="line">console.log('p.a: '+ p.a); # p.a: undefined</span><br><span class="line">console.log('p.b: '+ p.b); # p.b: b  问为什么？</span><br></pre></td></tr></table></figure>

<p><strong>Person函数才是Function对象的一个实例，所以通过Person.a可以访问到Function原型里面的属性，但是new Person()返回来的是一个对象，它是Object的一个实例,是没有继承Function的，所以无法访问Function原型里面的属性。但是,由于在js里面所有对象都是Object的实例，所以，Person函数可以访问到Object原型里面的属性，Person.b =&gt; <code>&#39;b&#39;</code></strong></p>
]]></content>
      <categories>
        <category>计算机~JavaScript专项练习</category>
      </categories>
      <tags>
        <tag>计算机~JavaScript专项练习</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript专项练习2</title>
    <url>/blog/2020/04/17/%E9%94%99%E9%A2%98%E7%AC%94%E8%AE%B0/JavaScript%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A02/</url>
    <content><![CDATA[<h2 id="JavaScript-parseInt-函数"><a href="#JavaScript-parseInt-函数" class="headerlink" title="JavaScript parseInt() 函数"></a>JavaScript parseInt() 函数</h2><h3 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h3><div class="note info">
            <p>parseInt()函数可解析一个字符串，并返回一个整数。当参数radix的值为0，或没有设置该参数时，parseInt()会根据string来判断数字的基数。<br>当忽略参数radix，JavaScript默认数字的基数如下：</p><ul><li>如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数。</li><li>如果 string 以 0 开头，那么 ECMAScript v3 允许 parseInt() 的一个实现把其后的字符解析为八进制或十六进制的数字。</li><li>如果 string 以 1 ~ 9 的数字开头，parseInt() 将把它解析为十进制的整数。</li></ul>
          </div>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(string, radix)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>必需。要被解析的字符串。</td>
</tr>
<tr>
<td>radix</td>
<td>可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。</td>
</tr>
</tbody></table>
<p><strong>所有浏览器都支持parseInt()函数。</strong></p>
<h3 id="提示和注释"><a href="#提示和注释" class="headerlink" title="提示和注释"></a>提示和注释</h3><p><strong>注意：</strong> 只有字符串中的第一个数字会被返回。<br><strong>注意：</strong> 开头和结尾的空格是允许的。<br><strong>注意：</strong> 如果字符串的第一个字符不能被转换为数字，那么parseInt()会返回NaN.<br><strong>注意：</strong> 在字符串以“0”为开始时旧的浏览器默认使用八进制基数。<strong>ECMAScript5，默认的是十进制的基数。</strong></p>
<h2 id="JavaScript-函数定义"><a href="#JavaScript-函数定义" class="headerlink" title="JavaScript 函数定义"></a>JavaScript 函数定义</h2><div class="note info">
            <p><code>JavaScript</code> 使用关键字 <code>function</code> 定义函数。<br>函数可以通过声明定义，也可以是一个表达式。</p>
          </div>

<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">parameters</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明后不会立即执行，会在我们需要的时候调用到。实例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>JavaScript函数可以通过一个表达式定义，函数表达式可以存储在变量中，实例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数表达式存储在变量后，变量也可以作为一个函数使用，实例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> z = x(<span class="number">4</span>,<span class="number">3</span>);  <span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function() 构造函数"></a>Function() 构造函数</h3><p>在以上实例中，我们了解到函数通过关键字<code>function</code>定义。函数同样可以通过内置的<code>JavaScript</code>函数构造器<code>（Function()）</code>定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"return a * b"</span>);</span><br><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p><strong>但实际上，在<code>JavaScript</code>中，很多时候，你需要避免使用<code>new</code>关键字。</strong>上面实例可以写成如下形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a * b&#125;;</span><br><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x);   <span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p><strong>提升（Hoisting）是<code>JavaScript</code>默认将当前作用域提升到前面去的的行为。提升（Hoisting）应用在变量的声明与函数的声明。</strong>因此，函数可以在声明之前调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myFunction(<span class="number">5</span>);   <span class="comment">//25</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：使用表达式定义函数时无法提升。</strong></p>
<h3 id="函数是对象"><a href="#函数是对象" class="headerlink" title="函数是对象"></a>函数是对象</h3><p>在<code>JavaScript</code> 中使用 <code>typeof</code> 操作符判断函数类型将返回 <code>&quot;function&quot;</code> 。但是<code>JavaScript</code> 函数描述为一个对象更加准确。<code>JavaScript</code> 函数有 <code>属性</code>和<code>方法</code>。<br><code>arguments.length</code>属性返回函数调用过程接收到的参数个数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">arguments</span>.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机~JavaScript专项练习</category>
      </categories>
      <tags>
        <tag>计算机~JavaScript专项练习</tag>
      </tags>
  </entry>
  <entry>
    <title>剩余时间段页面</title>
    <url>/blog/2020/07/09/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E9%9A%BE%E7%82%B9/%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E6%AE%B5%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p><strong>js 24小时制 给定多个时间段 计算剩下的时间段</strong><br>废话不多说，直接上图，为达到图中的功能，最后一个时间段是由其他几个时间段计算出来的，下图中的平时段是自动计算得到的。<br><img src="https://ningning-1259809020.cos.ap-chengdu.myqcloud.com/%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9/1594285891%281%29.png" alt="自定义输入时段个数及每个时段的输入时间，计算出最后一个时段的剩余时间段"><br>代码如下，代码很简单，就是为了满足条件操作时间的时候，逻辑上很恶心，vue代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"peakValleySetting"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"padding: 10px 20px"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最后一个输入时段之前的时段可以进行自定义 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item,i) in sourceFirst"</span> <span class="attr">:key</span>=<span class="string">"i"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dateSetting"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; item.name &#125;&#125;: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-time-picker</span></span></span><br><span class="line"><span class="tag">              <span class="attr">v-for</span>=<span class="string">"(res, m) of item.items"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">:key</span>=<span class="string">"m"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">v-model</span>=<span class="string">"item.items[m]"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">is-range</span></span></span><br><span class="line"><span class="tag">              <span class="attr">format</span>=<span class="string">"HH:mm"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">range-separator</span>=<span class="string">"-"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">start-placeholder</span>=<span class="string">"开始时间"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">end-placeholder</span>=<span class="string">"结束时间"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">placeholder</span>=<span class="string">"请选择时间范围"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">size</span>=<span class="string">"mini"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span></span></span><br><span class="line"><span class="tag">              <span class="attr">v-if</span>=<span class="string">"item.items.length &gt;= 1"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"danger"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">icon</span>=<span class="string">"el-icon-delete"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">circle</span></span></span><br><span class="line"><span class="tag">              <span class="attr">size</span>=<span class="string">"mini"</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">click</span>=<span class="string">"onDelete(item, sourceFirst)"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-button</span></span></span><br><span class="line"><span class="tag">              <span class="attr">type</span>=<span class="string">"success"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">icon</span>=<span class="string">"el-icon-circle-plus"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">circle</span></span></span><br><span class="line"><span class="tag">              <span class="attr">size</span>=<span class="string">"mini"</span></span></span><br><span class="line"><span class="tag">              @<span class="attr">click</span>=<span class="string">"onAdd(item.name, sourceFirst)"</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"dateSetting"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; sourceLast.name &#125;&#125;: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-time-picker</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-for</span>=<span class="string">"(res, m) of sourceLast.items"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:key</span>=<span class="string">"m"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">v-model</span>=<span class="string">"sourceLast.items[m]"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">is-range</span></span></span><br><span class="line"><span class="tag">            <span class="attr">format</span>=<span class="string">"HH:mm"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">value-format</span>=<span class="string">"HH:mm"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">range-separator</span>=<span class="string">"-"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">size</span>=<span class="string">"mini"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">start-placeholder</span>=<span class="string">"开始时间"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">end-placeholder</span>=<span class="string">"结束时间"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">placeholder</span>=<span class="string">"选择时间范围"</span></span></span><br><span class="line"><span class="tag">          /&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"success"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">icon</span>=<span class="string">"el-icon-circle-plus"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">circle</span></span></span><br><span class="line"><span class="tag">            <span class="attr">size</span>=<span class="string">"mini"</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">"lastAdd(sourceLast)"</span></span></span><br><span class="line"><span class="tag">          /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      date: <span class="string">''</span>,</span></span><br><span class="line">      sourceFirst: [</span><br><span class="line">        &#123;</span><br><span class="line"><span class="actionscript">          name: <span class="string">'峰时段'</span>,</span></span><br><span class="line">          items: [],</span><br><span class="line"><span class="actionscript">          radio: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          change: <span class="string">''</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="actionscript">          name: <span class="string">'谷时段'</span>,</span></span><br><span class="line">          items: [],</span><br><span class="line"><span class="actionscript">          radio: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          change: <span class="string">''</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line"><span class="actionscript">          name: <span class="string">'缓冲时段'</span>,</span></span><br><span class="line">          items: [],</span><br><span class="line"><span class="actionscript">          radio: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">          change: <span class="string">''</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      sourceLast: &#123;</span><br><span class="line"><span class="actionscript">        name: <span class="string">'平时段'</span>,</span></span><br><span class="line">        items: [],</span><br><span class="line"><span class="actionscript">        radio: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">        change: <span class="string">''</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onAdd(name, source) &#123;</span><br><span class="line"><span class="javascript">      source.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line">        if (item.name == name) &#123;</span><br><span class="line"><span class="actionscript">          item.items.push(<span class="string">' '</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    onDelete(time, source) &#123;</span><br><span class="line"><span class="javascript">      source.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line">        if (item.name == time.name &amp;&amp; time.items.length &gt;= 1) &#123;</span><br><span class="line">          item.items.pop()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="comment">// 获得输入时间段数组</span></span></span><br><span class="line">    getArr() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> arr = []</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.sourceFirst.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line">        if (item.name) &#123;</span><br><span class="line"><span class="javascript">          item.items.map(<span class="function"><span class="params">m</span> =&gt;</span> &#123;</span></span><br><span class="line">            arr.push(m)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> arr</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="comment">// 显示按钮</span></span></span><br><span class="line">    lastAdd(last) &#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">// 获得时间段数组</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> arr = <span class="keyword">this</span>.getArr()</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> newArr = []</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 时间格式化为HH:mm形式</span></span></span><br><span class="line"><span class="javascript">      arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (item != <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="actionscript">          newArr.push([(<span class="string">'0'</span> + item[<span class="number">0</span>].getHours().toString()).slice(<span class="number">-2</span>) + <span class="string">':'</span> + (<span class="string">'0'</span> + item[<span class="number">0</span>].getMinutes().toString()).slice(<span class="number">-2</span>),</span></span><br><span class="line"><span class="actionscript">            (<span class="string">'0'</span> + item[<span class="number">1</span>].getHours().toString()).slice(<span class="number">-2</span>) + <span class="string">':'</span> + (<span class="string">'0'</span> + item[<span class="number">1</span>].getMinutes().toString()).slice(<span class="number">-2</span>)])</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> result = <span class="keyword">this</span>.time(newArr)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(result)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.sourceLast.items = result</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="comment">// time 计算方法</span></span></span><br><span class="line">    time(arr) &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> newArr = <span class="keyword">this</span>.formatTime(arr)</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> sortArr = <span class="keyword">this</span>.timeSort(newArr) <span class="comment">// 时间段进行排序</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(sortArr)</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> aaa = <span class="string">'00:00'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> bbb = <span class="string">'23:59'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> resArr = []</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 开始比较</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (sortArr[<span class="number">0</span>] != <span class="literal">undefined</span> &amp;&amp; aaa &lt; sortArr[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span></span><br><span class="line">        resArr.push([aaa, sortArr[0][0]])</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      sortArr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line">        if (index === sortArr.length - 1) &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> startTime = item[<span class="number">1</span>]</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> endTime = sortArr[index + <span class="number">1</span>][<span class="number">0</span>]</span></span><br><span class="line">        if (startTime &lt; endTime) &#123;</span><br><span class="line">          resArr.push([startTime, endTime])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (sortArr[sortArr.length - <span class="number">1</span>] != <span class="literal">undefined</span> &amp;&amp; bbb &gt; sortArr[sortArr.length - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span></span><br><span class="line">        resArr.push([sortArr[sortArr.length - 1][1], bbb])</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> resArr</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果存在 ['22:00','00:10']  这样格式的 转化为['22:00','23:59'] 和['00:00','00:10']</span></span></span><br><span class="line">    formatTime(arr) &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> newArr = [...arr]</span></span><br><span class="line"><span class="javascript">      arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">Date</span>.parse(<span class="string">`2000/01/01 <span class="subst">$&#123;item[<span class="number">0</span>]&#125;</span>:00`</span>) &gt; <span class="built_in">Date</span>.parse(<span class="string">`2000/01/01 <span class="subst">$&#123;item[<span class="number">1</span>]&#125;</span>:00`</span>)) &#123;</span></span><br><span class="line">          newArr.splice(index, 1)</span><br><span class="line"><span class="actionscript">          newArr.push([item[<span class="number">0</span>], <span class="string">'23:59'</span>])</span></span><br><span class="line"><span class="actionscript">          newArr.push([<span class="string">'00:00'</span>, item[<span class="number">1</span>]])</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> newArr</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="comment">// 时间  排序</span></span></span><br><span class="line">    timeSort(arr) &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> arrSort = arr.sort(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">Date</span>.parse(<span class="string">`2000/01/01 <span class="subst">$&#123;a[<span class="number">0</span>]&#125;</span>:00`</span>) - <span class="built_in">Date</span>.parse(<span class="string">`2000/01/01 <span class="subst">$&#123;b[<span class="number">0</span>]&#125;</span>:00`</span>)</span></span><br><span class="line">      &#125;)</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> arrSort</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.peakValleySetting</span> &#123;</span></span><br><span class="line">  position: relative;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 50%;</span><br><span class="line"><span class="css">  <span class="comment">/* padding: 10px; */</span></span></span><br><span class="line">  background-color: white;</span><br><span class="line">  border: 2px solid rgb(141, 137, 79);</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.dateSetting</span> &#123;</span></span><br><span class="line">  margin-bottom: 20px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.el-date-editor</span><span class="selector-class">.el-input</span>,</span></span><br><span class="line"><span class="css"><span class="selector-class">.el-date-editor</span><span class="selector-class">.el-input__inner</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">width</span>: 12<span class="selector-class">.105vw</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目中的难点</category>
      </categories>
      <tags>
        <tag>项目中的难点</tag>
      </tags>
  </entry>
</search>
